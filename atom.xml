<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Shuping LIU]]></title>
  <subtitle><![CDATA[A JavaScript and C# developer]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://blog.liushuping.com/"/>
  <updated>2016-04-12T17:17:47.000Z</updated>
  <id>http://blog.liushuping.com/</id>
  
  <author>
    <name><![CDATA[Shuping LIU]]></name>
    <email><![CDATA[lsp.lhh@gmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[map reduce 与 MapReduce]]></title>
    <link href="http://blog.liushuping.com/2016/04/12/map-reduce-%E4%B8%8E-MapReduce/"/>
    <id>http://blog.liushuping.com/2016/04/12/map-reduce-与-MapReduce/</id>
    <published>2016-04-12T14:58:27.000Z</published>
    <updated>2016-04-12T17:17:47.000Z</updated>
    <content type="html"><![CDATA[<p>昨天一个偶然的机会跟同事讨论了<a href="https://en.wikipedia.org/wiki/MapReduce" target="_blank" rel="external">MapReduce</a>这个产品和<a href="http://baike.baidu.com/view/1711147.htm" target="_blank" rel="external">函数式编程</a>中最出名的两个函数<a href="https://en.wikipedia.org/wiki/Map_(higher-order_function" target="_blank" rel="external">map</a>和<a href="https://en.wikipedia.org/wiki/Map_(higher-order_function" target="_blank" rel="external">reduce/fold</a>之间的关系。是仅仅的名字巧合吗？还是存在着某种关系？<a id="more"></a><a href="https://en.wikipedia.org/wiki/MapReduce" target="_blank" rel="external">Wikipedia</a>对两者的关系有明确的解释：</p>
<blockquote>
<p>The model is inspired by the map and reduce functions commonly used in functional programming,[6] although their purpose in the MapReduce framework is not the same as in their original forms.[7] The key contributions of the MapReduce framework are not the actual map and reduce functions, but the scalability and fault-tolerance achieved for a variety of applications by optimizing the execution engine once. </p>
</blockquote>
<p>意思是说，MapReduce的名字受函数式编程中的map和reduce两个函数的名字启发，但是在MapReduce中，”map”和”reduce”不是函数式编程中的map和reduce的本意。</p>
<p>我们也讨论到MapReduce其实是一个Divide and Conquer的算法，那么它为什么不叫DivideConquer这个名呢？个人认为，就针对这个产品而言，DivideConquer这个名字比MapReduce逊色很多。要了解MapReduce的命名，我们需要从了解函数式编程中的map和reduce(或fold)两个函数入手。</p>
<h2 id="函数式编程中的map和reduce">函数式编程中的map和reduce</h2><p>map和reduce是函数式编程中两个最出名，最重要的<a href="https://en.wikipedia.org/wiki/Higher-order_function" target="_blank" rel="external">高阶函数(High Order Function)</a>。什么是高阶函数？它和初中时学的高次（高阶）方程同属一个概念。简单来说，一个函数能被称为高阶函数，它应具备下列2个要素中的至少一点：</p>
<ol>
<li>它能接受另外一个函数作为参数</li>
<li>它的返回值可以是另外一个函数</li>
</ol>
<p>毫无疑问，map和reduce函数都能满足上述两点。这里又引出了另外一个概念：<a href="https://en.wikipedia.org/wiki/First-class_function" target="_blank" rel="external">函数是一等公民(First-class Function)</a>。此处“一等公民”并非指社会地位高下的概念，而是指First-class Function要求编程语言支持把函数作为参数传递或能作为另外一个函数的返回值。因此，函数式编程语言支持First-class Function，而高阶函数的整套体系是构建在其基础之上的。</p>
<p>那么为什么高阶函数是函数式编程的一个核心概念？因为高阶提供了高层次的抽象，而<a href="http://blog.liushuping.com/2014/08/19/think-in-abstraction/">抽象是解决复杂问题（比如软件问题）的强有力工具</a>。</p>
<p>世间函数千千万，那么为什么唯独map，reduce两个函数如此与众不同？这就需要我们去关注一下函数所操作的数据对象，大致可以分为两类：个体或少量几个数据；某类数据的一个集合。对于个体或少量数据，能应用于它们的函数通常各不相同，共性比较少；而可应用于集合类数据的函数，大多具有通用的模式：</p>
<ul>
<li>模式一：对集合内每一个数据做某种转换处理，返回具有同等数量的不同类型集合</li>
<li>模式二：对集合内数据做累积操作，返回一个数据或另外一个不同数量的集合</li>
</ul>
<p>很明显的，模式一可以归纳出一个名字叫”map”，即把某种“转换处理”应用到集合中的每一个元素去。而这种“转换处理”有无数种可能，因此我们把“转换处理”这个函数以参数的形式传给map这个高阶函数。</p>
<p>同理，模式二可以归纳出一个名字叫”reduce”，即把某种“累积操作”逐步应用到集合中的每一个元素去，并最后把累加结果返回。而这种“累积操作”有无数种可能，因为我们把函数以参数的形式传给reduce这个高阶函数。</p>
<h2 id="MapReduce的命名为何对map和reduce函数情有独钟？">MapReduce的命名为何对map和reduce函数情有独钟？</h2><p>MapReduce是一个基于计算机集群的并行、分布式计算框架。它在很大程度上受函数式编程语言中的map和reduce所启发，对分布式计算进行高阶抽象，去除变化的部分，保留不变的框架。它认为：大多数分布式计算可以归纳为下列两种操作的多种组合：</p>
<ul>
<li>对所有数据块（分布于多台计算机上）进行“某种操作”</li>
<li>对局部或所有数据块做数据“汇总操作”</li>
</ul>
<p>看！这是多么的美妙！完全符合之前提到的两个模式。</p>
<p>Hadoop充分吸纳了map，reduce两个函数的精华：在集群机器间移动数据是很耗费资源的，因为它们选择移动函数，函数是一等公民的绝美应用！</p>
<h2 id="为什么是MapReduce而不是”DivideConquer”?">为什么是MapReduce而不是”DivideConquer”?</h2><p>从本质上来说MapReduce框架属于Divide Conquer的一种。然而针对这个产品，“DividerConquer” 这个命名比MapReduce逊色很多，主要有两点：</p>
<ul>
<li>Divider conquer明确提出了“分而治之”的思路，却没有明确提出“汇总“这个在MapReduce产品中占1/2的思想</li>
<li>MapReduce更加具体地描述了产品的工作流，属于准确的抽象–既有抽象的高可用性，又不失抽象的准确性与实用性。</li>
</ul>
<h2 id="打开另一个世界的大门">打开另一个世界的大门</h2><p>如果您对本文的理解存在困难，我强烈您阅读一些函数式编程的书籍和文章。相信我，一旦您掌握了它，您就打开了一扇通往另一个编程世界的大门（假如面向对象和面向过程是您已经打开的两扇大门）。门的另一侧，是一个美轮美奂的世界。</p>
<p>如果从来没了解过函数式编程，那么我建议您从最纯正的函数语言<a href="https://www.haskell.org/" target="_blank" rel="external">Haskell</a>开始。</p>
<p><a href="http://learnyouahaskell.com/" target="_blank" rel="external">Learn You a Haskell for Great Good!</a>一书妙语连珠，妙趣横生，深入浅出，有趣有料。作者自己画的插画更是生动活泼！我一直坚信：会画画的程序员是非常有前途的！(这个以后详细展开来说)。<br><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Flearnyouahaskell.png" alt="learn you a haskell for great good!"></p>
<p>如果您想找一本更加系统详实的Haskell书，那么看<a href="http://book.realworldhaskell.org/" target="_blank" rel="external">Real World Haskell</a>吧。它介绍了Haskell语言的每一个细节，当然你要有足够的耐心和毅力。</p>
<p>如果您想偏理论角度地研究一下为什么高阶函数很重要，那么我推荐您看一下这篇学术文章：High Order + Polymorphic = Reuse: <a href="http://citeseerx.ist.psu.edu/showciting?cid=577419" target="_blank" rel="external">http://citeseerx.ist.psu.edu/showciting?cid=577419</a></p>
<p>如果您想理论性地研究一下函数式编程，那么我推荐您看一下这篇神作，神作，神作：Theorems for free：<a href="http://ecee.colorado.edu/ecen5533/fall11/reading/free.pdf" target="_blank" rel="external">http://ecee.colorado.edu/ecen5533/fall11/reading/free.pdf</a> 在这篇文章里您可以学到如何用lambda组合子（或<a href="https://en.wikipedia.org/wiki/Fixed-point_combinator#Fixed_point_combinators_in_lambda_calculus" target="_blank" rel="external">Y Combinator</a>）来实现匿名函数的递归。《黑客与画家》的作者成立的创业孵化公司Y Combinator的名字就是来源于函数式编程。（想想吧，这又是一个美妙的名字)</p>
<p>好吧，如果您对函数式编程的纯理论性研究感兴趣，这完全超出我的能力了，但您去看<a href="https://en.wikipedia.org/wiki/Lambda_calculus" target="_blank" rel="external">Lambda Caculus</a>一准儿是没错的了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>昨天一个偶然的机会跟同事讨论了<a href="https://en.wikipedia.org/wiki/MapReduce">MapReduce</a>这个产品和<a href="http://baike.baidu.com/view/1711147.htm">函数式编程</a>中最出名的两个函数<a href="https://en.wikipedia.org/wiki/Map_(higher-order_function">map</a>和<a href="https://en.wikipedia.org/wiki/Map_(higher-order_function">reduce/fold</a>之间的关系。是仅仅的名字巧合吗？还是存在着某种关系？]]>
    
    </summary>
    
      <category term="map, reduce, MapReduce" scheme="http://blog.liushuping.com/tags/map-reduce-MapReduce/"/>
    
      <category term="Functional Programming" scheme="http://blog.liushuping.com/categories/Functional-Programming/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[伪基站之害]]></title>
    <link href="http://blog.liushuping.com/2016/03/29/%E4%BC%AA%E5%9F%BA%E7%AB%99%E4%B9%8B%E5%AE%B3/"/>
    <id>http://blog.liushuping.com/2016/03/29/伪基站之害/</id>
    <published>2016-03-29T13:44:51.000Z</published>
    <updated>2016-03-29T15:50:24.000Z</updated>
    <content type="html"><![CDATA[<p>或许你不清楚什么是伪基站，但你一定遭受过伪基站的骚扰或者欺骗（希望你没有蒙受损失），因为大多数手机诈骗短信都来自于伪基站。</p>
<h1 id="伪基站">伪基站</h1><p>什么事伪基站呢？<a href="http://baike.baidu.com/view/8940201.htm" target="_blank" rel="external">百度百科</a>上的解释:</p>
<blockquote>
<p>伪基站”即假基站，设备一般由主机和笔记本电脑组成，通过短信群发器、短信发信机等相关设备能够搜取以其为中心、一定半径范围内的手机卡信息，通过伪装成运营商的基站，冒用他人手机号码强行向用户手机发送诈骗、广告推销等短信息。</p>
</blockquote>
<a id="more"></a>
<p>受伪基站影响的手机会有什么异常吗？<a href="http://baike.baidu.com/view/8940201.htm" target="_blank" rel="external">百度百科</a>上说：</p>
<blockquote>
<p>伪基站设备运行时，用户手机信号被强制连接到该设备上，导致手机无法正常使用运营商提供的服务，手机用户一般会暂时脱网8～12 秒后恢复正常，部分手机则必须开关机才能重新入网。此外，它还会导致手机用户频繁地更新位置，使得该区域的无线网络资源紧张并出现网络拥塞现象，影响用户的正常通信。</p>
</blockquote>
<p>事实上，现在伪基站可以强制手机连接到其设备上长达将近2分钟了。而这2分钟内用户可能完全觉察不出来任何异常。今天就说一下我切身经历过且觉察到的这2分钟。</p>
<h1 id="我的经历">我的经历</h1><p>下午去银行办一个业务。由于涉及到的金额相对比较大，营业员需要面对面地验证所登记的手机号码归我本人所有。营业员拿起银行专用电话（外观跟遥控器类似）拨我的手机号，然后让我现场出示来电显示以确定号码归我所有。然后，奇怪的事情就发生了。</p>
<p>第一次拨打，营业员表示电话打通了，然而我的手机却没有响铃。因为是面对面地验证手机，我便仔细关注着手机，也得以巧合地看到了此时在几秒内手机信号强度变化的过程是：<code>4G -&gt; E -&gt; G -&gt; E</code>。反应快的你也许看出来了，此时手机已经从一个信号源切换到另一个信号源了。当然，也不排除手机信号由强到弱又到强的可能性。现在想来，营业员刚刚拨通我手机的那一刻，我的手机信号被伪基站给强制切换了，以至于手机还未来得及响铃。然后，这几秒钟的微小变化是很难引起手机用户怀疑的。</p>
<p>我跟营业员确认了一下手机号码没有登记错误。营业员接着进行了第二次拨打，同时我也略微紧张地盯着手机屏幕，生怕一不看就会错过铃声的响起。有时候担心是一种很奇妙的体验：你所担心的事情总是有很大几率发生，哪怕你从逻辑上分析这件事情的发生概率很小。在常规的铃声等待时间内手机并没有响起，取而代之的是手机突然收到了一条短信。还是反应快的你，应该猜到短信不是发自银行，而是来自伪基站的欺骗短信——这是伪基站捕获手机后要干的事情。<br><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Fpirate_station_msg" alt="img"></p>
<p>这里要感谢一下腾讯手机管家，很好地识别出了伪基站欺骗，能有效地提高用户的警惕性。当然了，短信中显而易见的伪造网址是完全欺骗不了我的，我根本不会去访问那个网址的。得益于所从事的工作，我对网站的安全以及欺骗相关知识还略知一二，然而对网络（不是“网站”）和设备层的安全，我还处于新手阶段。因此，我仍然没有意识到手机已经连到了一个非法设备上了。</p>
<p>接下来是第三次拨打电话。那时那刻，我已经有些紧张了：营业员不会怀疑我有什么不轨举动吧？当然这也是短暂的想法，很快就恢复了平静，因为我确认我是诚信地办理着合法的业务。</p>
<p>终于如愿以偿地手机在第四次拨打时响起了铃声，我也在手机上看到了满格的4G信号。手机归属验证通过后，营业员分两次发送手机验证码的方式完成了我的业务办理。我不清楚，如果在验证码发送期间手机被伪基站劫持会发生什么。。。</p>
<p>故事没有结束。直到业务办理完毕，我都没有意识到手机被伪基站劫持过。业务办理完毕，出来银行，心情放松了一下，就习惯性地打开手机随便点了一个程序。然后。。。。我的手机再一次被伪基站劫持（或者是一直被劫持？）。我要再一次感谢腾讯手机管家，因为这次它给了我明确地提醒：<br><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Fpirate_station_warn" alt="img"></p>
<p>然而这并没有结束，再一次反应快的你会从上面的截图（右下角）发现手机还有被<a href="http://baike.baidu.com/item/%E6%B5%81%E9%87%8F%E5%8A%AB%E6%8C%81" target="_blank" rel="external">流量劫持</a>的嫌疑。至此，我终于意识到问题的严重性，关掉网络与手机信号并离开这个伪基站覆盖范围。</p>
<h1 id="伪基站在哪儿？">伪基站在哪儿？</h1><p>它可能在银行周边的某个角落里；某个阴暗房间里；门口某个人的背包里；某个人的拉杆箱里；或者旁边某车的后备箱甚至副驾驶座上。总之，那个人跟我相距不远。事实上，在上午来办业务时，那个人就有可能在那里了（1公里范围内）。因为上午我就发现了信号的<code>4G -&gt; (3G) -&gt; E -&gt; G -&gt; E -&gt; (3G) -&gt; 4G</code>可疑过程了（在一个信号良好的区域），只是上午没用到手机而已。</p>
<p>如果你在大街上、公路上，看到有普通车辆外置长长的或短短的“天线”，抑或在靠近车窗玻璃的某个位置看见内置“天线”，不要天真地认为那是车主想听“BBC”广播。那有可能根本不是个“接收”天线，而是个“发射”天线，连接天线的末端很有可能就是一台伪基站。</p>
<h1 id="什么最不安全？">什么最不安全？</h1><p>有个不争的事实：在所有的技术中，互联网是最不安全的。现在我认为，如果电话系统不能归为互联网大类中的话，那么电话系统是最不安全的：无加密，随意被劫持，易被监听等。一个小学文化水平的行骗者，可以花较少的钱（几千人民币）伪造任意的电话号码。而一个网站域名，在没有<a href="http://baike.baidu.com/subview/3163602/3163602.htm" target="_blank" rel="external">DNS劫持</a>或<a href="http://baike.baidu.com/view/4040394.htm" target="_blank" rel="external">DNS污染</a>的情况下，是极难（个人认为不可能）被伪造的。而DNS劫持或污染的难度又很大。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>或许你不清楚什么是伪基站，但你一定遭受过伪基站的骚扰或者欺骗（希望你没有蒙受损失），因为大多数手机诈骗短信都来自于伪基站。</p>
<h1 id="伪基站">伪基站</h1><p>什么事伪基站呢？<a href="http://baike.baidu.com/view/8940201.htm">百度百科</a>上的解释:</p>
<blockquote>
<p>伪基站”即假基站，设备一般由主机和笔记本电脑组成，通过短信群发器、短信发信机等相关设备能够搜取以其为中心、一定半径范围内的手机卡信息，通过伪装成运营商的基站，冒用他人手机号码强行向用户手机发送诈骗、广告推销等短信息。</p>
</blockquote>]]>
    
    </summary>
    
      <category term="Security" scheme="http://blog.liushuping.com/tags/Security/"/>
    
      <category term="Security" scheme="http://blog.liushuping.com/categories/Security/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[完成Coursera Machine Learning课程]]></title>
    <link href="http://blog.liushuping.com/2016/03/01/%E5%AE%8C%E6%88%90Cousera-Machine-Learning%E8%AF%BE%E7%A8%8B/"/>
    <id>http://blog.liushuping.com/2016/03/01/完成Cousera-Machine-Learning课程/</id>
    <published>2016-03-01T14:40:57.000Z</published>
    <updated>2016-03-02T16:45:46.000Z</updated>
    <content type="html"><![CDATA[<h1 id="完成了一个目标">完成了一个目标</h1><p>经过了十周多的奋斗，我终于完成了<a href="http://baike.baidu.com/view/10853998.htm?fromtitle=Andrew+Ng" target="_blank" rel="external">Andrew Ng</a>的<a href="https://www.coursera.org/learn/machine-learning" target="_blank" rel="external">Machine Learning</a>课程并获得证书，这也是2016年我完成的第一个个人目标。<br><a id="more"></a></p>
<p><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Fcoursera-machine-learning-cert" alt="cert"></p>
<h1 id="过程值的回忆">过程值的回忆</h1><p>过去的十周内，有多少个夜深人静的夜晚，当他人已经进入梦乡，我仍在观看着视频、调试着程序。期间也经历了突击课程进度的艰难过程，为的是能提前完成春节期间的课程。大多数的课程都开始于下班回家，且给闺女讲完睡前故事之后，通常是晚上9点以后了。</p>
<p>课程注册之初，大致预测了一下可能会遇到的困难，总结有：数学的障碍，<a href="http://www.gnu.org/software/octave/" target="_blank" rel="external">Octave</a>陌生的语言，时间问题（晚上要先陪闺女玩儿）等等。然而最终的事实证明，这些都不是问题。而最大的问题是：宽带通！（此处预留一个<a href="http://blog.liushuping.com/2016/02/23/I-will-call-you-back/">Callback</a>，待以后详解。）</p>
<h1 id="目标要以总结结束">目标要以总结结束</h1><p>学完一门课程，做一些简单的总结，总是有好处的。喜欢对一件复杂的事情做一些通俗易懂的描述，让尽可能多的人理解（显然，我无法做到让隔壁的老奶奶也能听懂的极致）。数学公式是尽量避免去用的，虽然它是Machine Learning的灵魂，但是概念性的普及介绍却不必使用它。</p>
<p>Machine Learning很有趣，很有用，也很有挑战性。它又依赖于系统的软件工程。</p>
<ul>
<li>有趣：<a href="http://www.msxiaoice.com/DesktopLanding" target="_blank" rel="external">微软小冰</a>等有趣应用都是Machine Learning的具体应用</li>
<li>有用：照片、文字识别，自动驾驶等等极大地方便了生活</li>
<li>挑战：参考Google的<a href="http://baike.baidu.com/item/%E9%98%BF%E5%B0%94%E6%B3%95%E5%9B%B4%E6%A3%8B?fromtitle=AlphaGo" target="_blank" rel="external">阿尔法狗(AlphaGo)</a></li>
<li>软件工程：只有良好的系统架构、编码才能实现真正的Machine Learning应用</li>
</ul>
<p>用简短的话介绍<a href="https://www.coursera.org/" target="_blank" rel="external">Coursera</a>上<a href="http://baike.baidu.com/view/10853998.htm?fromtitle=Andrew+Ng" target="_blank" rel="external">Andrew Ng</a>的<a href="https://www.coursera.org/learn/machine-learning" target="_blank" rel="external">Machine Learning</a>课程。我的片面总结如下：</p>
<h2 id="Machine_Learning之基本思路">Machine Learning之基本思路</h2><p>Machine Learning用大量的数据，通过一定的学习算法让计算机具有一定的“智能”，比如预测、分类等。在面对大量数据时，计算机不可能一次完成学习任务，因此我们需要设计一个“渐进”的学习方式，让计算机逐渐完善其“智能”水平。这个“渐进”的过程，在程序代码的领域来讲，就是“迭代”。不断地迭代，调整参数，从而达到提高机器“学习”效果的目的。</p>
<h2 id="Machine_Learning“之学习效果”的评估">Machine Learning“之学习效果”的评估</h2><p>如何在迭代的基本框架下，来评价当前参数下的“学习”效果呢？我们很容易想到的是建立一个误差函数，对已知的输入数据，应用当前的学习算法，得到预测的结果。根据预测的结果和实际结果，计算<a href="http://baike.baidu.com/view/172036.htm" target="_blank" rel="external">方差</a>或<a href="http://baike.baidu.com/view/78339.htm" target="_blank" rel="external">标准差</a>，即可以作为我们的误差函数。这种以已知数据作为参考的“学习”过程被称为<a href="http://baike.baidu.com/view/2759226.htm" target="_blank" rel="external">“监督学习”</a>或<a href="https://en.wikipedia.org/wiki/Supervised_learning" target="_blank" rel="external">“Supervised Learning”</a>。而<a href="http://baike.baidu.com/view/2759226.htm" target="_blank" rel="external">“监督学习”</a>又可分为<a href="http://baike.baidu.com/view/449540.htm" target="_blank" rel="external">“线性回归”</a>(<a href="https://en.wikipedia.org/wiki/Linear_regression" target="_blank" rel="external">“Linear Regression”</a>)和<a href="http://baike.baidu.com/item/logistic%E5%9B%9E%E5%BD%92?fromtitle=%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92&amp;type=syn" target="_blank" rel="external">“逻辑回归”</a>(<a href="https://en.wikipedia.org/wiki/Logistic_regression" target="_blank" rel="external">“Logistic Regression”</a>)等常见类别。</p>
<h2 id="Machine_Learning之“学习方法”的改善">Machine Learning之“学习方法”的改善</h2><p>通常我们从随机化学习算法的参数开始，因为参数是我们最终要得到的，而开始之初我们并不知道它。因此我们希望每一步迭代都对参数做微小的改动，以使算法结果不断<a href="http://baike.baidu.com/subview/513233/8059330.htm" target="_blank" rel="external">“收敛”</a>，又或者说是使误差函数产生的结果越来越小。那么怎么做呢？</p>
<p>假如我们把误差函数画出来，以三维的一个曲面为例（高维空间无法绘制，但是具有相同的性质），误差函数结果最小的点就是三维曲面的最低点。我们的目标就是采取一种有效的措施来改变参数使误差函数的结果沿着三维空间坡度最陡的方向向下移动。用数学的概念来介绍，就是<a href="http://baike.baidu.com/view/30958.htm" target="_blank" rel="external">导数</a>，或者更准确一点，<a href="http://baike.baidu.com/view/1029405.htm" target="_blank" rel="external">偏导数</a>。因此，迭代过程内对参数做的微小改动就是对每个参数减去该参数所对应“特征”的<a href="http://baike.baidu.com/view/1029405.htm" target="_blank" rel="external">偏导数</a>。</p>
<p>参数的这种改变方式从本质上来说是<a href="http://baike.baidu.com/view/150456.htm" target="_blank" rel="external">连续</a>的，它适合被用在<a href="http://baike.baidu.com/view/449540.htm" target="_blank" rel="external">“线性回归”</a>问题上。但当一个问题是<a href="http://baike.baidu.com/item/logistic%E5%9B%9E%E5%BD%92?fromtitle=%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92&amp;type=syn" target="_blank" rel="external">“逻辑回归”</a>（如根据某些数据判断某个操作是否来自于人或机器等这种是非问题的判断）时怎么办呢？其实很简单：只需对<a href="http://baike.baidu.com/view/449540.htm" target="_blank" rel="external">“线性回归”</a>问题的学习方程进行一次转换，使其输出结果只有两种可能：0或1。适合这个问题的一个常用函数是<a href="http://baike.baidu.com/view/1176976.htm" target="_blank" rel="external">sigmoid函数</a>。关于<a href="http://baike.baidu.com/view/1176976.htm" target="_blank" rel="external">sigmoid函数</a>，此处也留一个<a href="http://blog.liushuping.com/2016/02/23/I-will-call-you-back/">Callback</a>。</p>
<h2 id="Machine_Learning之人工神经网络">Machine Learning之人工神经网络</h2><p><a href="http://baike.baidu.com/view/449540.htm" target="_blank" rel="external">“线性回归”</a>和<a href="http://baike.baidu.com/item/logistic%E5%9B%9E%E5%BD%92" target="_blank" rel="external">“逻辑回归”</a>都是通过建立一个<a href="http://baike.baidu.com/view/6156797.htm" target="_blank" rel="external">多项式函数</a>来实现对训练数据最大程度的拟合，比如最简单的函数 <code>y = ax + b</code>。<a href="http://baike.baidu.com/view/449540.htm" target="_blank" rel="external">“线性回归”</a>和<a href="http://baike.baidu.com/item/logistic%E5%9B%9E%E5%BD%92" target="_blank" rel="external">“逻辑回归”</a>的任务都是通过迭代来不断优化参数<code>a</code>和<code>b</code>(对于一阶方程来说)来实现最大程度地减少误差。然而，有很多问题我们很难找到一个合适的<a href="http://baike.baidu.com/view/6156797.htm" target="_blank" rel="external">多项式函数</a>来对数据进行<a href="http://baike.baidu.com/subview/133261/5033269.htm" target="_blank" rel="external">数学建模</a>，或者是<a href="http://baike.baidu.com/view/6156797.htm" target="_blank" rel="external">多项式函数</a>过于复杂，带来的计算量非常大。这时可以考虑使用<a href="http://baike.baidu.com/view/19743.htm" target="_blank" rel="external">人工神经网络</a>。</p>
<p>概括地来说，<a href="http://baike.baidu.com/view/19743.htm" target="_blank" rel="external">人工神经网络</a>的<a href="http://baike.baidu.com/subview/133261/5033269.htm" target="_blank" rel="external">数学模型</a>是一个由很多节点组成的网状结构。每个节点都是一个处理单元，能对接收到的数据做计算，其输出结果将是下层网络节点的计算输入。通过调节网络的层数、每层上计算节点的个数，以及对每个节点的参数等来优化<a href="http://baike.baidu.com/subview/133261/5033269.htm" target="_blank" rel="external">数学模型</a>，从而实现对训练数据的模拟，以及对未来数据的分析预测。<a href="http://baike.baidu.com/view/19743.htm" target="_blank" rel="external">人工神经网络</a>是一个很大的话题，本文仅做一般认识性介绍。</p>
<h2 id="Machine_Learning之聚类分析">Machine Learning之聚类分析</h2><p>然而，并不是所有的问题都是根据历史数据预测未来结果。还有一类问题是：给定一些数据，让计算机智能地对数据进行分类。这类问题叫<a href="http://baike.baidu.com/view/903740.htm" target="_blank" rel="external">“聚类分析”</a>，解决这类问题的一个重要算法是“<a href="http://baike.baidu.com/view/3066906.htm" target="_blank" rel="external">K均数</a>”算法。这个算法是如此简单而有效地应用了基本的数学知识对数据进行了分类！我强烈推荐您了解一下。</p>
<h2 id="Machine_Learning之主成份分析">Machine Learning之主成份分析</h2><p>对于给定的数据，在有些情况下数据所包涵的众多特征中，仅有几个特征起主导作用。此时，我们可以对数据进行<a href="http://baike.baidu.com/view/45376.htm" target="_blank" rel="external">主成分分析(Principle Component Analysis)</a>，选取几个主要成份来代表数据，从而达到数据压缩的目的。比如，要对某大量数据做Machine Learning分析，但发现由于数据太大，计算过程非常耗时，此时可以尝试用主成份分析来对数据进行压缩。<a href="http://baike.baidu.com/view/45376.htm" target="_blank" rel="external">主成分分析</a>的另外一个应用是图像的压缩，可以通过分析图像的前16种主颜色成份，把图像从256色压缩到16色。</p>
<h2 id="Machine_Learning之性能优化">Machine Learning之性能优化</h2><p>性能优化永远是Machine Learning领域的一个重要话题，因为数据容量是如此之大，每一点计算过程的优化都有可能带来整体效率上的显著提高。在<a href="http://baike.baidu.com/view/10853998.htm?fromtitle=Andrew+Ng" target="_blank" rel="external">Andrew Ng</a>的<a href="https://www.coursera.org/learn/machine-learning" target="_blank" rel="external">Machine Learning</a>课程中最让人拍案叫绝的一段数学证明是<a href="https://en.wikipedia.org/wiki/Support_vector_machine" target="_blank" rel="external">Support Vector Machine</a>如何有效地改善了<a href="http://baike.baidu.com/view/2759226.htm" target="_blank" rel="external">“监督学习”</a>中的分类算法。</p>
<p>另一个重要的性能优化则完全来自于计算机科学，那就是<a href="https://en.wikipedia.org/wiki/Array_programming" target="_blank" rel="external">Vectorization</a>。最擅长做<a href="https://en.wikipedia.org/wiki/Array_programming" target="_blank" rel="external">Vectorization</a>的是<a href="https://en.wikipedia.org/wiki/Graphics_processing_unit" target="_blank" rel="external">GPU</a>，当然现如今的大多数<a href="https://en.wikipedia.org/wiki/Central_processing_unit" target="_blank" rel="external">CPU</a>也已经支持<a href="https://en.wikipedia.org/wiki/Array_programming" target="_blank" rel="external">Vectorization</a>了。因此，在代码的实现上，软件工程师时刻牢记<a href="https://en.wikipedia.org/wiki/Array_programming" target="_blank" rel="external">Vectorization</a>的实现方式是至关重要的。</p>
<p>然而无论如何，超大规模的Machine Learning是不可能在一台机器上完成的，当需要在多台甚至成千上万台机运行时，就需要<a href="http://baike.baidu.com/view/2902.htm" target="_blank" rel="external">MapReduce</a>等类似的分布式框架来帮忙了。</p>
<h1 id="结论">结论</h1><p>Machine Learning很有趣，它需要一些数学知识、算法和软件工程思想来实现。<a href="http://baike.baidu.com/view/10853998.htm?fromtitle=Andrew+Ng" target="_blank" rel="external">Andrew Ng</a>的<a href="https://www.coursera.org/learn/machine-learning" target="_blank" rel="external">Machine Learning</a>课程深入浅出，循序渐进，有趣，有料！</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="完成了一个目标">完成了一个目标</h1><p>经过了十周多的奋斗，我终于完成了<a href="http://baike.baidu.com/view/10853998.htm?fromtitle=Andrew+Ng">Andrew Ng</a>的<a href="https://www.coursera.org/learn/machine-learning">Machine Learning</a>课程并获得证书，这也是2016年我完成的第一个个人目标。<br>]]>
    
    </summary>
    
      <category term="Coursera" scheme="http://blog.liushuping.com/tags/Coursera/"/>
    
      <category term="Machine Learning" scheme="http://blog.liushuping.com/tags/Machine-Learning/"/>
    
      <category term="Stanford" scheme="http://blog.liushuping.com/tags/Stanford/"/>
    
      <category term="Machine Learning" scheme="http://blog.liushuping.com/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[I will call you back]]></title>
    <link href="http://blog.liushuping.com/2016/02/23/I-will-call-you-back/"/>
    <id>http://blog.liushuping.com/2016/02/23/I-will-call-you-back/</id>
    <published>2016-02-23T15:05:38.000Z</published>
    <updated>2016-02-23T17:00:17.000Z</updated>
    <content type="html"><![CDATA[<p>春节前夕，一个偶然的机会我粗略地研究了一下ES6里异步代码的实现方式－－生成器（Generator），过程很是烧脑。决定首先重新审视一下JavaScript原有的异步代码实现方式－－回调（CallBack）。审视之初，大脑不由自主地发挥想象，滑稽却有趣。</p>
<h1 id="好莱坞原则">好莱坞原则</h1><p>Callback这个词几乎会出在现每日的工作中，平淡无奇，而此刻多年前的一个概念却突然浮现－－好莱坞原则：“Don’t call us, We will call you”。第一次了解到这个原则还是多年前学习设计模式时，那时好莱坞原则被用来说明观察者(Observer)等模式。当然，这个原则的本意是说“不要轮询来问我们，我们会通知你消息的”，这也很好地解释了观察者模式。</p>
<p><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Fhollywood.jpg" alt="image"></p>
<a id="more"></a>
<p>Callback让我回忆起了好莱坞原则，而好莱坞原则却貌似跟Callback没有直接关系。大脑接着想到了几年前参加的一个JavaScript会议中某演讲者讲的一个关于Callback的冷故事。我决定再一次地尝试对不同听众讲这个故事，并观察其反应。</p>
<p>除夕，看晚会，放烟花，没抢红包，当然更没咻。</p>
<h1 id="一个故事">一个故事</h1><p>春节后的一个下午，陪着闺女还有一个侄女玩耍。侄女提议讲故事玩，我和闺女都高兴地答应了。同时我也不怀好意地想到了那个关于Callback的故事，或者说是个笑话吧。</p>
<p>三个人依次按照顺序讲故事，侄女首先讲了一个《三只小猪》的故事，我们鼓掌表示鼓励。</p>
<p><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2F3_pigs.jpg" alt="image"></p>
<p>然后是我，讲了一个《白巧克力和黑巧克力》的故事，内容大致如下：</p>
<p>从前，有一块白巧克力和一块黑巧克力，他们在一起玩儿。白巧克力对黑巧克力说：“我们每人讲一个笑话给对方听吧，如果不能令对方发笑，就要被扔进大海里”。黑巧克力先讲了一个笑话，白巧克力没有笑，把黑巧克力扔进了大海。</p>
<p>侄女鼓掌表示故事好听，闺女像理解了我的套路似的（我之前没有跟闺女讲过该故事），仅仅象征性地拍了一下手掌。</p>
<p>接下来是闺女讲故事，她没有按套路出牌，而是给我们背了一首幼儿园学到的儿歌。当然，我和侄女也给了热烈的掌声。</p>
<p>故事进行到了第二轮，侄女又讲了一个《小红帽》的故事。</p>
<p><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Fxiaohongmao.png" alt="image"></p>
<p>然后又是我，讲了一个《两个小朋友钓鱼》的故事，内容大致如下：</p>
<p>从前，有两个好朋友，他们都很喜欢钓鱼。一天，他们像往常一样来到大海边开始钓鱼，不一会儿其中的一个小朋友就发现了鱼竿的晃动。于是他使劲往岸上拉，然而鱼竿似乎比往常重很多。终于在小伙伴的帮忙下，他把鱼钩拉上来了。猜：他们钓上什么来了？我对着侄女和闺女问。</p>
<p>侄女和闺女马上回答说是鱼。我提示我之前讲了一个《白巧克力和黑巧克力》的故事。话音未落，侄女马上回答说“钓上来的是黑巧克力”。我问为什么？她说，因为黑巧克力讲的笑话没使白巧克力笑，就被扔进大海里了，所以就被钓上来了。此刻，我可以验证，那次JavaScript会议上那位演讲者所讲的这个关于Callback的故事是成功的。</p>
<p>之后，小侄女又两次要求我重复讲述了《两个小朋友钓鱼》的故事，因为她说这个故事很好听！</p>
<h1 id="I_will_call_you_back!">I will call you back!</h1><p>在不少影视剧中，经常能看到这样的剧情：一个人在接电话，在简短的交谈后他会说一句“I’ll call you back”（或者国产剧的“我再打给你”），然后结束通话。这应该就是Callback的最初起源。</p>
<p>通话开始的简短交谈应该是Callback的“初始化”过程，它提供了足够的信息给Callback，以保证Callback能在正确的时刻以正确的方式发生。</p>
<p>一句“I’ll call you back”之后通话被结束，这是异步的本质。整个事情的处理过程尚未结束，当前过程挂起（hang up），后续过程等待由被呼叫者主动唤醒。唤醒过程被称之为Callback。</p>
<p>被呼叫者在完成相关任务后，呼叫主呼叫者，这是Callback的执行过程。被呼叫者呼叫主呼叫者的过程通常是以“我是谁谁谁”，“我们之前说的什么事”等等方式来提醒主呼叫者回忆起要处理的事情。这个过程叫Context restore。</p>
<p>如果你清楚了这个过程，就应该不难理解C# async里面的ConfigureAwait(boold)的作用了；也会更加清楚为什么有时代码会出现Context(如ASP.NET Context)丢失的问题了。</p>
<h1 id="Call_back">Call back</h1><p>好吧，思绪就飞这么远吧。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>春节前夕，一个偶然的机会我粗略地研究了一下ES6里异步代码的实现方式－－生成器（Generator），过程很是烧脑。决定首先重新审视一下JavaScript原有的异步代码实现方式－－回调（CallBack）。审视之初，大脑不由自主地发挥想象，滑稽却有趣。</p>
<h1 id="好莱坞原则">好莱坞原则</h1><p>Callback这个词几乎会出在现每日的工作中，平淡无奇，而此刻多年前的一个概念却突然浮现－－好莱坞原则：“Don’t call us, We will call you”。第一次了解到这个原则还是多年前学习设计模式时，那时好莱坞原则被用来说明观察者(Observer)等模式。当然，这个原则的本意是说“不要轮询来问我们，我们会通知你消息的”，这也很好地解释了观察者模式。</p>
<p><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Fhollywood.jpg" alt="image"></p>]]>
    
    </summary>
    
      <category term="Async" scheme="http://blog.liushuping.com/tags/Async/"/>
    
      <category term="JavaScript" scheme="http://blog.liushuping.com/tags/JavaScript/"/>
    
      <category term="Software" scheme="http://blog.liushuping.com/categories/Software/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[非windows平台上的.NET开发]]></title>
    <link href="http://blog.liushuping.com/2016/02/02/%E5%9C%A8%E9%9D%9EWindows%E5%B9%B3%E5%8F%B0%E4%B8%8A%E7%9A%84-NET%E5%BC%80%E5%8F%91/"/>
    <id>http://blog.liushuping.com/2016/02/02/在非Windows平台上的-NET开发/</id>
    <published>2016-02-02T14:25:39.000Z</published>
    <updated>2016-03-18T00:36:25.000Z</updated>
    <content type="html"><![CDATA[<p>长久以来，开发人员只能在Windows平台上进行.NET开发。在其它平台上，如Linux上只能依赖第三方的运行时，例如著名的<a href="http://www.mono-project.com/" target="_blank" rel="external">Mono</a>。但是从.NET  5开始，微软官方发布了真正跨平台的.NET运行环境<a href="https://github.com/dotnet/coreclr" target="_blank" rel="external">.NET Core</a>。.NET 的跨平台也步入了新的台阶。</p>
<a id="more"></a>
<p>本文介绍了如何在Mac上以C#进行.Net Core 5.0程序的开发。</p>
<h1 id="步骤概述">步骤概述</h1><p>不论是在Windows，Mac还是Linux平台上，.Net Core 5.0程序的开发都可以简要的总结为下列几个步骤：</p>
<ol>
<li>安装<a href="https://github.com/aspnet/dnvm/" target="_blank" rel="external">DNVM</a> - .NET版本管理器</li>
<li>通过DNVM安装指定版本的.NET CLR</li>
<li>创建.NET项目工程并编写代码</li>
<li>执行命令<code>dnu restore</code> － 安装程序运行依赖包(NuGet格式)</li>
<li>执行<code>dnx &lt;command&gt;</code> － 运行程序</li>
</ol>
<h1 id="安装DNVM">安装DNVM</h1><p><code>DNVM</code>是Dot Net Version Manager的缩写，它由几个脚本文件（Windows上PowerShell文件，Linux及Mac OS上是Shell文件）组成。按照<a href="https://docs.asp.net/en/latest/getting-started/installing-on-mac.html" target="_blank" rel="external">ASP官网</a>，通过下列命令来在Mac上下载并安装<code>DNVM</code>：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https://raw.githubusercontent.com/aspnet/Home/dev/dnvminstall.sh | DNX_BRANCH=dev sh &#38;&#38; source ~/.dnx/dnvm/dnvm.sh</span><br></pre></td></tr></table></figure></p>
<p>安装完成后，可以在Terminal下执行<code>DNVM</code>：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnvm</span><br></pre></td></tr></table></figure></p>
<p>如要列出机器上当前所安装的所有.NET 版本：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnvm list</span><br></pre></td></tr></table></figure></p>
<h1 id="安装CLR">安装CLR</h1><p>通过<code>DNVM</code>所管理的.NET 可以分为两类：.NET 4.5和.NET 5 Core。.NET 4.5在Mac上是基于Mono的，本文介绍的.NET 5 Core不依赖Mono，可以通过如下命令安装:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnvm upgrade -r coreclr</span><br></pre></td></tr></table></figure></p>
<p>安装完成后，可以通过<code>dnvm list</code>来查看所有已经安装的.NET 。例如我的电脑当前安装的版本信息显示如下：<br><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">Active</span> <span class="comment">Version</span>              <span class="comment">Runtime</span> <span class="comment">Architecture</span> <span class="comment">OperatingSystem</span> <span class="comment">Alias</span></span><br><span class="line"><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>              <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span></span><br><span class="line">       <span class="comment">1</span><span class="string">.</span><span class="comment">0</span><span class="string">.</span><span class="comment">0</span><span class="literal">-</span><span class="comment">rc1</span><span class="literal">-</span><span class="comment">final</span>      <span class="comment">coreclr</span> <span class="comment">x64</span>          <span class="comment">darwin</span>          </span><br><span class="line">  <span class="comment">*</span>    <span class="comment">1</span><span class="string">.</span><span class="comment">0</span><span class="string">.</span><span class="comment">0</span><span class="literal">-</span><span class="comment">rc1</span><span class="literal">-</span><span class="comment">update1</span>    <span class="comment">coreclr</span> <span class="comment">x64</span>          <span class="comment">darwin</span>          <span class="comment">default</span></span><br></pre></td></tr></table></figure></p>
<p>第一列中标星号的版本代表了当前默认版本，因此在该机器上的.NET 代码会被编译到该目标.NET 平台下。如果要切换目标.NET 平台，可以通过命令<code>dnvm use</code>来实现。具体使用方式，可以查看<code>DNVM</code>帮助。</p>
<h1 id="创建-NET项目">创建.NET项目</h1><p>前面的两步完成了对机器能编译运行.NET 程序的全部配置，因此可以进行.NET 的程序开发。然而从一个完全空白的文件或文件夹开始写源代码是非常不方便的。通常我们需要一个创建项目的模板，或者近几年更流行的名称是“脚手架”。针对.NET  5平台的脚手架的实现上，微软采取了充分利用开源社区资源的做法，既节省了成本又提高了广大开发者的认同度。</p>
<p>微软采取了通过<a href="https://www.npmjs.com/package/yo" target="_blank" rel="external">Yoeman</a>这个基于Node跨平台的脚手架工具来实现.NET  5项目工程文件创建的目的。具体地说，它开发了一个Yomean的插件<a href="https://www.npmjs.com/package/generator-aspnet" target="_blank" rel="external">generator-aspnet</a>来作为.NET 5的脚手架。</p>
<p>在Node的提示符下，输入如下命令可以进入.NET  5项目工程生成的引导步骤中：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">yo</span> aspnet</span><br></pre></td></tr></table></figure></p>
<p>值得一提的是，虽然命令行的参数叫<code>aspnet</code>，但是它却能创建大多数常见的.NET 工程类型，如<code>Console</code>, <code>UnitTest</code>等等。</p>
<h1 id="安装程序依赖包">安装程序依赖包</h1><p>.NET  5的所有依赖项都是通过NuGet来进行管理的，而这些依赖项都注册在工程主文件<code>project.json</code>中。通过脚手架生成的工程并没有把所依赖的包安装下载到工程所在目录。因此需要运行下面的命令来加载所有依赖项：<br><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnu <span class="built_in">restore</span></span><br></pre></td></tr></table></figure></p>
<h1 id="运行程序">运行程序</h1><p>运行程序所要执行的命令是<code>dnx</code>，其参数根据项目工程不同而不同，可以参考<code>project.json</code>文件中的<code>commands</code>属性。比如<code>Unit Test</code>的项目的<code>commands</code>属性是这样子的:<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"commands"</span>: &#123;</span><br><span class="line">    <span class="string">"test"</span>: <span class="string">"xunit.runner.dnx"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因此，运行该工程的命令是<code>dnx test</code>。如果执行<code>dnx</code>命令前并没有执行<code>dnu</code>命令，则<code>dnx</code>会先执行<code>dnu</code>。</p>
<h1 id="演示">演示</h1><p><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Faspnet-sample.gif" alt="demo"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>长久以来，开发人员只能在Windows平台上进行.NET开发。在其它平台上，如Linux上只能依赖第三方的运行时，例如著名的<a href="http://www.mono-project.com/">Mono</a>。但是从.NET  5开始，微软官方发布了真正跨平台的.NET运行环境<a href="https://github.com/dotnet/coreclr">.NET Core</a>。.NET 的跨平台也步入了新的台阶。</p>]]>
    
    </summary>
    
      <category term=".NET" scheme="http://blog.liushuping.com/tags/NET/"/>
    
      <category term="Cross-Platform" scheme="http://blog.liushuping.com/tags/Cross-Platform/"/>
    
      <category term=".NET" scheme="http://blog.liushuping.com/categories/NET/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[微软跨平台及开源的执行力之我见]]></title>
    <link href="http://blog.liushuping.com/2016/01/23/%E5%BE%AE%E8%BD%AF%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%8F%8A%E5%BC%80%E6%BA%90%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8A%9B%E4%B9%8B%E6%88%91%E8%A7%81/"/>
    <id>http://blog.liushuping.com/2016/01/23/微软跨平台及开源的执行力之我见/</id>
    <published>2016-01-23T13:18:04.000Z</published>
    <updated>2016-01-29T12:54:36.000Z</updated>
    <content type="html"><![CDATA[<p>首先说明，本文不是给微软写的软文，而是对微软近些年在跨平台以及开源社区等领域所做努力的一些个人所见。好多人说微软做的越来越不行了，好多产品越来越不好用或者不明白为啥那样做等等。然而，我却看到了不太一样的微软。</p>
<p>科技公司在经历长期的发展壮大后会变成老牌企业，而老牌的IT企业在面对新兴的互联网领域时经常会表现出转型、创新困难，抓不住机会的尴尬状况。除IBM是一个典型代表外，微软也已经归为IT老牌企业的行列了。然而，个人所见微软在面对互联网的浪潮时在跨平台及开源领域的执行力以及进展还是有卓越成果的。</p>
<a id="more"></a>
<h1 id="-NET">.NET</h1><p>.NET 是微软在开发领域的一个主力产品，是Java等其它基于虚拟机产品的有力竞争对手。长期以来.NET是闭源的，而它所声称的跨平台性在其它平台如Linux上也只能靠其它三方产品来实现，如<a href="http://www.mono-project.com/" target="_blank" rel="external">Mono</a>。近几年微软意识到了开源社区的力量，因此也对.NET 的Runtime(CLR)和Framework做了开源：</p>
<ul>
<li>CoreClr: <a href="https://github.com/dotnet/coreclr" target="_blank" rel="external">https://github.com/dotnet/coreclr</a></li>
<li>ColreFx: <a href="https://github.com/dotnet/corefx" target="_blank" rel="external">https://github.com/dotnet/corefx</a></li>
</ul>
<p>在.NET领域，除CLR和Framework之外编译器是另一个重要的角色。微软在多年前启动了<a href="http://www.eweek.com/c/a/Application-Development/Microsoft-Delivers-Roslyn-Compiler-as-a-Service-Preview-455946" target="_blank" rel="external">Compiler as a Service</a>的Roslyn项目。之后整个<a href="https://github.com/dotnet/roslyn" target="_blank" rel="external">Roslyn</a>的源代码也开源在Github上。<br><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2FRoslyn.jpg" alt="Roslyn">(图片来源：<a href="http://goo.gl/HCyxMB" target="_blank" rel="external">http://goo.gl/HCyxMB</a>)</p>
<p>虽然说.NET CLR+Framework+Compiler(Roslyn)几乎是.NET的全部，有了它们就可以做完全的.NET研究和开发，然而.NET的工程构建还是一套复杂的系统，微软是通过MSBuild来管理它的，并对<a href="https://github.com/Microsoft/msbuild/" target="_blank" rel="external">MSBuild进行了开源</a>。</p>
<p>做了这些工作后，可以说微软已经完全拥抱开源和跨平台了，通过<a href="http://dotnet.github.io/" target="_blank" rel="external">http://dotnet.github.io/</a> 你可以找到.NET Core的很多信息，从中可以看到.NET现在官方支持下列平台：</p>
<ul>
<li>Windows </li>
<li>Debian</li>
<li>Ubuntu</li>
<li>CentOS</li>
<li>OpenSuSE</li>
<li>Mac OS</li>
<li>Free BSD</li>
</ul>
<p>最后考虑到了在不同平台上配置不同的.NET Runtime，Framework以及编译等工作的复杂性，微软又推出了.NET的执行环境(Execution Environment)－－<a href="https://github.com/aspnet/dnx" target="_blank" rel="external">DNX</a>。通过它，开发人员可以快速简单地在任何支持的平台上配置好.NET开发及运行环境。当然，它也是开源的。</p>
<h1 id="Web">Web</h1><p>Web是互联网的关键字之一，在微软阵营Web就是IIS，ASP.NET和MVC了。把ASP.NET以及MVC开源出来是微软在Web上的第一步：</p>
<ul>
<li>ASP.NET: <a href="https://github.com/aspnet/home" target="_blank" rel="external">https://github.com/aspnet/home</a></li>
<li>MVC: <a href="https://github.com/aspnet/Mvc" target="_blank" rel="external">https://github.com/aspnet/Mvc</a></li>
</ul>
<p>ASP.NET是一个集合，除MVC之外还包含了EntityFramework和Identity等诸多库。然后在.NET开源及跨平台的基础上，ASP.NET和MVC在其它平台上的开发和运行就变成了可能。当然这里有个障碍需要清除：ASP.NET及MVC运行所依赖的IIS环境是不存在于其它平台（如Linux）的。因此微软大刀阔斧地对其Web生态(Ecosystem)做了重大的变革－－IIS已经不是必须的运行环境，取而代之的是微软重新实现了一个开源跨平台的Web服务器<a href="https://github.com/aspnet/KestrelHttpServer" target="_blank" rel="external">Kestrel</a>， 为ASP.NET的跨平台扫清了最后的障碍。值得一提的是，在实现Kestrel时，微软拥抱社区，采取了基于社区的成熟组件的架构－－Kestrel是基于<a href="https://github.com/libuv/libuv" target="_blank" rel="external">libuv</a>的，而libuv又是Node.js的HTTP请求处理引擎。</p>
<p><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Faspnet_vs2015.png" alt="ASP.NET and Visual Studio 2015">(图片来源：<a href="http://goo.gl/TFg1dF" target="_blank" rel="external">http://goo.gl/TFg1dF</a>)</p>
<h1 id="浏览器与JavaScript">浏览器与JavaScript</h1><p>IE浏览器由于历史包袱太沉重，一直受到前端开发者的诟病。微软也是壮士断腕决定<a href="http://tech.qq.com/a/20150802/004144.htm" target="_blank" rel="external">停止IE</a>这个产品。要想在互联网上走的远，一定要做出一些革命性的变革，微软推出的下一代浏览器<a href="http://www.microsoft.com/en-us/windows/microsoft-edge" target="_blank" rel="external">Edge</a>以全新的面貌出现。从终端用户角度来看，虽不完美但值的期待。但从开发者角度来看，这绝对是革命性的，因为Edge浏览器引擎代码<a href="https://github.com/Microsoft/ChakraCore" target="_blank" rel="external">Chakra开源了</a>。</p>
<p><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Fchakra-componentization.png" alt="Chakra Core">(图片来源：<a href="https://goo.gl/YsW8Eh" target="_blank" rel="external">https://goo.gl/YsW8Eh</a>)</p>
<p>开放Chakra源代码意味着在服务器端JavaScript引擎不再只有<a href="https://en.wikipedia.org/wiki/V8_(JavaScript_engine" target="_blank" rel="external">Google V8</a>一个选择，Node.js或许可以运行在Chakara上了。事实上，截止日期2016-01-23，已经有人实现了在Chakra上运行Node了，并给Node.js提了一个<a href="https://github.com/nodejs/node/pull/4765" target="_blank" rel="external">Pull Request</a>。</p>
<p>在语言层面上，微软的大神，Techinical Fellow, Anders Hejlsberg很早就对JavaScript做了全面的分析，并以开源的形式推出JavaScript的超集(super set) －－ <a href="https://github.com/Microsoft/TypeScript" target="_blank" rel="external">TypeScript</a>。 之后，微软的另一个大神Erich Gamma（Design Pattern作者GoF之一）领导了一个团队用TypeScript开发了非常好用的编辑器<a href="https://code.visualstudio.com/" target="_blank" rel="external">VSCode</a>。VSCode也并不是微软从0开始开发的一个新编辑器，而是基于<a href="https://github.com/atom/electron" target="_blank" rel="external">Electron</a>开发的。Github自家的编辑器<a href="https://github.com/atom/atom" target="_blank" rel="external">Atom</a>也是基于Electron的。</p>
<h1 id="标准">标准</h1><p>开发工具的跨平台和开源之外，微软还不遗余力地参与或主导了很多标准及协议的定制。例如.NET的开放Web接口<a href="http://owin.org/" target="_blank" rel="external">OWIN</a>。 </p>
<p><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2FOWIN-0.png" alt="OWIN">(图片来源：<a href="http://goo.gl/fE1xdp" target="_blank" rel="external">http://goo.gl/fE1xdp</a>)</p>
<p><a href="http://www.amqp.org/" target="_blank" rel="external">AMQP</a> 也是微软积极参与的一个协议。在微软的Azure云中，AMQP是一个重要的协议。类似的微软主导或参与的协议和标准还有很多。这样微软既提高了行业领导力，又增加了产品的跨平台性。</p>
<h1 id="社区">社区</h1><p>近些年来微软既积极地参与各类社区活动又从社区中学到不少做法。这儿列几个仅作为例子：</p>
<ul>
<li><a href="http://www.nuget.org/" target="_blank" rel="external">NuGet</a>。 其包的管理方式完全类似于Ruby，Node等社区的包管理方式。NuGet使.NET的开发模式变的类似其它社区的开发模式，这样大大降低了其它社区开发者参与.NET社区开发或.NET社区开发者参与其它社区开发的学习曲线。<br><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2FNuGet-Stickers.jpg" alt="image">(图片来源：<a href="http://goo.gl/j5HaRq" target="_blank" rel="external">http://goo.gl/j5HaRq</a>)</li>
<li>基于<code>.json</code>的项目管理文件。不同社区使用同样的项目管理文件，这又是一个降低开发人员进入到不同社区时的学习曲线的有效举措。</li>
<li>社区参与的文档开发。对Azure有了解的开发人员会意识到Azure的文档不再按照传统的方式以MSDN来管理了。取而代之的是微软完全把Azure的文档放在GitHub上，任何人都可以对文档，当然包含所有微软开源的代码，进行贡献。</li>
<li>积极参与社区的线上和线下技术活动。不管是微软官方举办的，还是各种第三方举办的活动，不论活动级别大小，总能见到微软。比如说，<a href="http://www.huodongxing.com/" target="_blank" rel="external">活动行</a> 中就有很多微软参与的活动。2015年的<a href="http://www.eepw.com.cn/event/action/IOT2015/schedule.html" target="_blank" rel="external">物联网开发者大会</a>上我也看到了微软的积极参与。其目的自然是宣传其Azure产品，但也足以说明微软对社区的重视和参与度。</li>
</ul>
<h1 id="其它">其它</h1><p>在跨平台上，微软还有其它很多很多的工具或是行动，比如<a href="https://blog.docker.com/2014/10/docker-microsoft-partner-distributed-applications/" target="_blank" rel="external">Windows和Docker的合作</a>。这样分布式系统就可以更容易地跨不同操作系统平台了。</p>
<p><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Fdocker-windows-servers.png" alt="Windows and Docker">(图片来源：<a href="http://goo.gl/sPGd7B" target="_blank" rel="external">http://goo.gl/sPGd7B</a>)</p>
<p>在C/C++的跨平台上，<a href="http://blogs.msdn.com/b/vcblog/archive/2015/12/04/introducing-clang-with-microsoft-codegen-in-vs-2015-update-1.aspx" target="_blank" rel="external">Visual Studio 2015开始支持CLang</a>，从而大大地提高了用Visual Studio编译的C/C++程序的可移植性。</p>
<p>在云平台上，相对于其它产品，Azure有更全面的跨平台开发支持。无论是Windows，Mac，Linux还是ARM，都能找到相关的SDK。我曾经在一个国产的ARM板上不做任何配置成功地安装并运行了Azure的Node版SDK。</p>
<p>在机器学习领域，微软开源了其深度学习的工具箱<a href="https://github.com/Microsoft/CNTK" target="_blank" rel="external">CNTK</a>。</p>
<h1 id="总结">总结</h1><p>个人认为微软在跨平台、开源及行业标准等领域是有很强执行力的，成果也是非常明显的。</p>
<hr>
<p>封面图片：<a href="http://goo.gl/FAUfuk" target="_blank" rel="external">http://goo.gl/FAUfuk</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>首先说明，本文不是给微软写的软文，而是对微软近些年在跨平台以及开源社区等领域所做努力的一些个人所见。好多人说微软做的越来越不行了，好多产品越来越不好用或者不明白为啥那样做等等。然而，我却看到了不太一样的微软。</p>
<p>科技公司在经历长期的发展壮大后会变成老牌企业，而老牌的IT企业在面对新兴的互联网领域时经常会表现出转型、创新困难，抓不住机会的尴尬状况。除IBM是一个典型代表外，微软也已经归为IT老牌企业的行列了。然而，个人所见微软在面对互联网的浪潮时在跨平台及开源领域的执行力以及进展还是有卓越成果的。</p>]]>
    
    </summary>
    
      <category term="Microsoft" scheme="http://blog.liushuping.com/tags/Microsoft/"/>
    
      <category term="OSS" scheme="http://blog.liushuping.com/tags/OSS/"/>
    
      <category term="Microsoft" scheme="http://blog.liushuping.com/categories/Microsoft/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据正规化]]></title>
    <link href="http://blog.liushuping.com/2016/01/04/%E6%95%B0%E6%8D%AE%E6%AD%A3%E8%A7%84%E5%8C%96/"/>
    <id>http://blog.liushuping.com/2016/01/04/数据正规化/</id>
    <published>2016-01-04T14:23:06.000Z</published>
    <updated>2016-01-04T16:00:13.000Z</updated>
    <content type="html"><![CDATA[<p>当对包含不同指标的数据样本进行分析时，数值较高的指标容易在分析中突显作用，而数值较低的指标的作用易被削弱。因此在对数据进行分析之前，需要对数据进行去量纲的正规化处理，使数据分布在相同的区间内。正规化的方法有很多，本文列出三种常用的方法。</p>
<a id="more"></a>
<h1 id="z-score_(zero-mean)_正规化">z-score (zero-mean) 正规化</h1><p>这是最常用的一种正规化方法，从名字中可以看出，经过z-score正规化的数据平均值是0。<br>z-score的公式是：</p>
<p><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Fzero-mean.png" alt="z-score image"></p>
<p>其中μ是样本的平均值（数学期望）</p>
<p><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Fzero-mean-mu.png" alt="z-score mu image"></p>
<p>而σ是样本的标准差(standard deviation)</p>
<p><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Fzero-mean-sigma.png" alt="z-score sigma image"></p>
<p>在数据是全部样本的情况下，标准差的计算中根号内的分母是n；但是在抽样数据的情况下，标准差计算中的根号内的分母是n-1。因为大多数分析数据是抽样数据，所以计算中取n-1。</p>
<p>z-score正规化适合指标的最大最小值未知或有数据超出范围的情况。</p>
<h1 id="min-max_正规化">min-max 正规化</h1><p>min-max正规化是把原始数据映射到[0-1]的无量纲区间内，该方法也叫离差标准化。公式：</p>
<p><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Fmin-max-norm.png" alt="min-max morm image"></p>
<h1 id="归一化">归一化</h1><p>归一化要求分析数据是非负数，该方法把数据映射到[0,1]的无量纲区间内，且所有正规化后的数据总和为1：</p>
<p><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Fnorm-to-1.png" alt="归一化公式"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>当对包含不同指标的数据样本进行分析时，数值较高的指标容易在分析中突显作用，而数值较低的指标的作用易被削弱。因此在对数据进行分析之前，需要对数据进行去量纲的正规化处理，使数据分布在相同的区间内。正规化的方法有很多，本文列出三种常用的方法。</p>]]>
    
    </summary>
    
      <category term="Data" scheme="http://blog.liushuping.com/tags/Data/"/>
    
      <category term="Machine Learning" scheme="http://blog.liushuping.com/tags/Machine-Learning/"/>
    
      <category term="Data" scheme="http://blog.liushuping.com/categories/Data/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[nanopi2系统配置]]></title>
    <link href="http://blog.liushuping.com/2016/01/02/nanopi2%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/"/>
    <id>http://blog.liushuping.com/2016/01/02/nanopi2系统配置/</id>
    <published>2016-01-02T03:58:04.000Z</published>
    <updated>2016-01-02T12:36:11.000Z</updated>
    <content type="html"><![CDATA[<p>本文介绍了在nanopi2上安装Debian系统的简要步骤以及安装后的必要配置。</p>
<h1 id="烧录Debian系统">烧录Debian系统</h1><p><a href="http://wiki.friendlyarm.com/wiki/index.php/NanoPi_2/zh" target="_blank" rel="external">Nanopi2 wiki</a>上有对如何安装系统的详细介绍，这里以在Windows系统上安装Debian系统到SD/TF卡为例（安装Android请参考<a href="http://wiki.friendlyarm.com/wiki/index.php/NanoPi_2/zh" target="_blank" rel="external">wiki</a>)</p>
<ul>
<li>首先到<a href="http://wiki.friendlyarm.com/wiki/nanopi2/download/" target="_blank" rel="external">http://wiki.friendlyarm.com/wiki/nanopi2/download/</a> 下载需要的固件例如<code>nanopi2-debian-sd4g.img.zip</code>以及烧写工具<code>win32diskimager.rar</code></li>
<li>下载完成后运行<code>win32diskimager.exe</code>，选取下载的<code>Debian</code>固件，并指定正确的SD/TF卡盘符，然后烧写即可。</li>
</ul>
<p>写入完成后，在Windows上看到的卡容量会是64M。不必担心，这是因为64M是Windows能识别Boot分区，而其它分区是Linux分区，Windows并不能识别。</p>
<p>把TF卡插入Nanopi2的卡位1（靠近电源输入的一端），接入电源即可启动Nanopi2了。</p>
<a id="more"></a>
<h1 id="扩展磁盘分区">扩展磁盘分区</h1><p>通过<code>diskimager</code>写的SD／TF卡是不能很好地直接使用的，此时的系统只占用了大约3GB的空间，并没有足够的空间来安装必要的软件，因此无法用来做开发。在使用之前需要扩展分区空间到整个SD/TF卡空间。</p>
<p>网上介绍的方法是把SD／TF卡接入到一个Linux系统的电脑，并执行以下命令：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo umount <span class="regexp">/dev/</span>sdx</span><br><span class="line">sudo parted <span class="regexp">/dev/</span>sdx unit % resizepart <span class="number">2</span> <span class="number">100</span> unit MB <span class="keyword">print</span></span><br><span class="line">sudo resize2fs -f <span class="regexp">/dev/</span>sdx2</span><br></pre></td></tr></table></figure></p>
<p>其中<code>sdx</code>的<code>x</code>要替换成实际的挂载点，通常是<code>sdb</code>。然而多次尝试后，系统提示各种错误。因此，我尝试了图形化的分区工具<code>gparted</code>，并正确地扩展了分区空间。<br>首先在一台Linux电脑上安装<code>gparted</code><br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> install gparted</span><br></pre></td></tr></table></figure></p>
<p>然后运行<code>gparted</code>图形化分区程序，选取接入的SD／TF卡，会看到有两个分区，选择第二个分区，然后选择卸载，检查。执行操作，分区扩展就完成了。</p>
<h1 id="配置无线连接">配置无线连接</h1><p>Nanopi2 wiki上有无线配置的详细步骤：<a href="http://wiki.friendlyarm.com/wiki/index.php/NanoPi_2/zh" target="_blank" rel="external">http://wiki.friendlyarm.com/wiki/index.php/NanoPi_2/zh</a> 这儿做简要重复：</p>
<ol>
<li>查看WiFi的网络接口：<code>ifconfig -a</code>，以<code>wlan</code>开头的就是<code>wifi</code>，通常是<code>wlan0</code></li>
<li>创建一个以WiFi接口命名的文件<code>vi /etc/network/interfaces.d/wlan0</code>,这儿用的是<code>vi</code>编辑器</li>
<li><p>在<code>wlan0</code>文件中输入以下内容：</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">auto wlan0</span><br><span class="line">iface wlan0 <span class="keyword">inet</span> dhcp</span><br><span class="line">wpa-driver nl80211</span><br><span class="line">wpa-ssid <span class="variable">&lt;YourWiFiESSID&gt;</span></span><br><span class="line">wpa-ap-scan <span class="number">1</span></span><br><span class="line">wpa-psk <span class="variable">&lt;YourWiFiPassword&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>完成编辑后，reboot后即可自动连接无线。</p>
</li>
</ol>
<h1 id="修改root密码">修改root密码</h1><p>默认情况下，<code>root</code>密码是<code>fa</code>，配置好WiFi连接后，系统便接入了互联网，因此为了安全，建议修改<code>root</code>密码：<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sudo</span> passwd</span><br></pre></td></tr></table></figure></p>
<h1 id="SSH连接">SSH连接</h1><p>配置好无线连接后，可以通过SSH连接的方式连接到nanopi2。需要知道无线分配给nanopi2的IP地址，有两种方式：</p>
<ul>
<li>通过HDMI把nanopi2连接到显示器或电视，然后执行命令<code>ifconfig -a</code>来查看</li>
<li>或者在一台属于同一个无线网络的电脑执行命令<code>arp -a</code>来查看所有IP地址。</li>
</ul>
<p>获取IP地址后通过<code>ssh root@&lt;ip address&gt;</code>即可连接。</p>
<h1 id="修改时区及同步时间">修改时区及同步时间</h1><h2 id="修改时区">修改时区</h2><p>初次装的系统并没有设置时区，因此时间是UTC的方式显示。可以通过下面的命令来修改时区：<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sudo</span> dpkg-reconfigure tzdata</span><br></pre></td></tr></table></figure></p>
<p>命令执行后，系统会以图形化的方式引导修改时区。</p>
<h2 id="网络同步时间">网络同步时间</h2><p>由于nanopi2本身并不自带时钟电池，断电后时间设置就会丢失。因此通过NTP服务器动态获取时间的方式可以很好地确保时间的正确性。国内常用的NTP服务器有：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ntp<span class="class">.sjtu</span><span class="class">.edu</span><span class="class">.cn</span> <span class="number">202.120</span>.<span class="number">2.101</span> (上海交通大学网络中心NTP服务器地址）</span><br><span class="line">s1a<span class="class">.time</span><span class="class">.edu</span><span class="class">.cn</span>	北京邮电大学</span><br><span class="line">s1b<span class="class">.time</span><span class="class">.edu</span><span class="class">.cn</span>	清华大学</span><br><span class="line">s1c<span class="class">.time</span><span class="class">.edu</span><span class="class">.cn</span>	北京大学</span><br><span class="line">s1d<span class="class">.time</span><span class="class">.edu</span><span class="class">.cn</span>	东南大学</span><br><span class="line">s1e<span class="class">.time</span><span class="class">.edu</span><span class="class">.cn</span>	清华大学</span><br><span class="line">s2a<span class="class">.time</span><span class="class">.edu</span><span class="class">.cn</span>	清华大学</span><br><span class="line">s2b<span class="class">.time</span><span class="class">.edu</span><span class="class">.cn</span>	清华大学</span><br><span class="line">s2c<span class="class">.time</span><span class="class">.edu</span><span class="class">.cn</span>	北京邮电大学</span><br><span class="line">s2d<span class="class">.time</span><span class="class">.edu</span><span class="class">.cn</span>	西南地区网络中心</span><br><span class="line">s2e<span class="class">.time</span><span class="class">.edu</span><span class="class">.cn</span>	西北地区网络中心</span><br><span class="line">s2f<span class="class">.time</span><span class="class">.edu</span><span class="class">.cn</span>	东北地区网络中心</span><br><span class="line">s2g<span class="class">.time</span><span class="class">.edu</span><span class="class">.cn</span>	华东南地区网络中心</span><br><span class="line">s2h<span class="class">.time</span><span class="class">.edu</span><span class="class">.cn</span>	四川大学网络管理中心</span><br><span class="line">s2j<span class="class">.time</span><span class="class">.edu</span><span class="class">.cn</span>	大连理工大学网络中心</span><br><span class="line">s2k<span class="class">.time</span><span class="class">.edu</span><span class="class">.cn</span> CERNET桂林主节点</span><br><span class="line">s2m<span class="class">.time</span><span class="class">.edu</span><span class="class">.cn</span> 北京大学</span><br></pre></td></tr></table></figure></p>
<p>要通过NTP服务器同步时间，需要用到<code>ntpdate包</code>，通过下面命令安装:<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sudo</span> apt-get <span class="keyword">update</span> ntpdate</span><br></pre></td></tr></table></figure></p>
<p>安装后，通过<code>ntpdate</code>命令指定一个NTP服务器就可以同步时间了:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntpdate ntp<span class="class">.sjtu</span><span class="class">.edu</span><span class="class">.cn</span></span><br></pre></td></tr></table></figure></p>
<p>如果需要定期同步时间，可以通过<code>crontab -e</code>命令并在打开的文件中添加类似下面的一行：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">*</span>/30 <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> /usr/sbin/ntpdate time.cuit.edu.cn</span><br></pre></td></tr></table></figure></p>
<p>表示系统每30分钟同步一次时间。</p>
<h1 id="修改hostname">修改hostname</h1><p>nanopi2设备默认的名字是<code>nanopi2</code>，例如用ssh以root身份登录系统后的显示如下：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root<span class="variable">@nanopi2</span><span class="symbol">:~</span><span class="comment">#</span></span><br></pre></td></tr></table></figure></p>
<p>可以通过修改<code>/etc/hostname</code>文件内容来修改设备名字。<br>此外，在<code>apt-get install</code>命令安装包时，系统会提示类似<code>cannot resolve hostname nanopi2</code>之类的消息，可以通过修改<code>/etc/host</code>文件，在其中加入一条<code>nanopi2</code>(或是修改后的hostname)记录来解决，例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">27.0</span><span class="number">.0</span><span class="number">.1</span>       localhost</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>      nanopi2</span><br><span class="line">::<span class="number">1</span>            localhost ip6-localhost ip6-loopback</span><br><span class="line">ff02::<span class="number">1</span>        ip6-allnodes</span><br><span class="line">ff02::<span class="number">2</span>        ip6-allrouters</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文介绍了在nanopi2上安装Debian系统的简要步骤以及安装后的必要配置。</p>
<h1 id="烧录Debian系统">烧录Debian系统</h1><p><a href="http://wiki.friendlyarm.com/wiki/index.php/NanoPi_2/zh">Nanopi2 wiki</a>上有对如何安装系统的详细介绍，这里以在Windows系统上安装Debian系统到SD/TF卡为例（安装Android请参考<a href="http://wiki.friendlyarm.com/wiki/index.php/NanoPi_2/zh">wiki</a>)</p>
<ul>
<li>首先到<a href="http://wiki.friendlyarm.com/wiki/nanopi2/download/">http://wiki.friendlyarm.com/wiki/nanopi2/download/</a> 下载需要的固件例如<code>nanopi2-debian-sd4g.img.zip</code>以及烧写工具<code>win32diskimager.rar</code></li>
<li>下载完成后运行<code>win32diskimager.exe</code>，选取下载的<code>Debian</code>固件，并指定正确的SD/TF卡盘符，然后烧写即可。</li>
</ul>
<p>写入完成后，在Windows上看到的卡容量会是64M。不必担心，这是因为64M是Windows能识别Boot分区，而其它分区是Linux分区，Windows并不能识别。</p>
<p>把TF卡插入Nanopi2的卡位1（靠近电源输入的一端），接入电源即可启动Nanopi2了。</p>]]>
    
    </summary>
    
      <category term="nanopi2" scheme="http://blog.liushuping.com/tags/nanopi2/"/>
    
      <category term="nanopi2" scheme="http://blog.liushuping.com/categories/nanopi2/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++算法笔记－常用头文件]]></title>
    <link href="http://blog.liushuping.com/2015/11/09/C-%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%EF%BC%8D%E5%B8%B8%E7%94%A8%E5%A4%B4%E6%96%87%E4%BB%B6/"/>
    <id>http://blog.liushuping.com/2015/11/09/C-算法笔记－常用头文件/</id>
    <published>2015-11-09T13:53:43.000Z</published>
    <updated>2015-11-14T15:16:58.000Z</updated>
    <content type="html"><![CDATA[<p>C＋+有非常非常多的库文件，很多常见的功能都可在其中找到了解常用的库文件可以让我们清楚地知道有哪些系统已有功能可以使用，有哪些功能是我们需要实现的。本文列出了算法程序常用库的头文件。</p>
<a id="more"></a>
<h1 id="输入输出">输入输出</h1><table>
<thead>
<tr>
<th>头文件</th>
<th>主要功能</th>
<th>主要的类及函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>iostream</td>
<td>标准流输入输出对象</td>
<td>cin, cout, cerr, clog</td>
</tr>
<tr>
<td>cstdio或stdio.h</td>
<td>C语言的输入输出函数库</td>
<td>printf, scanf, fprintf, fscanf, fopen以及fclose等</td>
</tr>
<tr>
<td>iomanip</td>
<td>包含了一系列输入输出格式化的功能</td>
<td>setiosflags, setbase, setfill, setw, get_money, put_money, get_time, put_time等</td>
</tr>
<tr>
<td>ios</td>
<td>包含了输入输出的基类及相关函数</td>
<td>ios, ios_base, dec, hex, oct, fixed, left, right, uppercase等</td>
</tr>
<tr>
<td>istream</td>
<td>包含了标准输入和结合了输入输出相关的功能</td>
<td>istream, iostream</td>
</tr>
<tr>
<td>ostream</td>
<td>包含了标准输出和结合了输入输出相关的功能</td>
<td>ostream, endl, ends, flush等。</td>
</tr>
<tr>
<td>sstream</td>
<td>包含了以流操作符方式操作字符串的相关功能</td>
<td>istringstream, ostringstream, stringstream, stringbuf等。</td>
</tr>
</tbody>
</table>
<h1 id="数值">数值</h1><table>
<thead>
<tr>
<th>头文件</th>
<th>主要功能</th>
<th>主要的类及函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>limits</td>
<td>包含了所有数值的边界值</td>
<td>numeric_limits</td>
</tr>
<tr>
<td>climits或limits.h</td>
<td>一系列极值相关的宏</td>
<td>INT_MIN, INT_MAX, LONG_MIN, LONG_MAX等。</td>
</tr>
<tr>
<td>numeric</td>
<td>包含了对数列元素的一些函数</td>
<td>accumulate, adjacent_difference, inner_product, partial_sum和iota</td>
</tr>
<tr>
<td>random</td>
<td>包含了随机数产生的相关功能</td>
<td>random_device等非常多的随机数相关功能</td>
</tr>
</tbody>
</table>
<h1 id="数学计算">数学计算</h1><table>
<thead>
<tr>
<th>头文件</th>
<th>主要功能</th>
<th>主要的类及函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>cmath或math.h</td>
<td>C语言的数学函数和宏的库，有三角函数，指数函数，比较的宏等。</td>
<td>sin, cos, exp, pow, sqrt, ceil, floor, nextafter等非常多的数学函数</td>
</tr>
<tr>
<td>complex</td>
<td>复数运算相关的功能</td>
<td>real, imag以及各数学函数的复数版重载</td>
</tr>
<tr>
<td>ratio</td>
<td>分数计算相关功能</td>
<td>ratio, ratio_add, ratio_substract, ratio_multiply, ratio_divide, ratio_equal, ratio_less等</td>
</tr>
</tbody>
</table>
<h1 id="字符串操作">字符串操作</h1><table>
<thead>
<tr>
<th>头文件</th>
<th>主要功能</th>
<th>主要的类及函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>string</td>
<td>字符串转换的相关功能</td>
<td>string, to_string等</td>
</tr>
<tr>
<td>regex</td>
<td>正则表达式</td>
<td>regex_match, regex_search, regex_replace, basic_regex, match_results, sub_match及reg等</td>
</tr>
</tbody>
</table>
<h1 id="内存操作">内存操作</h1><table>
<thead>
<tr>
<th>头文件</th>
<th>主要功能</th>
<th>主要的类及函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>memory</td>
<td>动态内存管理的相关功能</td>
<td>auto_ptr, shared_ptr, weak_ptr, make_shared等</td>
</tr>
<tr>
<td>new</td>
<td>重载了new、delete等动态内存操作符</td>
<td>operator new, operator new[], operator delete, operator delete[], set_new_handler, get_new_handler等</td>
</tr>
<tr>
<td>cstring或string.h</td>
<td>操作C类型的字符串或数组的功能</td>
<td>memcpy, memmove, strcpy, strncpy, memcmp, memset, strlen, size_t, strstr等</td>
</tr>
</tbody>
</table>
<h1 id="数据结构">数据结构</h1><table>
<thead>
<tr>
<th>头文件</th>
<th>主要功能</th>
<th>主要的类</th>
</tr>
</thead>
<tbody>
<tr>
<td>vector</td>
<td>C++中使用频率最高、可以动态改变大小的类似数组的数据结构</td>
<td>vector    </td>
</tr>
<tr>
<td>set</td>
<td>集合相关的数据结构</td>
<td>set和multiset</td>
</tr>
<tr>
<td>unordered_map</td>
<td>跟无序映射相关的功能</td>
<td>unordered_map和unordered_multimap</td>
</tr>
<tr>
<td>map</td>
<td>跟有序映射相关的功能</td>
<td>map和multimap</td>
</tr>
<tr>
<td>queue</td>
<td>FIFO队列和优先队列</td>
<td>queue和priority_queue</td>
</tr>
<tr>
<td>stack</td>
<td>栈</td>
<td>stack</td>
</tr>
<tr>
<td>array</td>
<td>固定长度数组类array，因此它的灵活性比vector差一些</td>
<td>array</td>
</tr>
<tr>
<td>list</td>
<td>具有常数时间复杂度的任意未知元素的插入删除操作，以及支持正反方向遍历操作的list</td>
<td>list</td>
</tr>
<tr>
<td>forward_list</td>
<td>前向链表</td>
<td>forward_list, begin, end</td>
</tr>
<tr>
<td>deque</td>
<td>可以从头尾分别访问的队列</td>
<td>deque</td>
</tr>
<tr>
<td>tuple</td>
<td>元组的相关功能</td>
<td>tuple, tuple_size, make_tuple, tuple_cat, get等</td>
</tr>
</tbody>
</table>
<h1 id="算法">算法</h1><table>
<thead>
<tr>
<th>头文件</th>
<th>主要功能</th>
<th>主要的类及函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>algorithm</td>
<td>来自于STL的算法库，有排序、二分搜索、归并、最值、分区、查找以及数列的操作等</td>
<td>all_of, any_of, none_of, for_each, count, count_if, search, search_n, find, find_if, copy, swap, reverse, sort, lower_bound, make_heap等非常多的算法相关功能</td>
</tr>
<tr>
<td>iterator</td>
<td>迭代器相关的功能</td>
<td>begin, end, prev, next, advance, distance, iterator, istream_iterator, ostream_iterator等</td>
</tr>
</tbody>
</table>
<h1 id="时间">时间</h1><table>
<thead>
<tr>
<th>头文件</th>
<th>主要功能</th>
<th>主要的类及函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>chrono</td>
<td>处理时刻、时间以及系统无力时间等</td>
<td>duration, time_point, system_clock, steady_clock, high_resolution_clock, duration_cast, time_point_cast, duration_values等</td>
</tr>
<tr>
<td>ctime或time.h</td>
<td>C语言的时间相关功能</td>
<td>clock, difftime, time, ctime, clock_t, size_t, time_t等</td>
</tr>
</tbody>
</table>
<h1 id="位操作">位操作</h1><table>
<thead>
<tr>
<th>头文件</th>
<th>主要功能</th>
<th>主要的类及函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>bitset</td>
<td>比特位的集合，适合进行位数超出最大整数的位操作</td>
<td>bitset</td>
</tr>
</tbody>
</table>
<h1 id="函数对象">函数对象</h1><table>
<thead>
<tr>
<th>头文件</th>
<th>主要功能</th>
<th>主要的类及函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>functional</td>
<td>函数对象，主要包含数字计算、比较、逻辑运算等函数对象，以及一些转换函数</td>
<td>plus, minus, multiplies, equal_to, greater, logical_and, not1, not2等非常多的函数对象</td>
</tr>
</tbody>
</table>
<h1 id="Utility">Utility</h1><table>
<thead>
<tr>
<th>头文件</th>
<th>主要功能</th>
<th>主要的类及函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>utility</td>
<td>多种工具集合</td>
<td>swap, make_pair, forward, move, pair等</td>
</tr>
</tbody>
</table>
]]></content>
    <summary type="html">
    <![CDATA[<p>C＋+有非常非常多的库文件，很多常见的功能都可在其中找到了解常用的库文件可以让我们清楚地知道有哪些系统已有功能可以使用，有哪些功能是我们需要实现的。本文列出了算法程序常用库的头文件。</p>]]>
    
    </summary>
    
      <category term="C++" scheme="http://blog.liushuping.com/tags/C/"/>
    
      <category term="算法" scheme="http://blog.liushuping.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="C++算法笔记" scheme="http://blog.liushuping.com/categories/C-%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[算法的思维之沿着右手边的墙往前走就一定能走出迷宫]]></title>
    <link href="http://blog.liushuping.com/2015/11/01/%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%9D%E7%BB%B4%E4%B9%8B%E6%B2%BF%E7%9D%80%E5%8F%B3%E6%89%8B%E8%BE%B9%E7%9A%84%E5%A2%99%E5%BE%80%E5%89%8D%E8%B5%B0%E5%B0%B1%E4%B8%80%E5%AE%9A%E8%83%BD%E8%B5%B0%E5%87%BA%E8%BF%B7%E5%AE%AB/"/>
    <id>http://blog.liushuping.com/2015/11/01/算法的思维之沿着右手边的墙往前走就一定能走出迷宫/</id>
    <published>2015-11-01T10:25:27.000Z</published>
    <updated>2015-11-09T13:47:06.000Z</updated>
    <content type="html"><![CDATA[<p>迷宫是一种老少咸宜的游戏，可以是画在纸上的迷宫游戏，也可以是以隔墙或树木修建在公园或游乐场的迷宫游戏。</p>
<h1 id="迷宫游戏的基本思路">迷宫游戏的基本思路</h1><p>解决迷宫游戏的思路很简单：任意挑一条面前没有走过的路，一旦发现当前所走的路是死胡同则记住当前路不可行并退回到上一个路口选择下一条未走过的路，以此类推直到走到出口位置。这里有个很大的难点：当迷宫足够大的时候，人很难记住哪些路是走过的，于是很有可能就在绕圈子。当用计算机来解决迷宫问题时，通常就简单很多了，因为计算机能“记忆”非常大的路径。计算机解决迷宫问题，可以归结为两种方案：深度优先搜索和广度优先搜索。</p>
<a id="more"></a>
<h1 id="深度优先">深度优先</h1><h2 id="算法">算法</h2><p>深度优先方案的思路是：每到一个分岔路口时，按照特定的顺序（例如顺时针）选取一个路口走下去，接下来的分岔路口继续按照这个思路走。一旦发现某一条路是死胡同则回到之前的岔路口，按照之前的顺序选取下一个路口走下去。如果发现当前的岔路口的所有选择都走不通，则退回到再之前的一个岔路口继续选择下去。</p>
<h2 id="数据结构">数据结构</h2><p>为了实现上面的算法，需要一定的数据结构来存储发现的路径，从而保证：</p>
<ol>
<li>路径的顺序是按照计划的方式存储的</li>
<li>要及时从数据结构中删除已经走过的路径，以确保不走重复的路</li>
<li>确保路径是沿着先深度后广度的的方案进行的</li>
</ol>
<p>基于这样的特征，很容易把栈对应到这个数据结构上来：</p>
<ol>
<li>把岔路口的所有选择逆序压到栈顶</li>
<li>然后选取栈顶的路径作为下一条路径</li>
<li>如果选择的路径走不通，则弹出栈顶的路径作为下一个选择</li>
<li>如果选择的路径继续有岔路口，则重复这几个步骤直到发现出口为止。</li>
</ol>
<p>因此这个方案所需要的栈存储空间跟入口到出口间的岔路口的多少成正比关系。</p>
<h1 id="广度优先">广度优先</h1><h2 id="算法-1">算法</h2><p>广度优先方案的思路是：每到一个分岔路口时，按照特定的顺序遍访所有的路口来确认其是否就是出口。如果没有找到出口，则以同样的思路遍访当前岔路口每一个路口所通向的下一个岔路口。如此进行下去，直到发现出口。</p>
<h2 id="数据结构-1">数据结构</h2><p>要实现上面的算法，需要一种数据结构来存储发现的岔路口，以保证：</p>
<ol>
<li>路径的顺序是按照计划的方式存取的</li>
<li>要及时从数据结构中删除已经访问过的岔路口，以确保不走重复的路</li>
<li>确保路径是沿着广度优先——层层向外扩展的方向进行的</li>
</ol>
<p>基于上面的特征，很容易把队列对应到这个数据结构上来：</p>
<ol>
<li>把当前碰到的所有岔路口追加到队列的尾部</li>
<li>取队列头部的岔路口，并检查其通向的所有路口是否为出口</li>
<li>如若不是，且该路口能通向下一个岔路口则把这个岔路口追加到队尾</li>
<li>如此循环进行，直到发现出口为止。</li>
</ol>
<p>因此这个方案所需的队列存储空间也跟入口到出口之间的岔路口的多少成正比关系。</p>
<h1 id="必须存储走过的路吗？">必须存储走过的路吗？</h1><p>为了避免让程序陷入死循环或是不必要的重复，需要记住走过的路，以便不再去走。是否需要这样做取决于所采取的方案在没有其它干预下是否存在可重复的可能。事实上，只要迷宫有岔路口，前面介绍的广度优先和深度优先的方案都确定存在这样的重复。</p>
<p>那么是否存在某种特殊的沿路径行走的方式，它能保证所走过的路一定是未走过的，不会重复走已经走过的呢？要回答这个问题，我们必须重新审视看待走迷宫的方式。</p>
<h1 id="如何看待迷宫某条路径的行走方式？">如何看待迷宫某条路径的行走方式？</h1><p>对同一个问题，不同的思考方式可能产生完全不同的解决方案，不同方案之间在复杂度以及效率上可能存在着巨大的差异。因此思维方式是人对算法理解的核心。</p>
<p>按照惯性思维，面对迷宫内的一条通道，最容易想到的是只有两种走法：进去和出来。然而基于这样的思维，解决方案也只能是前面介绍的广度或是深度优先的搜索，且都需要存储空间来标记已经走过的路。然而，简单的把迷宫通道的走法划分为进去和出来的方式使路径丢失了很多方向性信息，而丢失的信息正好可以用来“标记”走过的道路。事实上，迷宫的任意一条通道都是由左右两侧的两面墙组成而成的，沿着这两面墙分别有进去和出来的走法，这样一条通道就有4种走法了。</p>
<h1 id="无需额外记忆的迷宫走法">无需额外记忆的迷宫走法</h1><p>对迷宫通道走法的思维转变后，问题就容易分析了。先从直线分析，要保证不走重复的路很简单，只要沿着一个方向向前走即可。迷宫的路径是曲线，是否也可以用同样的方案？答案是肯定的：沿着曲线朝一个方向行走，若是发生回到原点的情况，只有下面两种可能：</p>
<ol>
<li>曲线是闭合的，在闭合区域内部，沿着曲线行走。</li>
<li>曲线是闭合的，在闭合区域的外沿，沿着曲线行走。</li>
</ol>
<p>然而，在入口到出口之间确定有通道的情况下（也即迷宫有解）的情况下，采取沿着迷宫墙壁朝一个方向行走的方式，是永远不会进入上面两种区域的。因为：</p>
<ol>
<li>不可能从一个闭合区域的外部进入其内部，因为没有”门”。而如果一开始就在内部，说明迷宫无解。</li>
<li>第二种是一个孤岛的情况，而从入口开始沿着墙朝一个方向行走，是不可能进入孤岛的。因为孤岛不可能接触人所在的墙，否则它就不是孤岛了。</li>
</ol>
<p>因此，我们把所有重复行走路线的可能都排除了，方案的正确性得到了证明。当然，沿着一个方向行走，既可是右侧，也可是左侧。</p>
<p>无需额外记忆的前提是迷宫确定有能通向出口的通道，否则会进入到上面介绍的两种重复行走路线的情况。</p>
<h1 id="总结">总结</h1><p>本文继续介绍了思维方式在算法中的重要性。通过分析解决迷宫问题的两种思路，阐述了思维方式的多样性以及不同的思维方式会对算法产生不同的效果。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>迷宫是一种老少咸宜的游戏，可以是画在纸上的迷宫游戏，也可以是以隔墙或树木修建在公园或游乐场的迷宫游戏。</p>
<h1 id="迷宫游戏的基本思路">迷宫游戏的基本思路</h1><p>解决迷宫游戏的思路很简单：任意挑一条面前没有走过的路，一旦发现当前所走的路是死胡同则记住当前路不可行并退回到上一个路口选择下一条未走过的路，以此类推直到走到出口位置。这里有个很大的难点：当迷宫足够大的时候，人很难记住哪些路是走过的，于是很有可能就在绕圈子。当用计算机来解决迷宫问题时，通常就简单很多了，因为计算机能“记忆”非常大的路径。计算机解决迷宫问题，可以归结为两种方案：深度优先搜索和广度优先搜索。</p>]]>
    
    </summary>
    
      <category term="几何" scheme="http://blog.liushuping.com/tags/%E5%87%A0%E4%BD%95/"/>
    
      <category term="算法" scheme="http://blog.liushuping.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="逻辑" scheme="http://blog.liushuping.com/tags/%E9%80%BB%E8%BE%91/"/>
    
      <category term="C++算法笔记" scheme="http://blog.liushuping.com/categories/C-%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[算法的思维之鸡兔同笼问题的分析]]></title>
    <link href="http://blog.liushuping.com/2015/11/01/%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%9D%E7%BB%B4%E4%B9%8B%E9%B8%A1%E5%85%94%E5%90%8C%E7%AC%BC%E9%97%AE%E9%A2%98%E7%9A%84%E5%88%86%E6%9E%90/"/>
    <id>http://blog.liushuping.com/2015/11/01/算法的思维之鸡兔同笼问题的分析/</id>
    <published>2015-11-01T10:24:25.000Z</published>
    <updated>2015-11-09T13:41:21.000Z</updated>
    <content type="html"><![CDATA[<p>约1500年前，《孙子算经》中有如下的问题描述：</p>
<blockquote>
<p>今有雉兔同笼，上有三十五头，下有九十四足，问雉兔各几何？</p>
</blockquote>
<p>首先科普一下，《孙子算经》的作者不详，且同《孙子兵法》不是一个作者。</p>
<p>进入正题：在数学发展到今天的水平来看，这是个很简单的问题，是一个初中问题或是小学奥数问题。然而用一些简单的问题去说明一些道理还是更容易让人接受的，毕竟如果直接拿哥德巴赫猜想（我也不会）这种世界性难题来说明道理是很难让人理解的，因为门槛太高。当然，这里要介绍的内容跟任何计算机程序语言都没有关系，只是统一分类到我的C++算法笔记作为一个子类别而已。</p>
<a id="more"></a>
<h1 id="思考的目的">思考的目的</h1><p>这里，我想通过这个简单的例子来尝试介绍一下算法的思维。个人认为，狭义上的算法思维就是按照能用计算机实现的方式来去思考问题的解决办法，当然这还需考虑解决办法的复杂度。这是一个很抽象的问题，我想还是通过这样一个简单的例子来给亲爱的读者一个直观的感觉吧。</p>
<h1 id="思考的方式">思考的方式</h1><p>这要从我还上小学的时候说起，那时就有长者考我这个问题，而当时的我觉得除了暴力穷举（知道这个方法的名字已经是好多年后的事了）外实在没有什么思路。等上了初中，学习了代数后才认识到它是人类发明的多么强大的数学工具，好多之前完全没有思路的问题顷刻间变的异常简单！</p>
<p>可是为什么会这样？这个问题我思考了很久，可以简单的总结为以下几点个人观点：</p>
<ol>
<li>有很多的问题我们很难分析出正面解决问题的思路办法</li>
<li>而在大量的问题分析过程中人们已经分析总结出了大量的恒等变化，例如交换律、结合律等等</li>
<li>代数的发明为人类提供了强有力的工具，让人们把正向难以分析的问题转化为反向的问题，从而使问题变得异常简单</li>
</ol>
<h1 id="思考的意义">思考的意义</h1><p>然而，很多情况下似乎正面分析得出的思路更容易通过计算机算法程序去实现。事实上，通过代数结合等式的恒等变化而解决问题的方式，如果不加深入的思考，很容易陷入知道如何解决问题，却不明白解决方式背后所隐含的真实思路的境况。</p>
<h1 id="以更加算法的方式去思考">以更加算法的方式去思考</h1><p>鸡兔同笼问题如果从正面思考，应该是简单的数论问题，是关于整数的加减乘除及取余的相关操作，而这些都跟计算机程序的算法息息相关。既然当鸡和兔子都已经站在笼子里时去正面分析比较困难，需要代数的帮忙，那么我们把顺序反过来，先让它们都站在笼子外面，然后从正面去分析让它们在逐步满足条件的前提下如何分步骤进入笼子。</p>
<p>在问题有解的前提下，腿的总数量应该介于全部是鸡时的腿的数量和全部是兔时腿的数量之间。那么在这个思路下，问题可以划分为多个子问题，而大问题划分为子问题的方法是计算机算法的一个重要工具：</p>
<ol>
<li>让全部的鸡进入笼子，然后计算一下全部腿的数量，如若等于问题给定的腿的数量，那么笼子内全是鸡；否则，进入第二个子问题</li>
<li>把多余的腿分配到笼子内的鸡身上。怎么分配？不能每只鸡分配一条腿，因为三条腿既不是鸡也不是兔子。所以要每只鸡分配两条腿，这样就神奇地让这只鸡变成兔子了。</li>
<li>问题得到了解决：变成兔子了的就是兔子，而没变的仍是鸡。</li>
</ol>
<h1 id="从反向思维推正向思维">从反向思维推正向思维</h1><p>代数、等式以及等价变换等都是数学对问题高度的抽象，可以脱离于物理量而存在。然而对于具体的问题，还是能通过对其问题的计算过程赋以具体物理意义而推导正向思维的。鸡兔问题，可以通过一元一次或二元一次方程来解决。而二元一次方程可以转化为一元一次方程，所以我们就以一元一次方程来分析（因为给二元赋以物理量比给一元赋以物理量难得多）：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span>x + (<span class="number">35</span> - x) * <span class="number">2</span> = <span class="number">94</span></span><br></pre></td></tr></table></figure></p>
<p>这代表了<code>x</code>只兔子和<code>35 - x</code>只鸡总共有94条腿。然后，可以用数学工具把它变化为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>x = <span class="number">94</span> - <span class="number">70</span></span><br></pre></td></tr></table></figure></p>
<p>这代表了什么意思呢？一种可行的理解方式是：假如把<code>35</code>全部分配为鸡的话<code>(35 * 2)</code>，剩余的腿<code>(94 - 70)</code>如何去分配呢？分配的限制条件是只能分配成兔子，也就是说要以两个两个的方式去分配，而被分配到的就变成了兔子，这就是<code>2x</code>所表示的意义。那么这个正向思路也就倒着推出来了。</p>
<h1 id="总结">总结</h1><p>思维的方式是决定或影响算法的一个重要因素。有时候从正反两个方面去分析问题，能更容易地找到思路。本文的目的不是告诉大家鸡兔同笼这个问题如何去解，而是通过分析解这道题的思路去认识和了解算法的思维。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>约1500年前，《孙子算经》中有如下的问题描述：</p>
<blockquote>
<p>今有雉兔同笼，上有三十五头，下有九十四足，问雉兔各几何？</p>
</blockquote>
<p>首先科普一下，《孙子算经》的作者不详，且同《孙子兵法》不是一个作者。</p>
<p>进入正题：在数学发展到今天的水平来看，这是个很简单的问题，是一个初中问题或是小学奥数问题。然而用一些简单的问题去说明一些道理还是更容易让人接受的，毕竟如果直接拿哥德巴赫猜想（我也不会）这种世界性难题来说明道理是很难让人理解的，因为门槛太高。当然，这里要介绍的内容跟任何计算机程序语言都没有关系，只是统一分类到我的C++算法笔记作为一个子类别而已。</p>]]>
    
    </summary>
    
      <category term="数学" scheme="http://blog.liushuping.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="数论" scheme="http://blog.liushuping.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="算法" scheme="http://blog.liushuping.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="逻辑" scheme="http://blog.liushuping.com/tags/%E9%80%BB%E8%BE%91/"/>
    
      <category term="C++算法笔记" scheme="http://blog.liushuping.com/categories/C-%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++算法笔记－基本输入输出]]></title>
    <link href="http://blog.liushuping.com/2015/10/28/C++%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%EF%BC%8D%E5%9F%BA%E6%9C%AC%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
    <id>http://blog.liushuping.com/2015/10/28/C++算法笔记－基本输入输出/</id>
    <published>2015-10-28T15:24:51.000Z</published>
    <updated>2015-11-09T13:40:23.000Z</updated>
    <content type="html"><![CDATA[<p>算法题目都是要求对于给定的输入，在规定时间内把结果输出到指定的设备上。因此输入输出是做算法的最基本条件。</p>
<h1 id="输入">输入</h1><p>C++中输入有两种常见的形式：来自标准输入设备<code>stdin</code>和来自文件。</p>
<h2 id="标准输入设备stdin">标准输入设备stdin</h2><h3 id="输入重定向">输入重定向</h3><p>默认情况下<code>stdin</code>来自于键盘的输入，然而我们可以把它重定向到任何其它可用的设备，比如常见的文件。在常见的系统中，对于一个控制台程序，我们可以用输入重定向来把标准输入重定向到文件设备。例如下列代码把程序<code>test</code>的标准输入重定向到了文件<code>file1.txt</code>:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test &lt; file1.txt</span><br></pre></td></tr></table></figure></p>
<p>这是一个非常实用的功能：在程序算法题中常见的输入是一个文件，如果通过把文件内容粘贴到控制台程序来实现输入会很不方便，尤其是当文件内容非常大的时候。</p>
<p>除输入重定向之外，还可以通过<code>freopen</code>来使一个已经存在的流<code>stream</code>指向目标文件。当然，<code>stdin</code>，<code>stdout</code>，以及<code>stderr</code>都是流的一种，因此我们可以用该函数来实现输入的重定向。下面的代码实现了把标准输入重定向到文件<code>file1.txt</code>:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">freopen(“file1.txt”, “r”, <span class="built_in">stdin</span>);</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>函数<code>freopen</code>的第二个参数表示了文件的访问模式，有下面的几种可能的取值：</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>”r”</td>
<td>以读取的方式打开文件，文件必须存在</td>
</tr>
<tr>
<td>”w”</td>
<td>创建一个空文件用来写入。如果文件内容存在，则忽略文件内容并按照空文件的方式写入内容</td>
</tr>
<tr>
<td>”a”</td>
<td>按照追加模式打开文件写入内容。如果文件不存在，则创建文件</td>
</tr>
<tr>
<td>”r+”</td>
<td>以读取并更新的模式打开一个文件，文件必须存在</td>
</tr>
<tr>
<td>”w+”</td>
<td>以写入并更新的模式创建一个文件。如果文件存在，则忽略内容并按照空文件的方式对待</td>
</tr>
<tr>
<td>”a+”</td>
<td>以追加并更新的模式打开一个文件。文件定位操作会影响下次输入的操作，而输出内容总是会被追加到文件末尾。如果文件不存在，则创建文件</td>
</tr>
</tbody>
</table>
<p>上面所列模式都是以文本方式打开文件，这也是大多数算法程序常见的输入模式。若需要以二进制的方式读取文件，在模式中添加一个<code>b</code>字符即可，该字符可处于任何位置，如：<code>rb</code>，<code>bw</code>。<br>作为良好的习惯，在文件使用完毕后应该将其关闭：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">freopen(“file1.txt”, “r”, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">fclose(<span class="built_in">stdin</span>);</span><br></pre></td></tr></table></figure></p>
<p>关于<code>freopen</code>的信息，请参考<a href="http://www.cplusplus.com/reference/cstdio/freopen/" target="_blank" rel="external">链接</a>。</p>
<h3 id="读取标准输入设备stdin">读取标准输入设备stdin</h3><h4 id="std::cin">std::cin</h4><p><code>std::cin</code>是指向标准输入设备<code>stdin</code>的流对象，通过流输入运算符<code>&gt;&gt;</code>可以从标准输入设备中读取内容到指定的内存变量中。例如下面的代码是从标准输入设备中读取一个整数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br></pre></td></tr></table></figure></p>
<p>默认的读取方式是以空格或换行符号为分隔的。假如输入设备中有内容 <code>10 20 abc</code>，可以方便的用以下代码读取：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> c;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br></pre></td></tr></table></figure></p>
<h4 id="std::cin读取空格或换行符">std::cin读取空格或换行符</h4><p>如果确需要读取空格或换行字符，则需要用到<code>std::cin.get();</code>函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s;</span><br><span class="line">s = <span class="built_in">std</span>::<span class="built_in">cin</span>.get();</span><br></pre></td></tr></table></figure></p>
<h4 id="std::cin读取非十进制数字">std::cin读取非十进制数字</h4><p>如果要读取的字符是非十进制数字，则需要告诉<code>std::cin</code>按照指定的进制读取，可以通过<code>std::setbase()</code>来指定：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; <span class="built_in">std</span>::setbase(<span class="number">16</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br></pre></td></tr></table></figure></p>
<h4 id="cin读取整行">cin读取整行</h4><p>可以通过<code>std::cin.getline()</code>或<code>std::getline()</code>来实现读取一行内容。实际使用中，<code>std::getline()</code>更常用一些，因为它直接支持STL字符串类型，更加方便：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">std</span>::getline(<span class="built_in">cin</span>, s);</span><br></pre></td></tr></table></figure></p>
<p>更多的关于<code>std::getline()</code>的内容，参考<a href="http://www.cplusplus.com/reference/string/string/getline/?kw=getline" target="_blank" rel="external">链接</a>。<br>关于<code>std::cin.getline()</code>的内容，参考<a href="http://www.cplusplus.com/reference/istream/istream/getline/" target="_blank" rel="external">链接</a>。</p>
<h4 id="std::cin其它相关">std::cin其它相关</h4><p>事实上，<code>std::cin</code>是<code>std::istream</code>的一个实例，因此<code>std::istream</code>的所有公开方法都可以通过<code>std::cin</code>调用。比如流读取位置定位，<code>peek</code>以及忽略当前字符等等功能。这些高级功能在算法程序中应用的比较少，就不赘述了，具体内容可参考<a href="http://www.cnblogs.com/pegasus923/archive/2011/04/22/2024418.html" target="_blank" rel="external">链接</a>。</p>
<h3 id="scanf">scanf</h3><p><code>scanf</code>是C风格的从标准输入设备读取格式化数据的强有力的方法，它从<code>stdin</code>中读取内容，其参数类型丰富强大，但也不容易记忆。<code>scanf</code>接受至少一个参数的变长参数，第一个参数是以C类型字符串表示的输入参数格式。后面的其它参数应该是一系列预先分配好的变量，依次对应参数格式字符串内的标识符。例如下面代码表示从<code>stdin</code>中读取一个整型数字到变量<code>x</code>中：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(“%i”, &amp;x);</span><br></pre></td></tr></table></figure></p>
<p>其中参数格式字符串的格式是：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%[<span class="link_label">*</span>][<span class="link_reference">width</span>][<span class="link_label">length</span>]specifier</span><br></pre></td></tr></table></figure></p>
<p>这其中的的<code>specifier</code>有如下的定义：</p>
<table>
<thead>
<tr>
<th>specifier</th>
<th>解释</th>
<th>读取的字符</th>
</tr>
</thead>
<tbody>
<tr>
<td>i</td>
<td>Integer</td>
<td>整数，有符号的(singed)，可以以<code>+</code>或<code>-</code>开头。默认是十进制，若以0开头则认为是8进制，以0x开头则认为是16进制</td>
</tr>
<tr>
<td>d, u</td>
<td>Decimal Integer</td>
<td>十进制整数，可以以<code>+</code>或<code>-</code>开头。<code>d</code>代表有符号的，<code>u</code>代表无符号的</td>
</tr>
<tr>
<td>o</td>
<td>Octal integer</td>
<td>八进制整数，可以以<code>+</code>或<code>-</code>开头。无符号参数</td>
</tr>
<tr>
<td>x</td>
<td>Hexadecimal integer</td>
<td>十六进制整数，可以以<code>0x</code>或<code>0X</code>开头，同时也可以以<code>+</code>或<code>-</code>开头。无符号参数</td>
</tr>
<tr>
<td>f, e, g</td>
<td>Floating Point Number</td>
<td>浮点数，可带小数点，开头可以包含<code>+</code>或<code>-</code>，可以用科学记数法。C99标准支持以<code>0x</code>或<code>0X</code>开头的十六进制数</td>
</tr>
<tr>
<td>c</td>
<td>Character</td>
<td>读取下一个字符。如果<code>width</code>是大于<code>1</code>的数，则读取相应数量的字符，并把它们放在指定的内存连续空间内，但不会在结尾处添加<code>null</code>字符。</td>
</tr>
<tr>
<td>s</td>
<td>String of characters</td>
<td>从当前位置开始读取字符，直到下一个字符是空白字符。读取完毕后会在存储变量后添加一个代表结束的<code>null</code>字符</td>
</tr>
<tr>
<td>p</td>
<td>Pointer address</td>
<td>读取一系列代表指针的字符，它的格式会因不同系统及不同库而不同，但是它跟在<code>fprintf</code>中的<code>%p</code>的参数使用方式是一样的</td>
</tr>
<tr>
<td>[characters]</td>
<td>Scanset</td>
<td>从当前位置开始读取字符，直到下一个字符是方括号内未定义的字符停止</td>
</tr>
<tr>
<td>[^characters]</td>
<td>Negated scanset</td>
<td>从当前位置开始读取字符，直到下一个字符是方括号内定义的字符停止</td>
</tr>
<tr>
<td>n</td>
<td>Count</td>
<td>不会读取字符，会返回当前已读取字符的个数到对应参数所指向的存储空间</td>
</tr>
<tr>
<td>%</td>
<td>%</td>
<td>表示读取一个%字符</td>
</tr>
</tbody>
</table>
<p>除<code>n</code>之外，其它任何的标识符都至少会触发读取一个字符，否则匹配失败，读取扫描结束。</p>
<p>参数格式中的<code>*</code>，<code>width</code>及<code>length</code>的解释如下：</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>可选参数，表示数据会被读取并被忽略，不会存储到某个地址中</td>
</tr>
<tr>
<td>width</td>
<td>可选参数，指定了读取字符的最大个数</td>
</tr>
<tr>
<td>length</td>
<td>可选参数，可以是<code>hh</code>, <code>h</code>, <code>l</code>, <code>ll</code>, <code>j</code>, <code>z</code>, <code>t</code>, <code>L</code>中的任一值，表明了对存储地址的期望类型</td>
</tr>
</tbody>
</table>
<p>下表列出了不同<code>length</code>对不同标识符的类型期望：</p>
<table>
<thead>
<tr>
<th>length</th>
<th>d i</th>
<th>u o x</th>
<th>f e g a</th>
<th>c s [] [^]</th>
<th>p</th>
<th>n</th>
</tr>
</thead>
<tbody>
<tr>
<td>(none)</td>
<td>int*</td>
<td>unsigned int*</td>
<td>float*</td>
<td>char*</td>
<td>void**</td>
<td>int*</td>
</tr>
<tr>
<td>hh</td>
<td>signed char*</td>
<td>unsigned char*</td>
<td></td>
<td></td>
<td></td>
<td>singed char*</td>
</tr>
<tr>
<td>h</td>
<td>short int*</td>
<td>unsigned short int*</td>
<td></td>
<td></td>
<td></td>
<td>short int*</td>
</tr>
<tr>
<td>l</td>
<td>long int*</td>
<td>unsigned long int*</td>
<td>double*</td>
<td>wchar_t*</td>
<td></td>
<td>long int*</td>
</tr>
<tr>
<td>ll</td>
<td>long long int*</td>
<td>unsigned long long int*</td>
<td></td>
<td></td>
<td></td>
<td>long int*</td>
</tr>
<tr>
<td>j</td>
<td>intmax_t*</td>
<td>uintmax_t*</td>
<td></td>
<td></td>
<td></td>
<td>intmax_t*</td>
</tr>
<tr>
<td>z</td>
<td>size_t*</td>
<td>size_t*</td>
<td></td>
<td></td>
<td></td>
<td>size_t*</td>
</tr>
<tr>
<td>t</td>
<td>ptrdiff_t*</td>
<td>ptrdiff_t*</td>
<td></td>
<td></td>
<td></td>
<td>ptfdiff_t*</td>
</tr>
<tr>
<td>L</td>
<td></td>
<td></td>
<td>long double*</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>函数返回有多少个参数被设置值了，可能是返回所有参数的个数，如果发生了任何错误，则可能是比它小的一个数字。</p>
<p>关于<code>scanf</code>更多内容请参考<a href="http://www.cplusplus.com/reference/cstdio/scanf/?kw=scanf" target="_blank" rel="external">链接</a>。</p>
<h3 id="读取文件内容">读取文件内容</h3><p>当输入内容来自于文件时，对于编写算法程序，推荐的做法是通过输入重定向或<code>freopen</code>让<code>stdin</code>指向输入文件。然而如果确需要直接读取文件，可以使用<code>fopen</code>打开文件然后配合多种文件的读取函数来实现期望的对输入文件的读取，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FILE *file;</span><br><span class="line">file = fopen(<span class="string">"stdinout.cpp"</span>, <span class="string">"r"</span>);</span><br><span class="line"><span class="keyword">char</span> c = getc(file);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c;</span><br><span class="line">fclose(file);</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，<code>getc</code>的作用是从指定的文件中读取下一个字符。除此之外，还有很多从文件读取内容的函数，如<code>fgetc</code>，<code>fgets</code>，<code>fscanf</code>等。由于算法程序中输入大多是顺序的文本文件读取操作，因此输入重定向结合读取标准输入设备的方式更实用。文件的读取方式便不再赘述，有关详细内容可参考<a href="http://www.cplusplus.com/reference/cstdio/" target="_blank" rel="external">链接</a>。</p>
<h1 id="输出">输出</h1><p>C++中输出有两种常见的形式：标准输出设备<code>stdout</code>和文件。</p>
<h2 id="标准输出设备stdout">标准输出设备stdout</h2><h3 id="输出重定向">输出重定向</h3><p>默认情况下，<code>stdout</code>指向的是显示器，然而我们可以把它重定向到任何其它可用的设备，例如文件。在常见的系统中，对于一个控制台程序，我们可以通过输出重定向来让<code>stdout</code>指向文件，例如下面的代码把<code>test</code>程序的输出重定向到了文件<code>file1.txt</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span> &gt; file1.txt</span><br></pre></td></tr></table></figure></p>
<p>输出重定向是一个非常实用的功能：当程序输出内容很多的时候，显示器会翻屏甚至清除掉前面输出的内容，不方便人工查看。因此，可以把内容输出重定向到文件内，方便人工查看和备份。</p>
<p>除了输出重定向外，还可以通过<code>freopen</code>来让一个已经存在的<code>stream</code>指向指定的目标文件。它的使用方式已经在<a href="#输入重定向">输入重定向</a>中详细介绍了，这里不在赘述，区别是输出的时候文件打开模式要是<code>&quot;w&quot;</code>。</p>
<h3 id="写入到标准输出设备stdout">写入到标准输出设备stdout</h3><h4 id="std::cout">std::cout</h4><p><code>std::cout</code>是指向标准输出设备<code>stdout</code>的流对象，通过流运算符<code>&lt;&lt;</code>可以输出内容到标准输出设备中。例如下面的代码是向标准设备输出整数<code>x</code>:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">x = <span class="number">123</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x;</span><br></pre></td></tr></table></figure></p>
<h4 id="std::cout输出空行">std::cout输出空行</h4><p>当需要输出空行是，可以用<code>\n</code>或者<code>std::endl</code>的方式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::endl;</span><br></pre></td></tr></table></figure></p>
<h4 id="std::cout输出指定宽度">std::cout输出指定宽度</h4><p>当需要对输出内容指定宽度时，可以使用<code>std::setw()</code>函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setw(<span class="number">5</span>) &lt;&lt; <span class="number">11</span> &lt;&lt; <span class="built_in">std</span>::endl;</span><br></pre></td></tr></table></figure></p>
<p>输出时，数字<code>11</code>的左侧会填充三个空格。值得注意的是，<code>std::setw()</code>只会影响下一次输出，并不会影响后续的输出。<code>std::set()</code>来自于头文件<code>&lt;iomanip&gt;</code>。</p>
<h4 id="std::cout指定输出的填充字符">std::cout指定输出的填充字符</h4><p>当对输出内容指定输出宽度，但内容不够宽度时，输出内容的左侧会以空格字符填充。如果需要指定不同的填充字符，则使用<code>std::setfill()</code>，如下代码则用字符<code>x</code>做为填充：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setfill(<span class="string">'x'</span>) &lt;&lt; <span class="built_in">std</span>::setw(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">11</span> &lt;&lt; <span class="built_in">std</span>::endl;</span><br></pre></td></tr></table></figure></p>
<h4 id="std::cout输出非十进制数字">std::cout输出非十进制数字</h4><p>当需要输出的内容是非十进制时，可以通过<code>std::setbase()</code>来指定：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setbase(<span class="number">16</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">0xff</span> &lt;&lt; <span class="built_in">std</span>::endl;</span><br></pre></td></tr></table></figure></p>
<p>STL预定义了一些进制标识符可以用做<code>std::setbase()</code>的参数，他们是：<code>std::dec</code>，<code>std::hex</code>和<code>std::oct</code>。</p>
<h4 id="std::cout设置流的格式">std::cout设置流的格式</h4><p>通过<code>std::setbase()</code>可以设置下一次数的输出进制，然而如果需要多次输出则需要多次设置。<code>std::cout</code>支持全局设置格式，直到取消前该格式会一直影响输出设置。STL定义了一系列的基于位运算的格式，详细信息如下表所列：</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>常量</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>独立标志位</td>
<td>boolalpha</td>
<td>以字符串的形式(true，false)读取布尔变量</td>
</tr>
<tr>
<td>独立标志位</td>
<td>showbase</td>
<td>在输出整数之前输出其进制标识符</td>
</tr>
<tr>
<td>独立标志位</td>
<td>showpoint</td>
<td>输出浮点数时，总是输出小数点</td>
</tr>
<tr>
<td>独立标志位</td>
<td>showpos</td>
<td>输出非负数时，以+号开始</td>
</tr>
<tr>
<td>独立标志位</td>
<td>skipws</td>
<td>这个参数用在输入时，其作用是忽略某些输入操作开头部分的空格</td>
</tr>
<tr>
<td>独立标志位</td>
<td>unitbuf</td>
<td>每次插入操作后，都进行一次写出(flush)操作</td>
</tr>
<tr>
<td>独立标志位</td>
<td>uppercase</td>
<td>在某些插入操作，以大写字母代替小写字幕</td>
</tr>
<tr>
<td>进制(basefield)</td>
<td>dec</td>
<td>以十进制读取或写入整数</td>
</tr>
<tr>
<td>进制(basefield)</td>
<td>hex</td>
<td>以十六进制读取或写入整数</td>
</tr>
<tr>
<td>进制(basefield)</td>
<td>oct</td>
<td>以八进制读取或写入整数</td>
</tr>
<tr>
<td>浮点数格式(floatfield)</td>
<td>fixed</td>
<td>以固定小数点的形式输出浮点数</td>
</tr>
<tr>
<td>浮点数格式(floatfield)</td>
<td>scientific</td>
<td>以科学计数法的形式输出浮点数</td>
</tr>
<tr>
<td>对齐方式(adjustfield)</td>
<td>internal</td>
<td>通过在指定位置插入填充字符的方式来使输出达到指定宽度</td>
</tr>
<tr>
<td>对齐方式(adjustfield)</td>
<td>left</td>
<td>通过在末尾追加填充字符的方式来使输出达到指定宽度</td>
</tr>
<tr>
<td>对齐方式(adjustfield)</td>
<td>right</td>
<td>通过在开头添加填充字符的方式来使输出达到指定宽度</td>
</tr>
</tbody>
</table>
<p>格式可以是上述任意一种或是它们任意多个的组合。<code>basefield</code>，<code>floatfield</code>和<code>adjustfield</code>是三个预定义的组合，它们分别对应的值如下表所列：</p>
<table>
<thead>
<tr>
<th>组合</th>
<th>组合形式</th>
</tr>
</thead>
<tbody>
<tr>
<td>basefield</td>
<td>dec&#124;hex&#124;oct</td>
</tr>
<tr>
<td>floatfield</td>
<td>fixed&#124;scientific</td>
</tr>
<tr>
<td>adjustfield</td>
<td>internal&#124;left&#124;right</td>
</tr>
</tbody>
</table>
<p>这些常量值都定义在<code>ios_base</code>类中，因此可以通过<code>ios_base</code>及其子类，或任何其实例来访问这些常量。例如：<code>std::ios_base::hex</code>，<code>std::ios::hex</code>或<code>std::cout.hex</code>。可以通过<code>std::cout.setf()</code>函数来设置这些值：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::<span class="built_in">cout</span>.hex);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::ios_base::hex);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::ios::hex);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::out.hex, <span class="built_in">std</span>::<span class="built_in">cout</span>.basefield)</span><br></pre></td></tr></table></figure></p>
<p>从代码中可以看出，<code>std::cout.setf()</code>有重载，可以是给定一个参数，相当于只设置这个标志位而不影响其它标志位；也可以是两个参数，其作用是设置第二个参数所影响范围内的标志位，把其值设置为第一个参数和第二个参数的逻辑与之后的值，而第二个参数标志位以外的标志位不受影响。关于<code>std::cout.setf()</code>的更多信息请参考<a href="http://www.cplusplus.com/reference/ios/ios_base/setf/" target="_blank" rel="external">链接</a></p>
<p>另外，<code>std::cout.setiosflags()</code>等同于<code>std::cout.setf()</code>的两参数版本；<code>std:cout.resetiosflags()</code>等同于<code>std::cout.unsetf()</code>的两参数版本。</p>
<p>任何时刻可以通过<code>std::cout.unsetf()</code>来取消之前所设置的任何标志位。</p>
<p>任何时刻都可以通过<code>std::cout.flags()</code>来获取当前已经设置的所有标志位。<code>std::cout.flags()</code>还有一个重载，接受一个标志位参数，不同于<code>std::cout.setf()</code>的是，它会清除所有其它的标志位，只保留所设置的标志位。</p>
<h3 id="printf">printf</h3><p><code>printf</code>是C风格的向标准输出设备输出格式化字符串的强有力方法，它有同<code>scanf</code>类似的参数定义，但对参数格式字符串的定义有略微的不同，其定义是：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%[<span class="link_label">flags</span>][<span class="link_reference">width</span>][<span class="link_label">.precision</span>][<span class="link_reference">length</span>]specifier</span><br></pre></td></tr></table></figure></p>
<p>对其中的<code>specifier</code>的解释如下表：</p>
<table>
<thead>
<tr>
<th>specifier</th>
<th>输出</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>d或i</td>
<td>有符号的十进制整数</td>
<td>123</td>
</tr>
<tr>
<td>u</td>
<td>无符号的十进制整数</td>
<td>1234</td>
</tr>
<tr>
<td>o</td>
<td>无符号的八进制整数</td>
<td>723</td>
</tr>
<tr>
<td>x</td>
<td>无符号的十六进制整数</td>
<td>ab12</td>
</tr>
<tr>
<td>X</td>
<td>大写的无符号十六进制整数</td>
<td>AB12</td>
</tr>
<tr>
<td>f</td>
<td>小写的十进制浮点数</td>
<td>123.45</td>
</tr>
<tr>
<td>F</td>
<td>大写的十进制浮点数</td>
<td>123.45</td>
</tr>
<tr>
<td>e</td>
<td>小写的科学计数法数</td>
<td>1.2345e+2</td>
</tr>
<tr>
<td>E</td>
<td>大写的科学计数法数</td>
<td>1.2345E+2</td>
</tr>
<tr>
<td>g</td>
<td>在%f和%e之间取比较短的表示方式</td>
<td>123.45</td>
</tr>
<tr>
<td>G</td>
<td>在%F和%E之间取比较短的表示方式</td>
<td>123.45</td>
</tr>
<tr>
<td>a</td>
<td>小写16进制浮点数</td>
<td>-0xabc123.45ep-3</td>
</tr>
<tr>
<td>A</td>
<td>大写16进制浮点数</td>
<td>-0XABC123.45EP-3</td>
</tr>
<tr>
<td>c</td>
<td>字符</td>
<td>a</td>
</tr>
<tr>
<td>s</td>
<td>字符串</td>
<td>test</td>
</tr>
<tr>
<td>p</td>
<td>指针地址</td>
<td>f1234567</td>
</tr>
<tr>
<td>n</td>
<td>不会输出任何内容，对应的参数应该是一个有符号整数，会把当前已经输出的字符个数存储到该参数对应的变量中</td>
<td></td>
</tr>
<tr>
<td>%</td>
<td>输出一个%符号</td>
<td>%</td>
</tr>
</tbody>
</table>
<p>对格式串中的<code>flags</code>域有如下表所列解释：</p>
<table>
<thead>
<tr>
<th>flags</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>-</td>
<td>以左对齐的方式输出指定内容，默认是右对齐</td>
</tr>
<tr>
<td>+</td>
<td>强制数字的输出以<code>+</code>或<code>-</code>符号开始，即使是正数。默认只有负数才以符号位开始</td>
</tr>
<tr>
<td>(空格)</td>
<td>如果无符号输出，则在值之前输出一个空格</td>
</tr>
<tr>
<td>#</td>
<td>当跟o，x或X一起使用时，用来指示值是以0，0x或0X开头。当跟a，A，e，E，f，F，g，G一起使用时，强制输出小数点后的位数。默认情况下，如果没有小数点后的位数则不输出小数点</td>
</tr>
<tr>
<td>0</td>
<td>当对输出指定宽度时(见下表)，不足位数在左侧以0补齐</td>
</tr>
</tbody>
</table>
<p>对格式串中的<code>width</code>域的解释如下：</p>
<table>
<thead>
<tr>
<th>width</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>数字</td>
<td>输出字符串的最小宽度，当不足宽度时以空格或其它指定的字符补齐；当要输出的内容比指定的宽度长时，内容不会被截断</td>
</tr>
<tr>
<td>*</td>
<td>未在格式串中指定宽度，而是由对应的一个额外的参数（来自于参数列表）来指定。</td>
</tr>
</tbody>
</table>
<p>对格式串中的 <code>.precision</code>域的解释如下：</p>
<table>
<thead>
<tr>
<th>.precision</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>.number</td>
<td>当和整数标识符(d，i，o，u，x，X）一起使用时，表示要输出的总位数，不够时在左侧以0补齐。当要输出的数字超出这个长度时不会被截断。当<code>precision</code>是0的时候，表示对0不会输出任何字符。当同a，A，e，E，f或F一起使用时，表示要输出的小数点后的位数。当结合g或G使用时，表示要输出的最大有效位数。当与s结合使用时，表示要输出的最大字符数，默认情况下会一直输出到空字符结束。</td>
</tr>
<tr>
<td>.*</td>
<td>未在格式串中指定精度，而是由对应的一个额外参数（来自于参数列表）来指定。</td>
</tr>
</tbody>
</table>
<p>而格式串中的<code>length</code>与<a href="#scanf">scanf</a>格式串中的<code>length</code>域有相同的解释，不再重复。</p>
<h3 id="写入文件内容">写入文件内容</h3><p>当需要输出内容到文件时，对于编写算法程序，推荐的做法是通过输出重定向或<code>freopen</code>让<code>stdout</code>指向目标输出文件。然而如果确需要直接写入文件，可以使用<code>fopen</code>以写入的方式打开文件并进行写入，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FILE *file;</span><br><span class="line">file = fopen(<span class="string">"test.txt"</span>, <span class="string">"wt"</span>);</span><br><span class="line">putc(<span class="string">'a'</span>, file);</span><br><span class="line">fclose(file);</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，<code>putc</code>的作用是向文件<code>test.txt</code>中输出一个指定的字符。除此之外，还有其它写入文件内容的函数，如<code>fputc</code>，<code>fputs</code>，<code>fprintf</code>等。由于算法程序大多是顺序的输出，因此输出重定向结合写入标准输出设备的方式更实用。文件的写入方式便不再赘述，有关详细内容可参考<a href="http://www.cplusplus.com/reference/cstdio/" target="_blank" rel="external">链接</a>。</p>
<h1 id="输出的效率">输出的效率</h1><p>算法程序的一个重要考量因素是程序的运行效率。除去程序逻辑本身是算法效率高低的主要因素之外，输出的效率也是一个应该考虑的因素，尤其是当输出的数据量非常大时。例如在一个非常大的循环内输出数据，而输出又被定向到文件内，这样多次的文件写入必然会造成效率的损失。因此，把要输出的数据缓存在一个内存空间内，待所有数据准备完毕后，一次性输出到文件内，则可提高一定的效率。</p>
<h1 id="头文件">头文件</h1><p><code>std::cin</code>和<code>std::cout</code>来自于头文件<code>&lt;iostream&gt;</code><br><code>std::cin</code>和<code>std::cout</code>输入输出格式的控制函数存在于<code>&lt;iomanip&gt;</code>头文件中。<br><code>scanf</code>和<code>printf</code>函数来自于头文件<code>&lt;stdio.h&gt;</code></p>
<h1 id="TL;DR">TL;DR</h1><p>基本的输入输出是算法程序的重要基础。在C++算法程序中，输入输出的重定向可以方便快捷地让标准输入输出设备指向所指定的文件。而C++ STL中的<code>cin</code>和<code>cout</code>流可以很方便地从标准输入设备读取数据和向标准输出设备输出数据。<code>scanf</code>和<code>printf</code>是C风格的输入输出函数。熟练掌握输入输出数据格式的控制，是正确处理输入输出文件的重要前提，也是保证算法程序正确性的一个基本前提。</p>
<p>把要输出的内容缓存到一个内存空间内，待所有数据准备完毕后一次性把结果写出到输出设备中，可以一定程度地提高程序的运行效率。当然，这需要在内存的占用空间和算法效率之间做一些权衡。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>算法题目都是要求对于给定的输入，在规定时间内把结果输出到指定的设备上。因此输入输出是做算法的最基本条件。</p>
<h1 id="输入">输入</h1><p>C++中输入有两种常见的形式：来自标准输入设备<code>stdin</code>和来自文件。</p>
<h2 id="标准输入设备stdin">标准输入设备stdin</h2><h3 id="输入重定向">输入重定向</h3><p>默认情况下<code>stdin</code>来自于键盘的输入，然而我们可以把它重定向到任何其它可用的设备，比如常见的文件。在常见的系统中，对于一个控制台程序，我们可以用输入重定向来把标准输入重定向到文件设备。例如下列代码把程序<code>test</code>的标准输入重定向到了文件<code>file1.txt</code>:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test &lt; file1.txt</span><br></pre></td></tr></table></figure></p>
<p>这是一个非常实用的功能：在程序算法题中常见的输入是一个文件，如果通过把文件内容粘贴到控制台程序来实现输入会很不方便，尤其是当文件内容非常大的时候。</p>
<p>除输入重定向之外，还可以通过<code>freopen</code>来使一个已经存在的流<code>stream</code>指向目标文件。当然，<code>stdin</code>，<code>stdout</code>，以及<code>stderr</code>都是流的一种，因此我们可以用该函数来实现输入的重定向。下面的代码实现了把标准输入重定向到文件<code>file1.txt</code>:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">freopen(“file1.txt”, “r”, <span class="built_in">stdin</span>);</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="C++" scheme="http://blog.liushuping.com/tags/C/"/>
    
      <category term="算法" scheme="http://blog.liushuping.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="C++算法笔记" scheme="http://blog.liushuping.com/categories/C-%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Backbone router demo]]></title>
    <link href="http://blog.liushuping.com/2015/08/09/Backbone-router-demo/"/>
    <id>http://blog.liushuping.com/2015/08/09/Backbone-router-demo/</id>
    <published>2015-08-09T14:48:36.000Z</published>
    <updated>2015-10-25T10:40:14.000Z</updated>
    <content type="html"><![CDATA[<p>这是一个简单的关于Backbone router的演示，下面的例子演示了，通过Backbone的router和pushState来达到省略URL中的Hash符号的目的。</p>
<p>首先定义一个App需要的router，例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> AppRouter = Backbone.Router.extend(&#123;  </span><br><span class="line">    routes : &#123;  </span><br><span class="line">        <span class="string">'help'</span>: <span class="string">'help'</span>,  </span><br><span class="line">        <span class="string">'search/:query'</span>: <span class="string">'search'</span>, </span><br><span class="line">        <span class="string">'search/:query/:page'</span>: <span class="string">'search'</span></span><br><span class="line">    &#125;,   </span><br><span class="line"></span><br><span class="line">    search: <span class="function"><span class="keyword">function</span>(<span class="params">query, page</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (page == <span class="literal">null</span>) &#123;</span><br><span class="line">          alert(<span class="string">'query: '</span> + query);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          alert(<span class="string">'query: '</span> + query + <span class="string">', page: '</span> + page);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>接下来启动<code>history</code>的状态记录：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Backbone.history.start(&#123;pushState: <span class="literal">true</span>&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这里如果页面所在的目录不是根目录，则需要添加root参数。</p>
<p>然后我们就可以用router来控制URL状态了：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> router = <span class="keyword">new</span> AppRouter();</span><br><span class="line">router.navigate(<span class="string">'search/myquery/123'</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure></p>
<p>这很有用，然而并不是所有的状态变化都是我们通过代码来修改<code>router</code>的状态，更多的是可能交给用户去“导航”，比如<code>&lt;a&gt;</code>标签。然而不幸的是，<code>Backbone</code>并没有对<code>&lt;a&gt;</code>标签做任何的定制，也就是说如果不做任何处理的话，<code>&lt;a&gt;</code>标签的点击事件还是会触发浏览器向服务器发起HTTP请求的，这并不是我们想要的。</p>
<p>因此，我们应该做的是阻断a标签的<code>click</code>事件，在事件里面阻止<code>&lt;a&gt;</code>标签的默认行为，修改为我们的<code>router.navigate</code>行为。例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).on(<span class="string">'click'</span>, <span class="string">'a'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> href = $(<span class="keyword">this</span>).prop(<span class="string">'href'</span>);</span><br><span class="line">    href = href.slice(...) <span class="comment">// 去掉root部分</span></span><br><span class="line">    router.navigate(href, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果我们并不想这样处理所有的<code>&lt;a&gt;</code>标签，比如仍保留某些向服务器发送HTTP请求的功能。这可以通过有条件的选择，一个好的方式是把所有不期望向服务器发送请求的<code>&lt;a&gt;</code>标签的href都以<code>&#39;#&#39;</code>开头，否则则认为向服务器发送请求。此时阻断代码可以写成如下的样子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).on(<span class="string">'click'</span>, <span class="string">'a[href*="#"]'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> href = $(<span class="keyword">this</span>).prop(<span class="string">'href'</span>);</span><br><span class="line">    href = href.slice(...) <span class="comment">// 去掉root部分</span></span><br><span class="line">    router.navigate(href, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>点击下面的链接及浏览器的前进后退按钮查看运行效果：</p>
<p><base href="/2015/08/09/Backbone-router-demo/"></p>
<div id="demo"><br>  <a href="#help">help</a><br>  <a href="#search/myquery">search “myquery”</a><br>  <a href="#search/myquery/page1">search “myquery/page1”</a><br><br>  <script src="http://cdn.staticfile.org/jquery/2.1.1/jquery.min.js"></script><br>  <script src="http://cdn.staticfile.org/underscore.js/1.7.0/underscore-min.js"></script><br>  <script src="http://cdn.staticfile.org/backbone.js/1.1.2/backbone-min.js"></script><br>  <script src="/assets/backbone-router-demo.js"></script><br></div>]]></content>
    <summary type="html">
    <![CDATA[<p>这是一个简单的关于Backbone router的演示，下面的例子演示了，通过Backbone的router和pushState来达到省略URL中的Hash符号的目的。</p>
<p>首先定义一个App需要的router，例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> AppRouter = Backbone.Router.extend(&#123;  </span><br><span class="line">    routes : &#123;  </span><br><span class="line">        <span class="string">'help'</span>: <span class="string">'help'</span>,  </span><br><span class="line">        <span class="string">'search/:query'</span>: <span class="string">'search'</span>, </span><br><span class="line">        <span class="string">'search/:query/:page'</span>: <span class="string">'search'</span></span><br><span class="line">    &#125;,   </span><br><span class="line"></span><br><span class="line">    search: <span class="function"><span class="keyword">function</span>(<span class="params">query, page</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (page == <span class="literal">null</span>) &#123;</span><br><span class="line">          alert(<span class="string">'query: '</span> + query);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          alert(<span class="string">'query: '</span> + query + <span class="string">', page: '</span> + page);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="Backbone" scheme="http://blog.liushuping.com/tags/Backbone/"/>
    
      <category term="Route" scheme="http://blog.liushuping.com/tags/Route/"/>
    
      <category term="Backbone" scheme="http://blog.liushuping.com/categories/Backbone/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode OJ 238 Product of Array Except Self]]></title>
    <link href="http://blog.liushuping.com/2015/07/26/LeetCode-OJ-238-Product-of-Array-Except-Self/"/>
    <id>http://blog.liushuping.com/2015/07/26/LeetCode-OJ-238-Product-of-Array-Except-Self/</id>
    <published>2015-07-26T14:17:39.000Z</published>
    <updated>2015-10-25T10:41:23.000Z</updated>
    <content type="html"><![CDATA[<p>给定一个有<code>n</code>个元素且<code>n</code>大于<code>1</code>的一维数组<code>nums</code>，计算并返回一个数组<code>output</code>，使其任一元素<code>output[i]</code>的值是数组<code>nums</code>除<code>nums[i]</code>外的其它所有元素的乘积。要求不能使用除法，且在<code>O(n)</code>的时间复杂度和常数空间复杂度内完成计算。</p>
<p>例如，给定数组<code>[1,2,3,4]</code>，则返回数组<code>[24,12,8,6]</code></p>
<p>注：返回数组所占空间不在本题的空间复杂度的计算范围内。</p>
<a id="more"></a>
<h2 id="问题分析">问题分析</h2><p>按照常规的思维，最直接的计算方式是先对所有元素乘积，然后分别除以数组中的每个元素，其复杂度也在O(n)内。不幸的是，题目要求不能使用除法。然而我们可以从这个思路中尝试分析其它的解决方案。</p>
<p>首先，假设数组的n个元素分别为：a1, a2, a3, … an, 令P = a1 <em> a2 </em> a3 <em> … an,所以目标结果数组应为P/a1, P/a2, P/a3, … P/an。约掉分母可得：a2</em>a3<em>…an, a1</em>a3<em>…an, … a1</em>a2*…a(n-1).对结果数组的每一个元素的乘法进行分组可得如下形式：</p>
<p>(1) <em>* (a2</em>a3*…an)</p>
<p>(a1) <em>* (a3</em>a4*…an)</p>
<p>(a1<em>a2) </em> (a4<em>a5</em>…an)</p>
<p>(a1<em>a2</em>…a(n-2)) * (an)</p>
<p>(a1<em>a2</em>…a(n-1)) * (1)</p>
<p>以垂直方向看，左侧括号内部分是a1一直到a(n-1)的阶乘，而以垂直方向逆序来看，右侧括号内部分是an到a2的阶乘。 因此问题迎刃而解，可以用两个循环来迭代阶乘，也可以用一个循环分别从首尾迭代两组阶乘。</p>
<h2 id="代码">代码</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        // 两个迭代变量，t1从数组低位</span><br><span class="line">        // 向高位迭代；t2从数组高位</span><br><span class="line">        // 向低位迭代。</span><br><span class="line">        int t1(1), t2(1);</span><br><span class="line"></span><br><span class="line">        // 缓存数组的长度</span><br><span class="line">        int size(nums.size());</span><br><span class="line"></span><br><span class="line">        // 初始化返回数组的所有元素为 1</span><br><span class="line">        vector&lt;int&gt; result(size, 1);</span><br><span class="line"></span><br><span class="line">        // 做(数组长度-1)次数的迭代</span><br><span class="line">        for (int i(1); i &lt; size; ++i) &#123;</span><br><span class="line">            // 通过迭代来达到如下赋值</span><br><span class="line">            // result(i) &lt;- ProductOf(nums(0), nums(1) ... nums(i-1))</span><br><span class="line">            // 即返回数组的第i个元素的值等于输入数组的前i个元素的乘积。</span><br><span class="line">            t1 *= nums[i - 1];</span><br><span class="line">            result[i] *= t1;</span><br><span class="line"></span><br><span class="line">            // 在t1迭代计算的结果基础上，t2以反方向进行与t1完全类似的计算，</span><br><span class="line">            // 把计算结果累积乘积到输出数组上。</span><br><span class="line">            t2 *= nums[size - i];</span><br><span class="line">            result[size - 1 - i] *= t2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>给定一个有<code>n</code>个元素且<code>n</code>大于<code>1</code>的一维数组<code>nums</code>，计算并返回一个数组<code>output</code>，使其任一元素<code>output[i]</code>的值是数组<code>nums</code>除<code>nums[i]</code>外的其它所有元素的乘积。要求不能使用除法，且在<code>O(n)</code>的时间复杂度和常数空间复杂度内完成计算。</p>
<p>例如，给定数组<code>[1,2,3,4]</code>，则返回数组<code>[24,12,8,6]</code></p>
<p>注：返回数组所占空间不在本题的空间复杂度的计算范围内。</p>]]>
    
    </summary>
    
      <category term="Array" scheme="http://blog.liushuping.com/tags/Array/"/>
    
      <category term="LeetCode" scheme="http://blog.liushuping.com/categories/LeetCode/"/>
    
      <category term="Algorithm" scheme="http://blog.liushuping.com/categories/LeetCode/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[NFC SIM卡的尴尬]]></title>
    <link href="http://blog.liushuping.com/2015/07/22/NFC-SIM%E5%8D%A1%E7%9A%84%E5%B0%B4%E5%B0%AC/"/>
    <id>http://blog.liushuping.com/2015/07/22/NFC-SIM卡的尴尬/</id>
    <published>2015-07-22T15:50:39.000Z</published>
    <updated>2015-10-25T10:41:38.000Z</updated>
    <content type="html"><![CDATA[<p>近日NFC又一次出现在新闻中，如<em>今日头条</em>的<a href="http://toutiao.com/a4762553742/" target="_blank" rel="external">千万不要忽略了手机上NFC功能，你会后悔的</a>。我终于觉得有必要介绍一下自己几个月来NFC使用的体验了。</p>
<p>首先，NFC是一项重要的技术，在我们的日常生活中扮演着重要的作用。公交，地铁，饭卡等等很多近距离通信设备都是使用的NFC技术。</p>
<p>手机在我们的日常生活中同样扮演着越来越重要的作用，智能手机已成为大多数人时刻带在身上的设备，甚至包含上厕所的时间。因此，让手机具备NFC的功能也就是理所应该的了。在现阶段，具备NFC功能的手机还需要一张NFC SIM卡，这也是可以理解的。然而在使用了几个月的手机NFC功能后，其中的尴尬还是不少的。</p>
<a id="more"></a>
<h2 id="NFC标签">NFC标签</h2><p>听起来很酷炫的功能，但目前阶段看来，除了炫耀一下似乎没有什么其它务实的应用场景。然而，当把手机和钱包放在一起时，麻烦也便来了: 钱包里通常放各种银行卡，会员卡等等，或多或少的总有那么一两张卡有NFC功能。所以，当手机和钱包在一起时，手机立马会跳出对话框询问用什么程序访问当前NFC设备，并伴随着声音的提示。 然而多数时候我们并无此意，仅仅是把两者放在一起而已。什么？你问我为什么把手机和钱包放在一起？当两者变成人们寸步不离的个人物品时，放在一起的机会总是很多的。</p>
<h2 id="NFC乘坐公交地铁">NFC乘坐公交地铁</h2><p>此处下所述都是我在北京交通的体会，不代表其它城市的状态。先来一句猜测性的话阐述观点：北京的公交和地铁读卡设备在投入生产之前可能没有对非公交卡片之外的其它设备做足够的质量验收测试(仅代表个人猜测)。</p>
<p><strong>先说地铁</strong></p>
<p>几个月的使用体验结论是：地铁的读卡设备比公交上的读卡设备迟钝，且容易出错。当我以帅气的姿势在闸机上刷手机并期待吸引目光的时候，通常会有很大几率(大概三分之一吧)把自己陷入尴尬的境地：机器会无情地回以尖锐的错误声音，错误通常有以下几类：</p>
<ol>
<li>无效的卡片</li>
<li>错误，多张卡片</li>
<li>错误，0x12cf02…</li>
</ol>
<p>此刻只能尴尬地漫无目的地在手机上操作一番，然后重试。幸运的是通常重试后会成功，且地铁内有足够的空闲闸机及时间供我重试。</p>
<p><strong>再说公交</strong> </p>
<p>前面说了，地铁的读卡设备没有公交的读卡设备敏感，是不是说公交上就没问题了呢？恰恰相反，公交上容易造成多扣票款(在几个月的使用中，地铁没却发生过)，粗略估计有五分之一的概率发生吧。</p>
<p>这要从手机刷公交的“姿势”说起。不同于地铁闸机的刷卡处是一个倾斜的台面，公交的刷卡设备大多悬空且表面垂直于地面。因此，需要把公交卡贴近刷卡，这对有韧性的塑料卡来说不是难事。然而，用手机刷的体验就大不相同了。手机不具备韧性(什么？柔性屏？呵呵)，且手机有比较大的质量，比较大的体积(大屏手机变为主流), 还有手机卡在手机内部因此拉大了刷卡的距离。这些都要求手机刷公交要有一定的“姿势”，且要在人流拥挤，空间狭窄的公交车上，更要命的是后面的乘客还看着你并等着你，给你无形中造成了压力。好吧，在这些压力下，你的手在刷手机的时候抖了一下，或者是你觉得刷的“姿势”不对，微微地调节了一下。清脆的刷卡成功声音响起，然而在未来得及高兴前，你却听到了紧接着的第二声响起。这就是敏感的设备在你手抖的那一瞬间两次读取了你的卡，并扣取了你的钱。</p>
<p>第二天，面对公交拥挤的人群，狭小的空间，担心着手机掉落的可能，颤抖着双手刷下去了手机。</p>
<p>滴-滴。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>近日NFC又一次出现在新闻中，如<em>今日头条</em>的<a href="http://toutiao.com/a4762553742/">千万不要忽略了手机上NFC功能，你会后悔的</a>。我终于觉得有必要介绍一下自己几个月来NFC使用的体验了。</p>
<p>首先，NFC是一项重要的技术，在我们的日常生活中扮演着重要的作用。公交，地铁，饭卡等等很多近距离通信设备都是使用的NFC技术。</p>
<p>手机在我们的日常生活中同样扮演着越来越重要的作用，智能手机已成为大多数人时刻带在身上的设备，甚至包含上厕所的时间。因此，让手机具备NFC的功能也就是理所应该的了。在现阶段，具备NFC功能的手机还需要一张NFC SIM卡，这也是可以理解的。然而在使用了几个月的手机NFC功能后，其中的尴尬还是不少的。</p>]]>
    
    </summary>
    
      <category term="Mobile" scheme="http://blog.liushuping.com/tags/Mobile/"/>
    
      <category term="NFC" scheme="http://blog.liushuping.com/tags/NFC/"/>
    
      <category term="New Tech" scheme="http://blog.liushuping.com/categories/New-Tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode OJ 234 Palindrome Linked List]]></title>
    <link href="http://blog.liushuping.com/2015/07/22/LeetCode-OJ-234-Palindrome-Linked-List/"/>
    <id>http://blog.liushuping.com/2015/07/22/LeetCode-OJ-234-Palindrome-Linked-List/</id>
    <published>2015-07-22T14:35:42.000Z</published>
    <updated>2015-10-25T10:40:01.000Z</updated>
    <content type="html"><![CDATA[<p>在时间复杂度为O(n),空间复杂度为O(1)的范围内，判断一个给定的单向列表是否为<a href="https://en.wikipedia.org/wiki/Palindrome" target="_blank" rel="external">回文</a>。</p>
<h2 id="问题分析">问题分析</h2><p>O(n)时间复杂度要求对链表全遍历(即访问一次链全部元素)的次数应为固定常数次，不应随链表长度的变化而变化；O(1)的空间复杂度要求额外定义的变量应为常数个，而不应随链表长度的变化而变化。</p>
<p>而对于回文的判定，唯一的办法是依次以中间对称的方式对比左右每个元素的值。通常在做算法题，或者有良好软件工程的程序人员都会“潜在地”去保持一些良好的习惯，或遵守某些常见的约定。比如“判断某链表是否某某结构”，“某树形数据结构是否符合某某结构”等等问题，有良好习惯的程序员会尽量保持函数不修改要判断的数据结构。然后，诸如本题目之类则是对优秀程序员的一种“伤害”，因为在不修改数据结构的前提下，可能无法在要求的复杂度内完成任务。但是，出题者一点小小的改进，例如在题目中提及一下数据结构或内容允许被修改，则既可保持程序题目的趣味性，又避免了程序员对题目要求的种种猜测。</p>
<p>在明确了链表的结构可被修改的前提下，问题的解决方案便可很容易分析得出：主体思路是修改链表的前或后半部分，使其链表内节点指向相反方向，然后依次对比前半部分和后半部分链表各个节点。 因此关键点是如何逆序重组链表的一半？有很多方案，例如以下：</p>
<ol>
<li>方案一：第一遍循环定位出中间节点(注意偶数和奇数节点总数的细微差别)，然后以中间节点为起点(链表后半部分)或为终点(链表前半部分)逆序重组链表的一半。依次对比链表前后部分的各个节点。</li>
<li>方案二：定义快慢两个指针，分别对应移动2步和1步。当快指针结束遍历链表时，慢指针位于链表中间。然后逆序重组从慢指针至链表结尾的节点。依次对比链表前后部分的各个节点。</li>
</ol>
<a id="more"></a>
<p>以下示例代码采取了第二种方案.</p>
<h2 id="代码">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *t, *t1, *t2;</span><br><span class="line">        t1 = head;</span><br><span class="line">        t2 = head; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 快指针遍历整个链表后，</span></span><br><span class="line">        <span class="comment">// 慢指针停留在中间节点</span></span><br><span class="line">        <span class="keyword">while</span>(t2)&#123;</span><br><span class="line">            t2 = t2-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (t2) </span><br><span class="line">                t2 = t2-&gt;next;</span><br><span class="line">            t1 = t1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 以慢指针(中间节点)为开始</span></span><br><span class="line">        <span class="comment">// 逆序重组后续节点</span></span><br><span class="line">        <span class="comment">// t用来辅助交换指针</span></span><br><span class="line">        <span class="keyword">while</span>(t1) &#123;</span><br><span class="line">            t = t1;</span><br><span class="line">            t1 = t1-&gt;next;</span><br><span class="line">            t-&gt;next = t2;</span><br><span class="line">            t2 = t;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 重组完成后，t2指向后半部分链表</span></span><br><span class="line">        <span class="comment">// 的开始， 而重新置t1于原始链表</span></span><br><span class="line">        <span class="comment">// 的头部， 并开始比较各个节点</span></span><br><span class="line">        t1 = head;</span><br><span class="line">        <span class="keyword">while</span>(t2 &amp;&amp; t1) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t1-&gt;val != t2-&gt;val)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            t1 = t1-&gt;next;</span><br><span class="line">            t2 = t2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>在时间复杂度为O(n),空间复杂度为O(1)的范围内，判断一个给定的单向列表是否为<a href="https://en.wikipedia.org/wiki/Palindrome">回文</a>。</p>
<h2 id="问题分析">问题分析</h2><p>O(n)时间复杂度要求对链表全遍历(即访问一次链全部元素)的次数应为固定常数次，不应随链表长度的变化而变化；O(1)的空间复杂度要求额外定义的变量应为常数个，而不应随链表长度的变化而变化。</p>
<p>而对于回文的判定，唯一的办法是依次以中间对称的方式对比左右每个元素的值。通常在做算法题，或者有良好软件工程的程序人员都会“潜在地”去保持一些良好的习惯，或遵守某些常见的约定。比如“判断某链表是否某某结构”，“某树形数据结构是否符合某某结构”等等问题，有良好习惯的程序员会尽量保持函数不修改要判断的数据结构。然后，诸如本题目之类则是对优秀程序员的一种“伤害”，因为在不修改数据结构的前提下，可能无法在要求的复杂度内完成任务。但是，出题者一点小小的改进，例如在题目中提及一下数据结构或内容允许被修改，则既可保持程序题目的趣味性，又避免了程序员对题目要求的种种猜测。</p>
<p>在明确了链表的结构可被修改的前提下，问题的解决方案便可很容易分析得出：主体思路是修改链表的前或后半部分，使其链表内节点指向相反方向，然后依次对比前半部分和后半部分链表各个节点。 因此关键点是如何逆序重组链表的一半？有很多方案，例如以下：</p>
<ol>
<li>方案一：第一遍循环定位出中间节点(注意偶数和奇数节点总数的细微差别)，然后以中间节点为起点(链表后半部分)或为终点(链表前半部分)逆序重组链表的一半。依次对比链表前后部分的各个节点。</li>
<li>方案二：定义快慢两个指针，分别对应移动2步和1步。当快指针结束遍历链表时，慢指针位于链表中间。然后逆序重组从慢指针至链表结尾的节点。依次对比链表前后部分的各个节点。</li>
</ol>]]>
    
    </summary>
    
      <category term="Linked List" scheme="http://blog.liushuping.com/tags/Linked-List/"/>
    
      <category term="Two Pointers" scheme="http://blog.liushuping.com/tags/Two-Pointers/"/>
    
      <category term="LeetCode" scheme="http://blog.liushuping.com/categories/LeetCode/"/>
    
      <category term="Algorithm" scheme="http://blog.liushuping.com/categories/LeetCode/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[基于NodeJS的ASCII树形文本生成模块]]></title>
    <link href="http://blog.liushuping.com/2015/07/21/generate-ascii-tree-from-input-string-with-node/"/>
    <id>http://blog.liushuping.com/2015/07/21/generate-ascii-tree-from-input-string-with-node/</id>
    <published>2015-07-21T14:51:16.000Z</published>
    <updated>2015-10-25T10:38:56.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://blog.liushuping.com/ascii-tree/">Ascii-tree</a>是一个简单的NodeJS模块，用来对指定格式的输入文本输出树形结构的ASCII文本。指定格式的输入文本要求每一个节点都要以一定数量的引导字符开始，根节点以1个引导字符开始；子节点引导字符以此类推，如下列输入文本：<br><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="special">#</span>root node<span class="command">\r</span><span class="command">\n</span><span class="special">#</span><span class="special">#</span>node1<span class="command">\r</span><span class="command">\n</span><span class="special">#</span><span class="special">#</span><span class="special">#</span><span class="command">\r</span><span class="command">\nnode</span>1<span class="command">\r</span><span class="command">\n</span><span class="special">#</span><span class="special">#</span>node2</span><br></pre></td></tr></table></figure></p>
<p>代表的是这样的一段ASCII树形文本：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root <span class="keyword">node</span><span class="identifier"></span><br><span class="line"></span><span class="title">├─ node1</span></span><br><span class="line">│  └─ node11</span><br><span class="line">└─ node2</span><br></pre></td></tr></table></figure></p>
<p><a href="http://blog.liushuping.com/ascii-tree/">Ascii-tree</a>就是这样的一个基于Node的ASCII Tree生成模块。链接：<a href="http://blog.liushuping.com/ascii-tree/">http://blog.liushuping.com/ascii-tree/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://blog.liushuping.com/ascii-tree/">Ascii-tree</a>是一个简单的NodeJS模块，用来对指定格式的输入文本输出树形结构的ASCII文本。指定格式的输入文本要求每一个节点都要以一定数量的引导字符开始，根]]>
    </summary>
    
      <category term="ASCII" scheme="http://blog.liushuping.com/tags/ASCII/"/>
    
      <category term="Node" scheme="http://blog.liushuping.com/tags/Node/"/>
    
      <category term="Tree" scheme="http://blog.liushuping.com/tags/Tree/"/>
    
      <category term="Ascii-tree" scheme="http://blog.liushuping.com/categories/Ascii-tree/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在Ubuntu15上用squid3部署HTTP代理]]></title>
    <link href="http://blog.liushuping.com/2015/07/21/setup-HTTP-proxy-server-with-squid3/"/>
    <id>http://blog.liushuping.com/2015/07/21/setup-HTTP-proxy-server-with-squid3/</id>
    <published>2015-07-21T13:06:59.000Z</published>
    <updated>2015-10-25T10:42:14.000Z</updated>
    <content type="html"><![CDATA[<p>Squid3 是一个简单易用、功能强大的HTTP代理软件，本文简要介绍了在Ubuntu 15.04上安装squid3以及基本配置的步骤。</p>
<h2 id="安装">安装</h2><p>通过命令<code>$ sudo apt-get install squid3</code>可以很方便地安装squid3,如下图：<br><img src="http://78rehp.com1.z0.glb.clouddn.com/blog/squid3-install-1.png" alt="squid 3安装"></p>
<a id="more"></a>
<h2 id="检查安装">检查安装</h2><p>通过<code>$ whereis squid3</code>命令来确认一下squid3是否已经安装正确：<br><img src="http://78rehp.com1.z0.glb.clouddn.com/blog/squid3-whereis.png" alt="whereis squid3"><br>正确安装后的squid3应该出现路径<code>/etc/squid3</code>。如果没有发现可以尝试重启系统后重新检查一下。</p>
<h2 id="代理配置">代理配置</h2><p>squid3提供了丰富的配置项，<code>/etc/squid3/squid.conf</code>文件内注释有每一个选项的作用。</p>
<h3 id="配置端口号">配置端口号</h3><p>squid3默认接受3128端口号，可以通过在文件<code>squid.conf</code>中添加<code>http_port &lt;port&gt;</code>来改变这个端口号:<br><img src="http://78rehp.com1.z0.glb.clouddn.com/blog/squid-edit-conf-2.png" alt="squid3 http_port"></p>
<h3 id="配置信任的客户端">配置信任的客户端</h3><p>在未配置信任客户端的情况下，squid3是不接受任何连接的。最简单的方案是接受任何客户端的请求，这可以通过添加<code>http_access allow all</code>选项来实现：<br><img src="http://78rehp.com1.z0.glb.clouddn.com/blog/squid-edit-conf-3.png" alt="squid3 http_access allow all"></p>
<h3 id="基本的访问控制配置">基本的访问控制配置</h3><p><code>http_access allow all</code>规则允许所有连接的客户端访问，不能很好地控制用户的访问权限，也存在潜在的安全问题。一种方案是通过允许一定区段的IP地址访问，这可以通过在配置文件中定义一个值为一段IP的acl的变量，并通过<code>http_access</code>选项来对其授权：<br><img src="http://78rehp.com1.z0.glb.clouddn.com/blog/squid-edit-conf-4.png" alt="squid3 acl ip group"></p>
<p>另一种更加可靠的识别用户的方式是通过MAC地址来认证，示例命令如下：<br><img src="http://78rehp.com1.z0.glb.clouddn.com/blog/squid-edit-conf-5.png" alt="squid3 acl arp"></p>
<h2 id="squid3的启动与关闭">squid3的启动与关闭</h2><p>squid3的启动，关闭，重新启动的命令：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>sudo service squid3 start</span><br><span class="line"><span class="variable">$ </span>sudo service squid3 stop</span><br><span class="line"><span class="variable">$ </span>sudo service squid3 restart</span><br></pre></td></tr></table></figure></p>
<h2 id="参考引用">参考引用</h2><p>更多的squid3配置选项，及完整的说明文档，请参考：<a href="https://help.ubuntu.com/lts/serverguide/squid.html" target="_blank" rel="external">https://help.ubuntu.com/lts/serverguide/squid.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Squid3 是一个简单易用、功能强大的HTTP代理软件，本文简要介绍了在Ubuntu 15.04上安装squid3以及基本配置的步骤。</p>
<h2 id="安装">安装</h2><p>通过命令<code>$ sudo apt-get install squid3</code>可以很方便地安装squid3,如下图：<br><img src="http://78rehp.com1.z0.glb.clouddn.com/blog/squid3-install-1.png" alt="squid 3安装"></p>]]>
    
    </summary>
    
      <category term="HTTP" scheme="http://blog.liushuping.com/tags/HTTP/"/>
    
      <category term="Proxy" scheme="http://blog.liushuping.com/tags/Proxy/"/>
    
      <category term="Squid3" scheme="http://blog.liushuping.com/tags/Squid3/"/>
    
      <category term="Ubuntu" scheme="http://blog.liushuping.com/tags/Ubuntu/"/>
    
      <category term="HTTP" scheme="http://blog.liushuping.com/categories/HTTP/"/>
    
      <category term="Proxy" scheme="http://blog.liushuping.com/categories/HTTP/Proxy/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode OJ 235 Lowest Common Ancestor of a Binary Search Tree]]></title>
    <link href="http://blog.liushuping.com/2015/07/17/LeetCode-OJ-235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree/"/>
    <id>http://blog.liushuping.com/2015/07/17/LeetCode-OJ-235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree/</id>
    <published>2015-07-17T15:24:07.000Z</published>
    <updated>2015-10-25T10:40:43.000Z</updated>
    <content type="html"><![CDATA[<p>对于给定的一颗二叉查找树和其中的两个节点，找出它们的最低公共祖先（LCA）</p>
<p>根据<a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor" target="_blank" rel="external">Wikipedia对LCA的定义</a>：</p>
<blockquote>
<p>The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).</p>
</blockquote>
<p>也就说：最低公共祖先指的是在一颗树中，节点v和节点w的最低的公共节点。这里允许节点可以是它本身的祖先。</p>
<p>例如，在下面的二叉查找树中，节点2和8的最低公共祖先是6。而节点2和4的最低公共祖先是2（节点可以是它本身的祖先）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">        ______6_____</span><br><span class="line">       /                    \</span><br><span class="line">  ___2__            ___8__</span><br><span class="line"> /          \          /          \</span><br><span class="line"><span class="number">0</span>         _4_      <span class="number">7</span>           <span class="number">9</span></span><br><span class="line">          /     \</span><br><span class="line">         <span class="number">3</span>      <span class="number">5</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="问题分析">问题分析</h2><p>由于题目限定查找的范围是一颗二叉查找树，所以可以利用树的左侧值比右侧值小的这个特性来快速查找目标的最低公共祖先。具体可以分五步：</p>
<ol>
<li>若目标节点之一等同于root节点，则root为所求目标。</li>
<li>若两个目标节点重合，则目标节点为所求目标。</li>
<li>在不符合上述两种情况下，若两个目标节点的值都大于根节点值，则递归遍历右子树获得结果。</li>
<li>在不符合上述三种情况下，若两个目标节点的值都小于根节点值，则递归遍历左子树获得结果。</li>
<li>最后一种情况表明两个目标节点分布在根节点的左右两侧，因此根节点为最终结果。</li>
</ol>
<h2 id="代码">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (p == q) <span class="keyword">return</span> p;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (p-&gt;val &gt; root-&gt;val &amp;&amp; q-&gt;val &gt; root-&gt;val) </span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> (p-&gt;val &lt; root-&gt;val &amp;&amp; q-&gt;val &lt; root-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>对于给定的一颗二叉查找树和其中的两个节点，找出它们的最低公共祖先（LCA）</p>
<p>根据<a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor">Wikipedia对LCA的定义</a>：</p>
<blockquote>
<p>The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).</p>
</blockquote>
<p>也就说：最低公共祖先指的是在一颗树中，节点v和节点w的最低的公共节点。这里允许节点可以是它本身的祖先。</p>
<p>例如，在下面的二叉查找树中，节点2和8的最低公共祖先是6。而节点2和4的最低公共祖先是2（节点可以是它本身的祖先）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">        ______6_____</span><br><span class="line">       /                    \</span><br><span class="line">  ___2__            ___8__</span><br><span class="line"> /          \          /          \</span><br><span class="line"><span class="number">0</span>         _4_      <span class="number">7</span>           <span class="number">9</span></span><br><span class="line">          /     \</span><br><span class="line">         <span class="number">3</span>      <span class="number">5</span></span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="Tree" scheme="http://blog.liushuping.com/tags/Tree/"/>
    
      <category term="LeetCode" scheme="http://blog.liushuping.com/categories/LeetCode/"/>
    
      <category term="Algorithm" scheme="http://blog.liushuping.com/categories/LeetCode/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode OJ 236 Lowest Common Ancestor of a Binary Tree]]></title>
    <link href="http://blog.liushuping.com/2015/07/15/LeetCode-OJ-236-Lowest-Common-Ancestor-of-a-Binary-Tree/"/>
    <id>http://blog.liushuping.com/2015/07/15/LeetCode-OJ-236-Lowest-Common-Ancestor-of-a-Binary-Tree/</id>
    <published>2015-07-15T14:45:07.000Z</published>
    <updated>2015-10-25T10:40:56.000Z</updated>
    <content type="html"><![CDATA[<p>对于给定的一颗二叉树和其中的两个节点，找出它们的最低公共祖先（LCA）</p>
<p>根据<a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor" target="_blank" rel="external">Wikipedia对LCA的定义</a>：</p>
<blockquote>
<p>The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).</p>
</blockquote>
<p>也就说：最低公共祖先指的是在一颗树中，节点v和节点w的最低的公共节点。这里允许节点可以是它本身的祖先。</p>
<p>例如，在下面的树中，节点5和1的最低公共祖先是3。而节点4和5的最低公共祖先是5（节点可以是它本身的祖先）。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="cpp">     _______3______</span><br><span class="line">    /              \</span><br><span class="line"> ___5__          ___1__</span><br><span class="line">/      \        /      \</span><br><span class="line"><span class="number">6</span>      _2       <span class="number">0</span>       <span class="number">8</span></span><br><span class="line">      /  \</span><br><span class="line">      <span class="number">7</span>   <span class="number">4</span></span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="问题分析">问题分析</h2><p>该问题可以分为两个步骤来分析：1.遍历整棵树直到两个目标节点全部被发现； 2.从第二个节点被找到时刻开始回溯节点，一直到两个目标节点的第一个共同祖先为止。所以，问题的全部难点都集中在第二步中。</p>
<p>难点一：如何回溯？<br>事实上，对于递归函数，函数的每一次返回(return)都是一次弹“栈”的过程，也就是一次回溯的过程。</p>
<p>难点二：在回溯过程中，如何判断某个节点是两个目标节点的共同祖先？<br>在回溯到某一个节点时，计算该节点及所有子节点包含目标节点的个数，一旦达到两个则表明共同祖先节点找到。</p>
<p>计算过程：如果当前节点是两个目标节点中一个，则该节点值为1，用同样的道理计算该节点左右子树的值，最后加和即是该节点为根的树所包含目标节点的个数。</p>
<p>特殊情况：如果两个目标节点是同一个节点，那么它就是要求的最终节点。</p>
<h2 id="代码">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 存储最低公共祖先结果</span></span><br><span class="line">    TreeNode* result;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录在遍历树的过程中已经发现的目标节点个数</span></span><br><span class="line">    <span class="comment">// 当count == 2时，全部节点找到，停止遍历，</span></span><br><span class="line">    <span class="comment">// 开始回溯。计算回溯路径上每一个节点为根</span></span><br><span class="line">    <span class="comment">// 的子树所包含目标节点的个数，一旦达到2，则</span></span><br><span class="line">    <span class="comment">// 表明最低公共祖先找到。</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        tranverse(root, p, q);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">tranverse</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">	<span class="comment">// 标识当前节点是否是目标节点之一</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">mark</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (root == p) &#123;</span><br><span class="line">            <span class="comment">// 是目标节点之一</span></span><br><span class="line">            mark++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (root == q) &#123;</span><br><span class="line">            <span class="comment">// 是目标节点，且两个目标相同</span></span><br><span class="line">            mark++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (mark &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 两个目标全部找到，标识LCA</span></span><br><span class="line">            <span class="keyword">if</span> (result == <span class="literal">NULL</span>) result = root;</span><br><span class="line">            <span class="keyword">return</span> mark;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 继续遍历左子树</span></span><br><span class="line">        mark += tranverse(root-&gt;left, p, q);</span><br><span class="line">        <span class="keyword">if</span> (mark &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (result == <span class="literal">NULL</span>) result = root;</span><br><span class="line">            <span class="keyword">return</span> mark;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">	<span class="comment">// 继续遍历右子树</span></span><br><span class="line">        mark += tranverse(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">if</span> (mark &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (result == <span class="literal">NULL</span>) result = root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mark;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>对于给定的一颗二叉树和其中的两个节点，找出它们的最低公共祖先（LCA）</p>
<p>根据<a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor">Wikipedia对LCA的定义</a>：</p>
<blockquote>
<p>The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).</p>
</blockquote>
<p>也就说：最低公共祖先指的是在一颗树中，节点v和节点w的最低的公共节点。这里允许节点可以是它本身的祖先。</p>
<p>例如，在下面的树中，节点5和1的最低公共祖先是3。而节点4和5的最低公共祖先是5（节点可以是它本身的祖先）。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="cpp">     _______3______</span><br><span class="line">    /              \</span><br><span class="line"> ___5__          ___1__</span><br><span class="line">/      \        /      \</span><br><span class="line"><span class="number">6</span>      _2       <span class="number">0</span>       <span class="number">8</span></span><br><span class="line">      /  \</span><br><span class="line">      <span class="number">7</span>   <span class="number">4</span></span></span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="Tree" scheme="http://blog.liushuping.com/tags/Tree/"/>
    
      <category term="LeetCode" scheme="http://blog.liushuping.com/categories/LeetCode/"/>
    
      <category term="Algorithm" scheme="http://blog.liushuping.com/categories/LeetCode/Algorithm/"/>
    
  </entry>
  
</feed>
