<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Shuping LIU]]></title>
  <subtitle><![CDATA[A JavaScript and C# developer]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://blog.liushuping.com/"/>
  <updated>2016-01-02T12:34:26.000Z</updated>
  <id>http://blog.liushuping.com/</id>
  
  <author>
    <name><![CDATA[Shuping LIU]]></name>
    <email><![CDATA[lsp.lhh@gmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[nanopi2系统配置]]></title>
    <link href="http://blog.liushuping.com/2016/01/02/nanopi2%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/"/>
    <id>http://blog.liushuping.com/2016/01/02/nanopi2系统配置/</id>
    <published>2016-01-02T03:58:04.000Z</published>
    <updated>2016-01-02T12:34:26.000Z</updated>
    <content type="html"><![CDATA[<p>本文介绍了在nanopi2上安装Debian系统的简要步骤以及安装后的必要配置。</p>
<h1 id="烧录Debian系统">烧录Debian系统</h1><p><a href="http://wiki.friendlyarm.com/wiki/index.php/NanoPi_2/zh" target="_blank" rel="external">Nanopi2 wiki</a>上有对如何安装系统的详细介绍，这里以在Windows系统上安装Debian系统到SD/TF卡为例（安装Android请参考<a href="http://wiki.friendlyarm.com/wiki/index.php/NanoPi_2/zh" target="_blank" rel="external">wiki</a>)</p>
<ul>
<li>首先到<a href="http://wiki.friendlyarm.com/wiki/nanopi2/download/" target="_blank" rel="external">http://wiki.friendlyarm.com/wiki/nanopi2/download/</a> 下载需要的固件例如<code>nanopi2-debian-sd4g.img.zip</code>以及烧写工具<code>win32diskimager.rar</code></li>
<li>下载完成后运行<code>win32diskimager.exe</code>，选取下载的<code>Debian</code>固件，并指定正确的SD/TF卡盘符，然后烧写即可。</li>
</ul>
<p>写入完成后，在Windows上看到的卡容量会是64M。不必担心，这是因为64M是Windows能识别Boot分区，而其它分区是Linux分区，Windows并不能识别。</p>
<p>把TF卡插入Nanopi2的卡位1（靠近电源输入的一端），接入电源即可启动Nanopi2了。</p>
<a id="more"></a>
<h1 id="扩展磁盘分区">扩展磁盘分区</h1><p>通过<code>diskimager</code>写的SD／TF卡是不能很好地直接使用的，此时的系统只占用了大约3GB的空间，并没有足够的空间来安装必要的软件，因此无法用来做开发。在使用之前需要扩展分区空间到整个SD/TF卡空间。</p>
<p>网上介绍的方法是把SD／TF卡接入到一个Linux系统的电脑，并执行以下命令：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo umount <span class="regexp">/dev/</span>sdx</span><br><span class="line">sudo parted <span class="regexp">/dev/</span>sdx unit % resizepart <span class="number">2</span> <span class="number">100</span> unit MB <span class="keyword">print</span></span><br><span class="line">sudo resize2fs -f <span class="regexp">/dev/</span>sdx2</span><br></pre></td></tr></table></figure></p>
<p>其中<code>sdx</code>的<code>x</code>要替换成实际的挂载点，通常是<code>sdb</code>。然而多次尝试后，系统提示各种错误。因此，我尝试了图形化的分区工具<code>gparted</code>，并正确地扩展了分区空间。<br>首先在一台Linux电脑上安装<code>gparted</code><br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> install gparted</span><br></pre></td></tr></table></figure></p>
<p>然后运行<code>gparted</code>图形化分区程序，选取接入的SD／TF卡，会看到有两个分区，选择第二个分区，然后选择卸载，检查。执行操作，分区扩展就完成了。</p>
<h1 id="配置无线连接">配置无线连接</h1><p>Nanopi2 wiki上有无线配置的详细步骤：<a href="http://wiki.friendlyarm.com/wiki/index.php/NanoPi_2/zh" target="_blank" rel="external">http://wiki.friendlyarm.com/wiki/index.php/NanoPi_2/zh</a> 这儿做简要重复：</p>
<ol>
<li>查看WiFi的网络接口：<code>ifconfig -a</code>，以<code>wlan</code>开头的就是<code>wifi</code>，通常是<code>wlan0</code></li>
<li>创建一个以WiFi接口命名的文件<code>vi /etc/network/interfaces.d/wlan0</code>,这儿用的是<code>vi</code>编辑器</li>
<li><p>在<code>wlan0</code>文件中输入以下内容：</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">auto wlan0</span><br><span class="line">iface wlan0 <span class="keyword">inet</span> dhcp</span><br><span class="line">wpa-driver nl80211</span><br><span class="line">wpa-ssid <span class="variable">&lt;YourWiFiESSID&gt;</span></span><br><span class="line">wpa-ap-scan <span class="number">1</span></span><br><span class="line">wpa-psk <span class="variable">&lt;YourWiFiPassword&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>完成编辑后，reboot后即可自动连接无线。</p>
</li>
</ol>
<h1 id="修改root密码">修改root密码</h1><p>默认情况下，<code>root</code>密码是<code>fa</code>，配置好WiFi连接后，系统便接入了互联网，因此为了安全，建议修改<code>root</code>密码：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sudo</span> passwd</span><br></pre></td></tr></table></figure></p>
<h1 id="SSH连接">SSH连接</h1><p>配置好无线连接后，可以通过SSH连接的方式连接到nanopi2。需要知道无线分配给nanopi2的IP地址，有两种方式：</p>
<ul>
<li>通过HDMI把nanopi2连接到显示器或电视，然后执行命令<code>ifconfig -a</code>来查看</li>
<li>或者在一台属于同一个无线网络的电脑执行命令<code>arp -a</code>来查看所有IP地址。</li>
</ul>
<p>获取IP地址后通过<code>ssh root@&lt;ip address&gt;</code>即可连接。</p>
<h1 id="修改时区及同步时间">修改时区及同步时间</h1><h2 id="修改时区">修改时区</h2><p>初次装的系统并没有设置时区，因此时间是UTC的方式显示。可以通过下面的命令来修改时区：<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sudo</span> dpkg-reconfigure tzdata</span><br></pre></td></tr></table></figure></p>
<p>命令执行后，系统会以图形化的方式引导修改时区。</p>
<h2 id="网络同步时间">网络同步时间</h2><p>由于nanopi2本身并不自带时钟电池，断电后时间设置就会丢失。因此通过NTP服务器动态获取时间的方式可以很好地确保时间的正确性。国内常用的NTP服务器有：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ntp<span class="class">.sjtu</span><span class="class">.edu</span><span class="class">.cn</span> <span class="number">202.120</span>.<span class="number">2.101</span> (上海交通大学网络中心NTP服务器地址）</span><br><span class="line">s1a<span class="class">.time</span><span class="class">.edu</span><span class="class">.cn</span>	北京邮电大学</span><br><span class="line">s1b<span class="class">.time</span><span class="class">.edu</span><span class="class">.cn</span>	清华大学</span><br><span class="line">s1c<span class="class">.time</span><span class="class">.edu</span><span class="class">.cn</span>	北京大学</span><br><span class="line">s1d<span class="class">.time</span><span class="class">.edu</span><span class="class">.cn</span>	东南大学</span><br><span class="line">s1e<span class="class">.time</span><span class="class">.edu</span><span class="class">.cn</span>	清华大学</span><br><span class="line">s2a<span class="class">.time</span><span class="class">.edu</span><span class="class">.cn</span>	清华大学</span><br><span class="line">s2b<span class="class">.time</span><span class="class">.edu</span><span class="class">.cn</span>	清华大学</span><br><span class="line">s2c<span class="class">.time</span><span class="class">.edu</span><span class="class">.cn</span>	北京邮电大学</span><br><span class="line">s2d<span class="class">.time</span><span class="class">.edu</span><span class="class">.cn</span>	西南地区网络中心</span><br><span class="line">s2e<span class="class">.time</span><span class="class">.edu</span><span class="class">.cn</span>	西北地区网络中心</span><br><span class="line">s2f<span class="class">.time</span><span class="class">.edu</span><span class="class">.cn</span>	东北地区网络中心</span><br><span class="line">s2g<span class="class">.time</span><span class="class">.edu</span><span class="class">.cn</span>	华东南地区网络中心</span><br><span class="line">s2h<span class="class">.time</span><span class="class">.edu</span><span class="class">.cn</span>	四川大学网络管理中心</span><br><span class="line">s2j<span class="class">.time</span><span class="class">.edu</span><span class="class">.cn</span>	大连理工大学网络中心</span><br><span class="line">s2k<span class="class">.time</span><span class="class">.edu</span><span class="class">.cn</span> CERNET桂林主节点</span><br><span class="line">s2m<span class="class">.time</span><span class="class">.edu</span><span class="class">.cn</span> 北京大学</span><br></pre></td></tr></table></figure></p>
<p>要通过NTP服务器同步时间，需要用到<code>ntpdate包</code>，通过下面命令安装:<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sudo</span> apt-get <span class="keyword">update</span> ntpdate</span><br></pre></td></tr></table></figure></p>
<p>安装后，通过<code>ntpdate</code>命令指定一个NTP服务器就可以同步时间了:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntpdate ntp<span class="class">.sjtu</span><span class="class">.edu</span><span class="class">.cn</span></span><br></pre></td></tr></table></figure></p>
<p>如果需要定期同步时间，可以通过<code>crontab -e</code>命令并在打开的文件中添加类似下面的一行：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">*</span>/30 <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> /usr/sbin/ntpdate time.cuit.edu.cn</span><br></pre></td></tr></table></figure></p>
<p>表示系统每30分钟同步一次时间。</p>
<h1 id="修改hostname">修改hostname</h1><p>nanopi2设备默认的名字是<code>nanopi2</code>，例如用ssh以root身份登录系统后的显示如下：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root<span class="variable">@nanopi2</span><span class="symbol">:~</span><span class="comment">#</span></span><br></pre></td></tr></table></figure></p>
<p>可以通过修改<code>/etc/hostname</code>文件内容来修改设备名字。<br>此外，在<code>apt-get install</code>命令安装包时，系统会提示类似<code>cannot resolve hostname nanopi2</code>之类的消息，可以通过修改<code>/etc/host</code>文件，在其中加入一条<code>nanopi2</code>(或是修改后的hostname)记录来解决，例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">27.0</span><span class="number">.0</span><span class="number">.1</span>       localhost</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>      nanopi2</span><br><span class="line">::<span class="number">1</span>            localhost ip6-localhost ip6-loopback</span><br><span class="line">ff02::<span class="number">1</span>        ip6-allnodes</span><br><span class="line">ff02::<span class="number">2</span>        ip6-allrouters</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文介绍了在nanopi2上安装Debian系统的简要步骤以及安装后的必要配置。</p>
<h1 id="烧录Debian系统">烧录Debian系统</h1><p><a href="http://wiki.friendlyarm.com/wiki/index.php/NanoPi_2/zh">Nanopi2 wiki</a>上有对如何安装系统的详细介绍，这里以在Windows系统上安装Debian系统到SD/TF卡为例（安装Android请参考<a href="http://wiki.friendlyarm.com/wiki/index.php/NanoPi_2/zh">wiki</a>)</p>
<ul>
<li>首先到<a href="http://wiki.friendlyarm.com/wiki/nanopi2/download/">http://wiki.friendlyarm.com/wiki/nanopi2/download/</a> 下载需要的固件例如<code>nanopi2-debian-sd4g.img.zip</code>以及烧写工具<code>win32diskimager.rar</code></li>
<li>下载完成后运行<code>win32diskimager.exe</code>，选取下载的<code>Debian</code>固件，并指定正确的SD/TF卡盘符，然后烧写即可。</li>
</ul>
<p>写入完成后，在Windows上看到的卡容量会是64M。不必担心，这是因为64M是Windows能识别Boot分区，而其它分区是Linux分区，Windows并不能识别。</p>
<p>把TF卡插入Nanopi2的卡位1（靠近电源输入的一端），接入电源即可启动Nanopi2了。</p>]]>
    
    </summary>
    
      <category term="nanopi2" scheme="http://blog.liushuping.com/tags/nanopi2/"/>
    
      <category term="nanopi2" scheme="http://blog.liushuping.com/categories/nanopi2/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++算法笔记－常用头文件]]></title>
    <link href="http://blog.liushuping.com/2015/11/09/C-%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%EF%BC%8D%E5%B8%B8%E7%94%A8%E5%A4%B4%E6%96%87%E4%BB%B6/"/>
    <id>http://blog.liushuping.com/2015/11/09/C-算法笔记－常用头文件/</id>
    <published>2015-11-09T13:53:43.000Z</published>
    <updated>2015-11-14T15:16:58.000Z</updated>
    <content type="html"><![CDATA[<p>C＋+有非常非常多的库文件，很多常见的功能都可在其中找到了解常用的库文件可以让我们清楚地知道有哪些系统已有功能可以使用，有哪些功能是我们需要实现的。本文列出了算法程序常用库的头文件。</p>
<a id="more"></a>
<h1 id="输入输出">输入输出</h1><table>
<thead>
<tr>
<th>头文件</th>
<th>主要功能</th>
<th>主要的类及函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>iostream</td>
<td>标准流输入输出对象</td>
<td>cin, cout, cerr, clog</td>
</tr>
<tr>
<td>cstdio或stdio.h</td>
<td>C语言的输入输出函数库</td>
<td>printf, scanf, fprintf, fscanf, fopen以及fclose等</td>
</tr>
<tr>
<td>iomanip</td>
<td>包含了一系列输入输出格式化的功能</td>
<td>setiosflags, setbase, setfill, setw, get_money, put_money, get_time, put_time等</td>
</tr>
<tr>
<td>ios</td>
<td>包含了输入输出的基类及相关函数</td>
<td>ios, ios_base, dec, hex, oct, fixed, left, right, uppercase等</td>
</tr>
<tr>
<td>istream</td>
<td>包含了标准输入和结合了输入输出相关的功能</td>
<td>istream, iostream</td>
</tr>
<tr>
<td>ostream</td>
<td>包含了标准输出和结合了输入输出相关的功能</td>
<td>ostream, endl, ends, flush等。</td>
</tr>
<tr>
<td>sstream</td>
<td>包含了以流操作符方式操作字符串的相关功能</td>
<td>istringstream, ostringstream, stringstream, stringbuf等。</td>
</tr>
</tbody>
</table>
<h1 id="数值">数值</h1><table>
<thead>
<tr>
<th>头文件</th>
<th>主要功能</th>
<th>主要的类及函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>limits</td>
<td>包含了所有数值的边界值</td>
<td>numeric_limits</td>
</tr>
<tr>
<td>climits或limits.h</td>
<td>一系列极值相关的宏</td>
<td>INT_MIN, INT_MAX, LONG_MIN, LONG_MAX等。</td>
</tr>
<tr>
<td>numeric</td>
<td>包含了对数列元素的一些函数</td>
<td>accumulate, adjacent_difference, inner_product, partial_sum和iota</td>
</tr>
<tr>
<td>random</td>
<td>包含了随机数产生的相关功能</td>
<td>random_device等非常多的随机数相关功能</td>
</tr>
</tbody>
</table>
<h1 id="数学计算">数学计算</h1><table>
<thead>
<tr>
<th>头文件</th>
<th>主要功能</th>
<th>主要的类及函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>cmath或math.h</td>
<td>C语言的数学函数和宏的库，有三角函数，指数函数，比较的宏等。</td>
<td>sin, cos, exp, pow, sqrt, ceil, floor, nextafter等非常多的数学函数</td>
</tr>
<tr>
<td>complex</td>
<td>复数运算相关的功能</td>
<td>real, imag以及各数学函数的复数版重载</td>
</tr>
<tr>
<td>ratio</td>
<td>分数计算相关功能</td>
<td>ratio, ratio_add, ratio_substract, ratio_multiply, ratio_divide, ratio_equal, ratio_less等</td>
</tr>
</tbody>
</table>
<h1 id="字符串操作">字符串操作</h1><table>
<thead>
<tr>
<th>头文件</th>
<th>主要功能</th>
<th>主要的类及函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>string</td>
<td>字符串转换的相关功能</td>
<td>string, to_string等</td>
</tr>
<tr>
<td>regex</td>
<td>正则表达式</td>
<td>regex_match, regex_search, regex_replace, basic_regex, match_results, sub_match及reg等</td>
</tr>
</tbody>
</table>
<h1 id="内存操作">内存操作</h1><table>
<thead>
<tr>
<th>头文件</th>
<th>主要功能</th>
<th>主要的类及函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>memory</td>
<td>动态内存管理的相关功能</td>
<td>auto_ptr, shared_ptr, weak_ptr, make_shared等</td>
</tr>
<tr>
<td>new</td>
<td>重载了new、delete等动态内存操作符</td>
<td>operator new, operator new[], operator delete, operator delete[], set_new_handler, get_new_handler等</td>
</tr>
<tr>
<td>cstring或string.h</td>
<td>操作C类型的字符串或数组的功能</td>
<td>memcpy, memmove, strcpy, strncpy, memcmp, memset, strlen, size_t, strstr等</td>
</tr>
</tbody>
</table>
<h1 id="数据结构">数据结构</h1><table>
<thead>
<tr>
<th>头文件</th>
<th>主要功能</th>
<th>主要的类</th>
</tr>
</thead>
<tbody>
<tr>
<td>vector</td>
<td>C++中使用频率最高、可以动态改变大小的类似数组的数据结构</td>
<td>vector    </td>
</tr>
<tr>
<td>set</td>
<td>集合相关的数据结构</td>
<td>set和multiset</td>
</tr>
<tr>
<td>unordered_map</td>
<td>跟无序映射相关的功能</td>
<td>unordered_map和unordered_multimap</td>
</tr>
<tr>
<td>map</td>
<td>跟有序映射相关的功能</td>
<td>map和multimap</td>
</tr>
<tr>
<td>queue</td>
<td>FIFO队列和优先队列</td>
<td>queue和priority_queue</td>
</tr>
<tr>
<td>stack</td>
<td>栈</td>
<td>stack</td>
</tr>
<tr>
<td>array</td>
<td>固定长度数组类array，因此它的灵活性比vector差一些</td>
<td>array</td>
</tr>
<tr>
<td>list</td>
<td>具有常数时间复杂度的任意未知元素的插入删除操作，以及支持正反方向遍历操作的list</td>
<td>list</td>
</tr>
<tr>
<td>forward_list</td>
<td>前向链表</td>
<td>forward_list, begin, end</td>
</tr>
<tr>
<td>deque</td>
<td>可以从头尾分别访问的队列</td>
<td>deque</td>
</tr>
<tr>
<td>tuple</td>
<td>元组的相关功能</td>
<td>tuple, tuple_size, make_tuple, tuple_cat, get等</td>
</tr>
</tbody>
</table>
<h1 id="算法">算法</h1><table>
<thead>
<tr>
<th>头文件</th>
<th>主要功能</th>
<th>主要的类及函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>algorithm</td>
<td>来自于STL的算法库，有排序、二分搜索、归并、最值、分区、查找以及数列的操作等</td>
<td>all_of, any_of, none_of, for_each, count, count_if, search, search_n, find, find_if, copy, swap, reverse, sort, lower_bound, make_heap等非常多的算法相关功能</td>
</tr>
<tr>
<td>iterator</td>
<td>迭代器相关的功能</td>
<td>begin, end, prev, next, advance, distance, iterator, istream_iterator, ostream_iterator等</td>
</tr>
</tbody>
</table>
<h1 id="时间">时间</h1><table>
<thead>
<tr>
<th>头文件</th>
<th>主要功能</th>
<th>主要的类及函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>chrono</td>
<td>处理时刻、时间以及系统无力时间等</td>
<td>duration, time_point, system_clock, steady_clock, high_resolution_clock, duration_cast, time_point_cast, duration_values等</td>
</tr>
<tr>
<td>ctime或time.h</td>
<td>C语言的时间相关功能</td>
<td>clock, difftime, time, ctime, clock_t, size_t, time_t等</td>
</tr>
</tbody>
</table>
<h1 id="位操作">位操作</h1><table>
<thead>
<tr>
<th>头文件</th>
<th>主要功能</th>
<th>主要的类及函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>bitset</td>
<td>比特位的集合，适合进行位数超出最大整数的位操作</td>
<td>bitset</td>
</tr>
</tbody>
</table>
<h1 id="函数对象">函数对象</h1><table>
<thead>
<tr>
<th>头文件</th>
<th>主要功能</th>
<th>主要的类及函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>functional</td>
<td>函数对象，主要包含数字计算、比较、逻辑运算等函数对象，以及一些转换函数</td>
<td>plus, minus, multiplies, equal_to, greater, logical_and, not1, not2等非常多的函数对象</td>
</tr>
</tbody>
</table>
<h1 id="Utility">Utility</h1><table>
<thead>
<tr>
<th>头文件</th>
<th>主要功能</th>
<th>主要的类及函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>utility</td>
<td>多种工具集合</td>
<td>swap, make_pair, forward, move, pair等</td>
</tr>
</tbody>
</table>
]]></content>
    <summary type="html">
    <![CDATA[<p>C＋+有非常非常多的库文件，很多常见的功能都可在其中找到了解常用的库文件可以让我们清楚地知道有哪些系统已有功能可以使用，有哪些功能是我们需要实现的。本文列出了算法程序常用库的头文件。</p>]]>
    
    </summary>
    
      <category term="C++" scheme="http://blog.liushuping.com/tags/C/"/>
    
      <category term="算法" scheme="http://blog.liushuping.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="C++算法笔记" scheme="http://blog.liushuping.com/categories/C-%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[算法的思维之沿着右手边的墙往前走就一定能走出迷宫]]></title>
    <link href="http://blog.liushuping.com/2015/11/01/%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%9D%E7%BB%B4%E4%B9%8B%E6%B2%BF%E7%9D%80%E5%8F%B3%E6%89%8B%E8%BE%B9%E7%9A%84%E5%A2%99%E5%BE%80%E5%89%8D%E8%B5%B0%E5%B0%B1%E4%B8%80%E5%AE%9A%E8%83%BD%E8%B5%B0%E5%87%BA%E8%BF%B7%E5%AE%AB/"/>
    <id>http://blog.liushuping.com/2015/11/01/算法的思维之沿着右手边的墙往前走就一定能走出迷宫/</id>
    <published>2015-11-01T10:25:27.000Z</published>
    <updated>2015-11-09T13:47:06.000Z</updated>
    <content type="html"><![CDATA[<p>迷宫是一种老少咸宜的游戏，可以是画在纸上的迷宫游戏，也可以是以隔墙或树木修建在公园或游乐场的迷宫游戏。</p>
<h1 id="迷宫游戏的基本思路">迷宫游戏的基本思路</h1><p>解决迷宫游戏的思路很简单：任意挑一条面前没有走过的路，一旦发现当前所走的路是死胡同则记住当前路不可行并退回到上一个路口选择下一条未走过的路，以此类推直到走到出口位置。这里有个很大的难点：当迷宫足够大的时候，人很难记住哪些路是走过的，于是很有可能就在绕圈子。当用计算机来解决迷宫问题时，通常就简单很多了，因为计算机能“记忆”非常大的路径。计算机解决迷宫问题，可以归结为两种方案：深度优先搜索和广度优先搜索。</p>
<a id="more"></a>
<h1 id="深度优先">深度优先</h1><h2 id="算法">算法</h2><p>深度优先方案的思路是：每到一个分岔路口时，按照特定的顺序（例如顺时针）选取一个路口走下去，接下来的分岔路口继续按照这个思路走。一旦发现某一条路是死胡同则回到之前的岔路口，按照之前的顺序选取下一个路口走下去。如果发现当前的岔路口的所有选择都走不通，则退回到再之前的一个岔路口继续选择下去。</p>
<h2 id="数据结构">数据结构</h2><p>为了实现上面的算法，需要一定的数据结构来存储发现的路径，从而保证：</p>
<ol>
<li>路径的顺序是按照计划的方式存储的</li>
<li>要及时从数据结构中删除已经走过的路径，以确保不走重复的路</li>
<li>确保路径是沿着先深度后广度的的方案进行的</li>
</ol>
<p>基于这样的特征，很容易把栈对应到这个数据结构上来：</p>
<ol>
<li>把岔路口的所有选择逆序压到栈顶</li>
<li>然后选取栈顶的路径作为下一条路径</li>
<li>如果选择的路径走不通，则弹出栈顶的路径作为下一个选择</li>
<li>如果选择的路径继续有岔路口，则重复这几个步骤直到发现出口为止。</li>
</ol>
<p>因此这个方案所需要的栈存储空间跟入口到出口间的岔路口的多少成正比关系。</p>
<h1 id="广度优先">广度优先</h1><h2 id="算法-1">算法</h2><p>广度优先方案的思路是：每到一个分岔路口时，按照特定的顺序遍访所有的路口来确认其是否就是出口。如果没有找到出口，则以同样的思路遍访当前岔路口每一个路口所通向的下一个岔路口。如此进行下去，直到发现出口。</p>
<h2 id="数据结构-1">数据结构</h2><p>要实现上面的算法，需要一种数据结构来存储发现的岔路口，以保证：</p>
<ol>
<li>路径的顺序是按照计划的方式存取的</li>
<li>要及时从数据结构中删除已经访问过的岔路口，以确保不走重复的路</li>
<li>确保路径是沿着广度优先——层层向外扩展的方向进行的</li>
</ol>
<p>基于上面的特征，很容易把队列对应到这个数据结构上来：</p>
<ol>
<li>把当前碰到的所有岔路口追加到队列的尾部</li>
<li>取队列头部的岔路口，并检查其通向的所有路口是否为出口</li>
<li>如若不是，且该路口能通向下一个岔路口则把这个岔路口追加到队尾</li>
<li>如此循环进行，直到发现出口为止。</li>
</ol>
<p>因此这个方案所需的队列存储空间也跟入口到出口之间的岔路口的多少成正比关系。</p>
<h1 id="必须存储走过的路吗？">必须存储走过的路吗？</h1><p>为了避免让程序陷入死循环或是不必要的重复，需要记住走过的路，以便不再去走。是否需要这样做取决于所采取的方案在没有其它干预下是否存在可重复的可能。事实上，只要迷宫有岔路口，前面介绍的广度优先和深度优先的方案都确定存在这样的重复。</p>
<p>那么是否存在某种特殊的沿路径行走的方式，它能保证所走过的路一定是未走过的，不会重复走已经走过的呢？要回答这个问题，我们必须重新审视看待走迷宫的方式。</p>
<h1 id="如何看待迷宫某条路径的行走方式？">如何看待迷宫某条路径的行走方式？</h1><p>对同一个问题，不同的思考方式可能产生完全不同的解决方案，不同方案之间在复杂度以及效率上可能存在着巨大的差异。因此思维方式是人对算法理解的核心。</p>
<p>按照惯性思维，面对迷宫内的一条通道，最容易想到的是只有两种走法：进去和出来。然而基于这样的思维，解决方案也只能是前面介绍的广度或是深度优先的搜索，且都需要存储空间来标记已经走过的路。然而，简单的把迷宫通道的走法划分为进去和出来的方式使路径丢失了很多方向性信息，而丢失的信息正好可以用来“标记”走过的道路。事实上，迷宫的任意一条通道都是由左右两侧的两面墙组成而成的，沿着这两面墙分别有进去和出来的走法，这样一条通道就有4种走法了。</p>
<h1 id="无需额外记忆的迷宫走法">无需额外记忆的迷宫走法</h1><p>对迷宫通道走法的思维转变后，问题就容易分析了。先从直线分析，要保证不走重复的路很简单，只要沿着一个方向向前走即可。迷宫的路径是曲线，是否也可以用同样的方案？答案是肯定的：沿着曲线朝一个方向行走，若是发生回到原点的情况，只有下面两种可能：</p>
<ol>
<li>曲线是闭合的，在闭合区域内部，沿着曲线行走。</li>
<li>曲线是闭合的，在闭合区域的外沿，沿着曲线行走。</li>
</ol>
<p>然而，在入口到出口之间确定有通道的情况下（也即迷宫有解）的情况下，采取沿着迷宫墙壁朝一个方向行走的方式，是永远不会进入上面两种区域的。因为：</p>
<ol>
<li>不可能从一个闭合区域的外部进入其内部，因为没有”门”。而如果一开始就在内部，说明迷宫无解。</li>
<li>第二种是一个孤岛的情况，而从入口开始沿着墙朝一个方向行走，是不可能进入孤岛的。因为孤岛不可能接触人所在的墙，否则它就不是孤岛了。</li>
</ol>
<p>因此，我们把所有重复行走路线的可能都排除了，方案的正确性得到了证明。当然，沿着一个方向行走，既可是右侧，也可是左侧。</p>
<p>无需额外记忆的前提是迷宫确定有能通向出口的通道，否则会进入到上面介绍的两种重复行走路线的情况。</p>
<h1 id="总结">总结</h1><p>本文继续介绍了思维方式在算法中的重要性。通过分析解决迷宫问题的两种思路，阐述了思维方式的多样性以及不同的思维方式会对算法产生不同的效果。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>迷宫是一种老少咸宜的游戏，可以是画在纸上的迷宫游戏，也可以是以隔墙或树木修建在公园或游乐场的迷宫游戏。</p>
<h1 id="迷宫游戏的基本思路">迷宫游戏的基本思路</h1><p>解决迷宫游戏的思路很简单：任意挑一条面前没有走过的路，一旦发现当前所走的路是死胡同则记住当前路不可行并退回到上一个路口选择下一条未走过的路，以此类推直到走到出口位置。这里有个很大的难点：当迷宫足够大的时候，人很难记住哪些路是走过的，于是很有可能就在绕圈子。当用计算机来解决迷宫问题时，通常就简单很多了，因为计算机能“记忆”非常大的路径。计算机解决迷宫问题，可以归结为两种方案：深度优先搜索和广度优先搜索。</p>]]>
    
    </summary>
    
      <category term="几何" scheme="http://blog.liushuping.com/tags/%E5%87%A0%E4%BD%95/"/>
    
      <category term="算法" scheme="http://blog.liushuping.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="逻辑" scheme="http://blog.liushuping.com/tags/%E9%80%BB%E8%BE%91/"/>
    
      <category term="C++算法笔记" scheme="http://blog.liushuping.com/categories/C-%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[算法的思维之鸡兔同笼问题的分析]]></title>
    <link href="http://blog.liushuping.com/2015/11/01/%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%9D%E7%BB%B4%E4%B9%8B%E9%B8%A1%E5%85%94%E5%90%8C%E7%AC%BC%E9%97%AE%E9%A2%98%E7%9A%84%E5%88%86%E6%9E%90/"/>
    <id>http://blog.liushuping.com/2015/11/01/算法的思维之鸡兔同笼问题的分析/</id>
    <published>2015-11-01T10:24:25.000Z</published>
    <updated>2015-11-09T13:41:21.000Z</updated>
    <content type="html"><![CDATA[<p>约1500年前，《孙子算经》中有如下的问题描述：</p>
<blockquote>
<p>今有雉兔同笼，上有三十五头，下有九十四足，问雉兔各几何？</p>
</blockquote>
<p>首先科普一下，《孙子算经》的作者不详，且同《孙子兵法》不是一个作者。</p>
<p>进入正题：在数学发展到今天的水平来看，这是个很简单的问题，是一个初中问题或是小学奥数问题。然而用一些简单的问题去说明一些道理还是更容易让人接受的，毕竟如果直接拿哥德巴赫猜想（我也不会）这种世界性难题来说明道理是很难让人理解的，因为门槛太高。当然，这里要介绍的内容跟任何计算机程序语言都没有关系，只是统一分类到我的C++算法笔记作为一个子类别而已。</p>
<a id="more"></a>
<h1 id="思考的目的">思考的目的</h1><p>这里，我想通过这个简单的例子来尝试介绍一下算法的思维。个人认为，狭义上的算法思维就是按照能用计算机实现的方式来去思考问题的解决办法，当然这还需考虑解决办法的复杂度。这是一个很抽象的问题，我想还是通过这样一个简单的例子来给亲爱的读者一个直观的感觉吧。</p>
<h1 id="思考的方式">思考的方式</h1><p>这要从我还上小学的时候说起，那时就有长者考我这个问题，而当时的我觉得除了暴力穷举（知道这个方法的名字已经是好多年后的事了）外实在没有什么思路。等上了初中，学习了代数后才认识到它是人类发明的多么强大的数学工具，好多之前完全没有思路的问题顷刻间变的异常简单！</p>
<p>可是为什么会这样？这个问题我思考了很久，可以简单的总结为以下几点个人观点：</p>
<ol>
<li>有很多的问题我们很难分析出正面解决问题的思路办法</li>
<li>而在大量的问题分析过程中人们已经分析总结出了大量的恒等变化，例如交换律、结合律等等</li>
<li>代数的发明为人类提供了强有力的工具，让人们把正向难以分析的问题转化为反向的问题，从而使问题变得异常简单</li>
</ol>
<h1 id="思考的意义">思考的意义</h1><p>然而，很多情况下似乎正面分析得出的思路更容易通过计算机算法程序去实现。事实上，通过代数结合等式的恒等变化而解决问题的方式，如果不加深入的思考，很容易陷入知道如何解决问题，却不明白解决方式背后所隐含的真实思路的境况。</p>
<h1 id="以更加算法的方式去思考">以更加算法的方式去思考</h1><p>鸡兔同笼问题如果从正面思考，应该是简单的数论问题，是关于整数的加减乘除及取余的相关操作，而这些都跟计算机程序的算法息息相关。既然当鸡和兔子都已经站在笼子里时去正面分析比较困难，需要代数的帮忙，那么我们把顺序反过来，先让它们都站在笼子外面，然后从正面去分析让它们在逐步满足条件的前提下如何分步骤进入笼子。</p>
<p>在问题有解的前提下，腿的总数量应该介于全部是鸡时的腿的数量和全部是兔时腿的数量之间。那么在这个思路下，问题可以划分为多个子问题，而大问题划分为子问题的方法是计算机算法的一个重要工具：</p>
<ol>
<li>让全部的鸡进入笼子，然后计算一下全部腿的数量，如若等于问题给定的腿的数量，那么笼子内全是鸡；否则，进入第二个子问题</li>
<li>把多余的腿分配到笼子内的鸡身上。怎么分配？不能每只鸡分配一条腿，因为三条腿既不是鸡也不是兔子。所以要每只鸡分配两条腿，这样就神奇地让这只鸡变成兔子了。</li>
<li>问题得到了解决：变成兔子了的就是兔子，而没变的仍是鸡。</li>
</ol>
<h1 id="从反向思维推正向思维">从反向思维推正向思维</h1><p>代数、等式以及等价变换等都是数学对问题高度的抽象，可以脱离于物理量而存在。然而对于具体的问题，还是能通过对其问题的计算过程赋以具体物理意义而推导正向思维的。鸡兔问题，可以通过一元一次或二元一次方程来解决。而二元一次方程可以转化为一元一次方程，所以我们就以一元一次方程来分析（因为给二元赋以物理量比给一元赋以物理量难得多）：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span>x + (<span class="number">35</span> - x) * <span class="number">2</span> = <span class="number">94</span></span><br></pre></td></tr></table></figure></p>
<p>这代表了<code>x</code>只兔子和<code>35 - x</code>只鸡总共有94条腿。然后，可以用数学工具把它变化为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>x = <span class="number">94</span> - <span class="number">70</span></span><br></pre></td></tr></table></figure></p>
<p>这代表了什么意思呢？一种可行的理解方式是：假如把<code>35</code>全部分配为鸡的话<code>(35 * 2)</code>，剩余的腿<code>(94 - 70)</code>如何去分配呢？分配的限制条件是只能分配成兔子，也就是说要以两个两个的方式去分配，而被分配到的就变成了兔子，这就是<code>2x</code>所表示的意义。那么这个正向思路也就倒着推出来了。</p>
<h1 id="总结">总结</h1><p>思维的方式是决定或影响算法的一个重要因素。有时候从正反两个方面去分析问题，能更容易地找到思路。本文的目的不是告诉大家鸡兔同笼这个问题如何去解，而是通过分析解这道题的思路去认识和了解算法的思维。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>约1500年前，《孙子算经》中有如下的问题描述：</p>
<blockquote>
<p>今有雉兔同笼，上有三十五头，下有九十四足，问雉兔各几何？</p>
</blockquote>
<p>首先科普一下，《孙子算经》的作者不详，且同《孙子兵法》不是一个作者。</p>
<p>进入正题：在数学发展到今天的水平来看，这是个很简单的问题，是一个初中问题或是小学奥数问题。然而用一些简单的问题去说明一些道理还是更容易让人接受的，毕竟如果直接拿哥德巴赫猜想（我也不会）这种世界性难题来说明道理是很难让人理解的，因为门槛太高。当然，这里要介绍的内容跟任何计算机程序语言都没有关系，只是统一分类到我的C++算法笔记作为一个子类别而已。</p>]]>
    
    </summary>
    
      <category term="数学" scheme="http://blog.liushuping.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="数论" scheme="http://blog.liushuping.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="算法" scheme="http://blog.liushuping.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="逻辑" scheme="http://blog.liushuping.com/tags/%E9%80%BB%E8%BE%91/"/>
    
      <category term="C++算法笔记" scheme="http://blog.liushuping.com/categories/C-%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++算法笔记－基本输入输出]]></title>
    <link href="http://blog.liushuping.com/2015/10/28/C++%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%EF%BC%8D%E5%9F%BA%E6%9C%AC%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
    <id>http://blog.liushuping.com/2015/10/28/C++算法笔记－基本输入输出/</id>
    <published>2015-10-28T15:24:51.000Z</published>
    <updated>2015-11-09T13:40:23.000Z</updated>
    <content type="html"><![CDATA[<p>算法题目都是要求对于给定的输入，在规定时间内把结果输出到指定的设备上。因此输入输出是做算法的最基本条件。</p>
<h1 id="输入">输入</h1><p>C++中输入有两种常见的形式：来自标准输入设备<code>stdin</code>和来自文件。</p>
<h2 id="标准输入设备stdin">标准输入设备stdin</h2><h3 id="输入重定向">输入重定向</h3><p>默认情况下<code>stdin</code>来自于键盘的输入，然而我们可以把它重定向到任何其它可用的设备，比如常见的文件。在常见的系统中，对于一个控制台程序，我们可以用输入重定向来把标准输入重定向到文件设备。例如下列代码把程序<code>test</code>的标准输入重定向到了文件<code>file1.txt</code>:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test &lt; file1.txt</span><br></pre></td></tr></table></figure></p>
<p>这是一个非常实用的功能：在程序算法题中常见的输入是一个文件，如果通过把文件内容粘贴到控制台程序来实现输入会很不方便，尤其是当文件内容非常大的时候。</p>
<p>除输入重定向之外，还可以通过<code>freopen</code>来使一个已经存在的流<code>stream</code>指向目标文件。当然，<code>stdin</code>，<code>stdout</code>，以及<code>stderr</code>都是流的一种，因此我们可以用该函数来实现输入的重定向。下面的代码实现了把标准输入重定向到文件<code>file1.txt</code>:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">freopen(“file1.txt”, “r”, <span class="built_in">stdin</span>);</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>函数<code>freopen</code>的第二个参数表示了文件的访问模式，有下面的几种可能的取值：</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>”r”</td>
<td>以读取的方式打开文件，文件必须存在</td>
</tr>
<tr>
<td>”w”</td>
<td>创建一个空文件用来写入。如果文件内容存在，则忽略文件内容并按照空文件的方式写入内容</td>
</tr>
<tr>
<td>”a”</td>
<td>按照追加模式打开文件写入内容。如果文件不存在，则创建文件</td>
</tr>
<tr>
<td>”r+”</td>
<td>以读取并更新的模式打开一个文件，文件必须存在</td>
</tr>
<tr>
<td>”w+”</td>
<td>以写入并更新的模式创建一个文件。如果文件存在，则忽略内容并按照空文件的方式对待</td>
</tr>
<tr>
<td>”a+”</td>
<td>以追加并更新的模式打开一个文件。文件定位操作会影响下次输入的操作，而输出内容总是会被追加到文件末尾。如果文件不存在，则创建文件</td>
</tr>
</tbody>
</table>
<p>上面所列模式都是以文本方式打开文件，这也是大多数算法程序常见的输入模式。若需要以二进制的方式读取文件，在模式中添加一个<code>b</code>字符即可，该字符可处于任何位置，如：<code>rb</code>，<code>bw</code>。<br>作为良好的习惯，在文件使用完毕后应该将其关闭：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">freopen(“file1.txt”, “r”, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">fclose(<span class="built_in">stdin</span>);</span><br></pre></td></tr></table></figure></p>
<p>关于<code>freopen</code>的信息，请参考<a href="http://www.cplusplus.com/reference/cstdio/freopen/" target="_blank" rel="external">链接</a>。</p>
<h3 id="读取标准输入设备stdin">读取标准输入设备stdin</h3><h4 id="std::cin">std::cin</h4><p><code>std::cin</code>是指向标准输入设备<code>stdin</code>的流对象，通过流输入运算符<code>&gt;&gt;</code>可以从标准输入设备中读取内容到指定的内存变量中。例如下面的代码是从标准输入设备中读取一个整数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br></pre></td></tr></table></figure></p>
<p>默认的读取方式是以空格或换行符号为分隔的。假如输入设备中有内容 <code>10 20 abc</code>，可以方便的用以下代码读取：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> c;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br></pre></td></tr></table></figure></p>
<h4 id="std::cin读取空格或换行符">std::cin读取空格或换行符</h4><p>如果确需要读取空格或换行字符，则需要用到<code>std::cin.get();</code>函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s;</span><br><span class="line">s = <span class="built_in">std</span>::<span class="built_in">cin</span>.get();</span><br></pre></td></tr></table></figure></p>
<h4 id="std::cin读取非十进制数字">std::cin读取非十进制数字</h4><p>如果要读取的字符是非十进制数字，则需要告诉<code>std::cin</code>按照指定的进制读取，可以通过<code>std::setbase()</code>来指定：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; <span class="built_in">std</span>::setbase(<span class="number">16</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br></pre></td></tr></table></figure></p>
<h4 id="cin读取整行">cin读取整行</h4><p>可以通过<code>std::cin.getline()</code>或<code>std::getline()</code>来实现读取一行内容。实际使用中，<code>std::getline()</code>更常用一些，因为它直接支持STL字符串类型，更加方便：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">std</span>::getline(<span class="built_in">cin</span>, s);</span><br></pre></td></tr></table></figure></p>
<p>更多的关于<code>std::getline()</code>的内容，参考<a href="http://www.cplusplus.com/reference/string/string/getline/?kw=getline" target="_blank" rel="external">链接</a>。<br>关于<code>std::cin.getline()</code>的内容，参考<a href="http://www.cplusplus.com/reference/istream/istream/getline/" target="_blank" rel="external">链接</a>。</p>
<h4 id="std::cin其它相关">std::cin其它相关</h4><p>事实上，<code>std::cin</code>是<code>std::istream</code>的一个实例，因此<code>std::istream</code>的所有公开方法都可以通过<code>std::cin</code>调用。比如流读取位置定位，<code>peek</code>以及忽略当前字符等等功能。这些高级功能在算法程序中应用的比较少，就不赘述了，具体内容可参考<a href="http://www.cnblogs.com/pegasus923/archive/2011/04/22/2024418.html" target="_blank" rel="external">链接</a>。</p>
<h3 id="scanf">scanf</h3><p><code>scanf</code>是C风格的从标准输入设备读取格式化数据的强有力的方法，它从<code>stdin</code>中读取内容，其参数类型丰富强大，但也不容易记忆。<code>scanf</code>接受至少一个参数的变长参数，第一个参数是以C类型字符串表示的输入参数格式。后面的其它参数应该是一系列预先分配好的变量，依次对应参数格式字符串内的标识符。例如下面代码表示从<code>stdin</code>中读取一个整型数字到变量<code>x</code>中：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(“%i”, &amp;x);</span><br></pre></td></tr></table></figure></p>
<p>其中参数格式字符串的格式是：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%[<span class="link_label">*</span>][<span class="link_reference">width</span>][<span class="link_label">length</span>]specifier</span><br></pre></td></tr></table></figure></p>
<p>这其中的的<code>specifier</code>有如下的定义：</p>
<table>
<thead>
<tr>
<th>specifier</th>
<th>解释</th>
<th>读取的字符</th>
</tr>
</thead>
<tbody>
<tr>
<td>i</td>
<td>Integer</td>
<td>整数，有符号的(singed)，可以以<code>+</code>或<code>-</code>开头。默认是十进制，若以0开头则认为是8进制，以0x开头则认为是16进制</td>
</tr>
<tr>
<td>d, u</td>
<td>Decimal Integer</td>
<td>十进制整数，可以以<code>+</code>或<code>-</code>开头。<code>d</code>代表有符号的，<code>u</code>代表无符号的</td>
</tr>
<tr>
<td>o</td>
<td>Octal integer</td>
<td>八进制整数，可以以<code>+</code>或<code>-</code>开头。无符号参数</td>
</tr>
<tr>
<td>x</td>
<td>Hexadecimal integer</td>
<td>十六进制整数，可以以<code>0x</code>或<code>0X</code>开头，同时也可以以<code>+</code>或<code>-</code>开头。无符号参数</td>
</tr>
<tr>
<td>f, e, g</td>
<td>Floating Point Number</td>
<td>浮点数，可带小数点，开头可以包含<code>+</code>或<code>-</code>，可以用科学记数法。C99标准支持以<code>0x</code>或<code>0X</code>开头的十六进制数</td>
</tr>
<tr>
<td>c</td>
<td>Character</td>
<td>读取下一个字符。如果<code>width</code>是大于<code>1</code>的数，则读取相应数量的字符，并把它们放在指定的内存连续空间内，但不会在结尾处添加<code>null</code>字符。</td>
</tr>
<tr>
<td>s</td>
<td>String of characters</td>
<td>从当前位置开始读取字符，直到下一个字符是空白字符。读取完毕后会在存储变量后添加一个代表结束的<code>null</code>字符</td>
</tr>
<tr>
<td>p</td>
<td>Pointer address</td>
<td>读取一系列代表指针的字符，它的格式会因不同系统及不同库而不同，但是它跟在<code>fprintf</code>中的<code>%p</code>的参数使用方式是一样的</td>
</tr>
<tr>
<td>[characters]</td>
<td>Scanset</td>
<td>从当前位置开始读取字符，直到下一个字符是方括号内未定义的字符停止</td>
</tr>
<tr>
<td>[^characters]</td>
<td>Negated scanset</td>
<td>从当前位置开始读取字符，直到下一个字符是方括号内定义的字符停止</td>
</tr>
<tr>
<td>n</td>
<td>Count</td>
<td>不会读取字符，会返回当前已读取字符的个数到对应参数所指向的存储空间</td>
</tr>
<tr>
<td>%</td>
<td>%</td>
<td>表示读取一个%字符</td>
</tr>
</tbody>
</table>
<p>除<code>n</code>之外，其它任何的标识符都至少会触发读取一个字符，否则匹配失败，读取扫描结束。</p>
<p>参数格式中的<code>*</code>，<code>width</code>及<code>length</code>的解释如下：</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>可选参数，表示数据会被读取并被忽略，不会存储到某个地址中</td>
</tr>
<tr>
<td>width</td>
<td>可选参数，指定了读取字符的最大个数</td>
</tr>
<tr>
<td>length</td>
<td>可选参数，可以是<code>hh</code>, <code>h</code>, <code>l</code>, <code>ll</code>, <code>j</code>, <code>z</code>, <code>t</code>, <code>L</code>中的任一值，表明了对存储地址的期望类型</td>
</tr>
</tbody>
</table>
<p>下表列出了不同<code>length</code>对不同标识符的类型期望：</p>
<table>
<thead>
<tr>
<th>length</th>
<th>d i</th>
<th>u o x</th>
<th>f e g a</th>
<th>c s [] [^]</th>
<th>p</th>
<th>n</th>
</tr>
</thead>
<tbody>
<tr>
<td>(none)</td>
<td>int*</td>
<td>unsigned int*</td>
<td>float*</td>
<td>char*</td>
<td>void**</td>
<td>int*</td>
</tr>
<tr>
<td>hh</td>
<td>signed char*</td>
<td>unsigned char*</td>
<td></td>
<td></td>
<td></td>
<td>singed char*</td>
</tr>
<tr>
<td>h</td>
<td>short int*</td>
<td>unsigned short int*</td>
<td></td>
<td></td>
<td></td>
<td>short int*</td>
</tr>
<tr>
<td>l</td>
<td>long int*</td>
<td>unsigned long int*</td>
<td>double*</td>
<td>wchar_t*</td>
<td></td>
<td>long int*</td>
</tr>
<tr>
<td>ll</td>
<td>long long int*</td>
<td>unsigned long long int*</td>
<td></td>
<td></td>
<td></td>
<td>long int*</td>
</tr>
<tr>
<td>j</td>
<td>intmax_t*</td>
<td>uintmax_t*</td>
<td></td>
<td></td>
<td></td>
<td>intmax_t*</td>
</tr>
<tr>
<td>z</td>
<td>size_t*</td>
<td>size_t*</td>
<td></td>
<td></td>
<td></td>
<td>size_t*</td>
</tr>
<tr>
<td>t</td>
<td>ptrdiff_t*</td>
<td>ptrdiff_t*</td>
<td></td>
<td></td>
<td></td>
<td>ptfdiff_t*</td>
</tr>
<tr>
<td>L</td>
<td></td>
<td></td>
<td>long double*</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>函数返回有多少个参数被设置值了，可能是返回所有参数的个数，如果发生了任何错误，则可能是比它小的一个数字。</p>
<p>关于<code>scanf</code>更多内容请参考<a href="http://www.cplusplus.com/reference/cstdio/scanf/?kw=scanf" target="_blank" rel="external">链接</a>。</p>
<h3 id="读取文件内容">读取文件内容</h3><p>当输入内容来自于文件时，对于编写算法程序，推荐的做法是通过输入重定向或<code>freopen</code>让<code>stdin</code>指向输入文件。然而如果确需要直接读取文件，可以使用<code>fopen</code>打开文件然后配合多种文件的读取函数来实现期望的对输入文件的读取，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FILE *file;</span><br><span class="line">file = fopen(<span class="string">"stdinout.cpp"</span>, <span class="string">"r"</span>);</span><br><span class="line"><span class="keyword">char</span> c = getc(file);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c;</span><br><span class="line">fclose(file);</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，<code>getc</code>的作用是从指定的文件中读取下一个字符。除此之外，还有很多从文件读取内容的函数，如<code>fgetc</code>，<code>fgets</code>，<code>fscanf</code>等。由于算法程序中输入大多是顺序的文本文件读取操作，因此输入重定向结合读取标准输入设备的方式更实用。文件的读取方式便不再赘述，有关详细内容可参考<a href="http://www.cplusplus.com/reference/cstdio/" target="_blank" rel="external">链接</a>。</p>
<h1 id="输出">输出</h1><p>C++中输出有两种常见的形式：标准输出设备<code>stdout</code>和文件。</p>
<h2 id="标准输出设备stdout">标准输出设备stdout</h2><h3 id="输出重定向">输出重定向</h3><p>默认情况下，<code>stdout</code>指向的是显示器，然而我们可以把它重定向到任何其它可用的设备，例如文件。在常见的系统中，对于一个控制台程序，我们可以通过输出重定向来让<code>stdout</code>指向文件，例如下面的代码把<code>test</code>程序的输出重定向到了文件<code>file1.txt</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span> &gt; file1.txt</span><br></pre></td></tr></table></figure></p>
<p>输出重定向是一个非常实用的功能：当程序输出内容很多的时候，显示器会翻屏甚至清除掉前面输出的内容，不方便人工查看。因此，可以把内容输出重定向到文件内，方便人工查看和备份。</p>
<p>除了输出重定向外，还可以通过<code>freopen</code>来让一个已经存在的<code>stream</code>指向指定的目标文件。它的使用方式已经在<a href="#输入重定向">输入重定向</a>中详细介绍了，这里不在赘述，区别是输出的时候文件打开模式要是<code>&quot;w&quot;</code>。</p>
<h3 id="写入到标准输出设备stdout">写入到标准输出设备stdout</h3><h4 id="std::cout">std::cout</h4><p><code>std::cout</code>是指向标准输出设备<code>stdout</code>的流对象，通过流运算符<code>&lt;&lt;</code>可以输出内容到标准输出设备中。例如下面的代码是向标准设备输出整数<code>x</code>:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">x = <span class="number">123</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x;</span><br></pre></td></tr></table></figure></p>
<h4 id="std::cout输出空行">std::cout输出空行</h4><p>当需要输出空行是，可以用<code>\n</code>或者<code>std::endl</code>的方式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::endl;</span><br></pre></td></tr></table></figure></p>
<h4 id="std::cout输出指定宽度">std::cout输出指定宽度</h4><p>当需要对输出内容指定宽度时，可以使用<code>std::setw()</code>函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setw(<span class="number">5</span>) &lt;&lt; <span class="number">11</span> &lt;&lt; <span class="built_in">std</span>::endl;</span><br></pre></td></tr></table></figure></p>
<p>输出时，数字<code>11</code>的左侧会填充三个空格。值得注意的是，<code>std::setw()</code>只会影响下一次输出，并不会影响后续的输出。<code>std::set()</code>来自于头文件<code>&lt;iomanip&gt;</code>。</p>
<h4 id="std::cout指定输出的填充字符">std::cout指定输出的填充字符</h4><p>当对输出内容指定输出宽度，但内容不够宽度时，输出内容的左侧会以空格字符填充。如果需要指定不同的填充字符，则使用<code>std::setfill()</code>，如下代码则用字符<code>x</code>做为填充：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setfill(<span class="string">'x'</span>) &lt;&lt; <span class="built_in">std</span>::setw(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">11</span> &lt;&lt; <span class="built_in">std</span>::endl;</span><br></pre></td></tr></table></figure></p>
<h4 id="std::cout输出非十进制数字">std::cout输出非十进制数字</h4><p>当需要输出的内容是非十进制时，可以通过<code>std::setbase()</code>来指定：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setbase(<span class="number">16</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">0xff</span> &lt;&lt; <span class="built_in">std</span>::endl;</span><br></pre></td></tr></table></figure></p>
<p>STL预定义了一些进制标识符可以用做<code>std::setbase()</code>的参数，他们是：<code>std::dec</code>，<code>std::hex</code>和<code>std::oct</code>。</p>
<h4 id="std::cout设置流的格式">std::cout设置流的格式</h4><p>通过<code>std::setbase()</code>可以设置下一次数的输出进制，然而如果需要多次输出则需要多次设置。<code>std::cout</code>支持全局设置格式，直到取消前该格式会一直影响输出设置。STL定义了一系列的基于位运算的格式，详细信息如下表所列：</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>常量</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>独立标志位</td>
<td>boolalpha</td>
<td>以字符串的形式(true，false)读取布尔变量</td>
</tr>
<tr>
<td>独立标志位</td>
<td>showbase</td>
<td>在输出整数之前输出其进制标识符</td>
</tr>
<tr>
<td>独立标志位</td>
<td>showpoint</td>
<td>输出浮点数时，总是输出小数点</td>
</tr>
<tr>
<td>独立标志位</td>
<td>showpos</td>
<td>输出非负数时，以+号开始</td>
</tr>
<tr>
<td>独立标志位</td>
<td>skipws</td>
<td>这个参数用在输入时，其作用是忽略某些输入操作开头部分的空格</td>
</tr>
<tr>
<td>独立标志位</td>
<td>unitbuf</td>
<td>每次插入操作后，都进行一次写出(flush)操作</td>
</tr>
<tr>
<td>独立标志位</td>
<td>uppercase</td>
<td>在某些插入操作，以大写字母代替小写字幕</td>
</tr>
<tr>
<td>进制(basefield)</td>
<td>dec</td>
<td>以十进制读取或写入整数</td>
</tr>
<tr>
<td>进制(basefield)</td>
<td>hex</td>
<td>以十六进制读取或写入整数</td>
</tr>
<tr>
<td>进制(basefield)</td>
<td>oct</td>
<td>以八进制读取或写入整数</td>
</tr>
<tr>
<td>浮点数格式(floatfield)</td>
<td>fixed</td>
<td>以固定小数点的形式输出浮点数</td>
</tr>
<tr>
<td>浮点数格式(floatfield)</td>
<td>scientific</td>
<td>以科学计数法的形式输出浮点数</td>
</tr>
<tr>
<td>对齐方式(adjustfield)</td>
<td>internal</td>
<td>通过在指定位置插入填充字符的方式来使输出达到指定宽度</td>
</tr>
<tr>
<td>对齐方式(adjustfield)</td>
<td>left</td>
<td>通过在末尾追加填充字符的方式来使输出达到指定宽度</td>
</tr>
<tr>
<td>对齐方式(adjustfield)</td>
<td>right</td>
<td>通过在开头添加填充字符的方式来使输出达到指定宽度</td>
</tr>
</tbody>
</table>
<p>格式可以是上述任意一种或是它们任意多个的组合。<code>basefield</code>，<code>floatfield</code>和<code>adjustfield</code>是三个预定义的组合，它们分别对应的值如下表所列：</p>
<table>
<thead>
<tr>
<th>组合</th>
<th>组合形式</th>
</tr>
</thead>
<tbody>
<tr>
<td>basefield</td>
<td>dec&#124;hex&#124;oct</td>
</tr>
<tr>
<td>floatfield</td>
<td>fixed&#124;scientific</td>
</tr>
<tr>
<td>adjustfield</td>
<td>internal&#124;left&#124;right</td>
</tr>
</tbody>
</table>
<p>这些常量值都定义在<code>ios_base</code>类中，因此可以通过<code>ios_base</code>及其子类，或任何其实例来访问这些常量。例如：<code>std::ios_base::hex</code>，<code>std::ios::hex</code>或<code>std::cout.hex</code>。可以通过<code>std::cout.setf()</code>函数来设置这些值：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::<span class="built_in">cout</span>.hex);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::ios_base::hex);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::ios::hex);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::out.hex, <span class="built_in">std</span>::<span class="built_in">cout</span>.basefield)</span><br></pre></td></tr></table></figure></p>
<p>从代码中可以看出，<code>std::cout.setf()</code>有重载，可以是给定一个参数，相当于只设置这个标志位而不影响其它标志位；也可以是两个参数，其作用是设置第二个参数所影响范围内的标志位，把其值设置为第一个参数和第二个参数的逻辑与之后的值，而第二个参数标志位以外的标志位不受影响。关于<code>std::cout.setf()</code>的更多信息请参考<a href="http://www.cplusplus.com/reference/ios/ios_base/setf/" target="_blank" rel="external">链接</a></p>
<p>另外，<code>std::cout.setiosflags()</code>等同于<code>std::cout.setf()</code>的两参数版本；<code>std:cout.resetiosflags()</code>等同于<code>std::cout.unsetf()</code>的两参数版本。</p>
<p>任何时刻可以通过<code>std::cout.unsetf()</code>来取消之前所设置的任何标志位。</p>
<p>任何时刻都可以通过<code>std::cout.flags()</code>来获取当前已经设置的所有标志位。<code>std::cout.flags()</code>还有一个重载，接受一个标志位参数，不同于<code>std::cout.setf()</code>的是，它会清除所有其它的标志位，只保留所设置的标志位。</p>
<h3 id="printf">printf</h3><p><code>printf</code>是C风格的向标准输出设备输出格式化字符串的强有力方法，它有同<code>scanf</code>类似的参数定义，但对参数格式字符串的定义有略微的不同，其定义是：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%[<span class="link_label">flags</span>][<span class="link_reference">width</span>][<span class="link_label">.precision</span>][<span class="link_reference">length</span>]specifier</span><br></pre></td></tr></table></figure></p>
<p>对其中的<code>specifier</code>的解释如下表：</p>
<table>
<thead>
<tr>
<th>specifier</th>
<th>输出</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>d或i</td>
<td>有符号的十进制整数</td>
<td>123</td>
</tr>
<tr>
<td>u</td>
<td>无符号的十进制整数</td>
<td>1234</td>
</tr>
<tr>
<td>o</td>
<td>无符号的八进制整数</td>
<td>723</td>
</tr>
<tr>
<td>x</td>
<td>无符号的十六进制整数</td>
<td>ab12</td>
</tr>
<tr>
<td>X</td>
<td>大写的无符号十六进制整数</td>
<td>AB12</td>
</tr>
<tr>
<td>f</td>
<td>小写的十进制浮点数</td>
<td>123.45</td>
</tr>
<tr>
<td>F</td>
<td>大写的十进制浮点数</td>
<td>123.45</td>
</tr>
<tr>
<td>e</td>
<td>小写的科学计数法数</td>
<td>1.2345e+2</td>
</tr>
<tr>
<td>E</td>
<td>大写的科学计数法数</td>
<td>1.2345E+2</td>
</tr>
<tr>
<td>g</td>
<td>在%f和%e之间取比较短的表示方式</td>
<td>123.45</td>
</tr>
<tr>
<td>G</td>
<td>在%F和%E之间取比较短的表示方式</td>
<td>123.45</td>
</tr>
<tr>
<td>a</td>
<td>小写16进制浮点数</td>
<td>-0xabc123.45ep-3</td>
</tr>
<tr>
<td>A</td>
<td>大写16进制浮点数</td>
<td>-0XABC123.45EP-3</td>
</tr>
<tr>
<td>c</td>
<td>字符</td>
<td>a</td>
</tr>
<tr>
<td>s</td>
<td>字符串</td>
<td>test</td>
</tr>
<tr>
<td>p</td>
<td>指针地址</td>
<td>f1234567</td>
</tr>
<tr>
<td>n</td>
<td>不会输出任何内容，对应的参数应该是一个有符号整数，会把当前已经输出的字符个数存储到该参数对应的变量中</td>
<td></td>
</tr>
<tr>
<td>%</td>
<td>输出一个%符号</td>
<td>%</td>
</tr>
</tbody>
</table>
<p>对格式串中的<code>flags</code>域有如下表所列解释：</p>
<table>
<thead>
<tr>
<th>flags</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>-</td>
<td>以左对齐的方式输出指定内容，默认是右对齐</td>
</tr>
<tr>
<td>+</td>
<td>强制数字的输出以<code>+</code>或<code>-</code>符号开始，即使是正数。默认只有负数才以符号位开始</td>
</tr>
<tr>
<td>(空格)</td>
<td>如果无符号输出，则在值之前输出一个空格</td>
</tr>
<tr>
<td>#</td>
<td>当跟o，x或X一起使用时，用来指示值是以0，0x或0X开头。当跟a，A，e，E，f，F，g，G一起使用时，强制输出小数点后的位数。默认情况下，如果没有小数点后的位数则不输出小数点</td>
</tr>
<tr>
<td>0</td>
<td>当对输出指定宽度时(见下表)，不足位数在左侧以0补齐</td>
</tr>
</tbody>
</table>
<p>对格式串中的<code>width</code>域的解释如下：</p>
<table>
<thead>
<tr>
<th>width</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>数字</td>
<td>输出字符串的最小宽度，当不足宽度时以空格或其它指定的字符补齐；当要输出的内容比指定的宽度长时，内容不会被截断</td>
</tr>
<tr>
<td>*</td>
<td>未在格式串中指定宽度，而是由对应的一个额外的参数（来自于参数列表）来指定。</td>
</tr>
</tbody>
</table>
<p>对格式串中的 <code>.precision</code>域的解释如下：</p>
<table>
<thead>
<tr>
<th>.precision</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>.number</td>
<td>当和整数标识符(d，i，o，u，x，X）一起使用时，表示要输出的总位数，不够时在左侧以0补齐。当要输出的数字超出这个长度时不会被截断。当<code>precision</code>是0的时候，表示对0不会输出任何字符。当同a，A，e，E，f或F一起使用时，表示要输出的小数点后的位数。当结合g或G使用时，表示要输出的最大有效位数。当与s结合使用时，表示要输出的最大字符数，默认情况下会一直输出到空字符结束。</td>
</tr>
<tr>
<td>.*</td>
<td>未在格式串中指定精度，而是由对应的一个额外参数（来自于参数列表）来指定。</td>
</tr>
</tbody>
</table>
<p>而格式串中的<code>length</code>与<a href="#scanf">scanf</a>格式串中的<code>length</code>域有相同的解释，不再重复。</p>
<h3 id="写入文件内容">写入文件内容</h3><p>当需要输出内容到文件时，对于编写算法程序，推荐的做法是通过输出重定向或<code>freopen</code>让<code>stdout</code>指向目标输出文件。然而如果确需要直接写入文件，可以使用<code>fopen</code>以写入的方式打开文件并进行写入，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FILE *file;</span><br><span class="line">file = fopen(<span class="string">"test.txt"</span>, <span class="string">"wt"</span>);</span><br><span class="line">putc(<span class="string">'a'</span>, file);</span><br><span class="line">fclose(file);</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，<code>putc</code>的作用是向文件<code>test.txt</code>中输出一个指定的字符。除此之外，还有其它写入文件内容的函数，如<code>fputc</code>，<code>fputs</code>，<code>fprintf</code>等。由于算法程序大多是顺序的输出，因此输出重定向结合写入标准输出设备的方式更实用。文件的写入方式便不再赘述，有关详细内容可参考<a href="http://www.cplusplus.com/reference/cstdio/" target="_blank" rel="external">链接</a>。</p>
<h1 id="输出的效率">输出的效率</h1><p>算法程序的一个重要考量因素是程序的运行效率。除去程序逻辑本身是算法效率高低的主要因素之外，输出的效率也是一个应该考虑的因素，尤其是当输出的数据量非常大时。例如在一个非常大的循环内输出数据，而输出又被定向到文件内，这样多次的文件写入必然会造成效率的损失。因此，把要输出的数据缓存在一个内存空间内，待所有数据准备完毕后，一次性输出到文件内，则可提高一定的效率。</p>
<h1 id="头文件">头文件</h1><p><code>std::cin</code>和<code>std::cout</code>来自于头文件<code>&lt;iostream&gt;</code><br><code>std::cin</code>和<code>std::cout</code>输入输出格式的控制函数存在于<code>&lt;iomanip&gt;</code>头文件中。<br><code>scanf</code>和<code>printf</code>函数来自于头文件<code>&lt;stdio.h&gt;</code></p>
<h1 id="TL;DR">TL;DR</h1><p>基本的输入输出是算法程序的重要基础。在C++算法程序中，输入输出的重定向可以方便快捷地让标准输入输出设备指向所指定的文件。而C++ STL中的<code>cin</code>和<code>cout</code>流可以很方便地从标准输入设备读取数据和向标准输出设备输出数据。<code>scanf</code>和<code>printf</code>是C风格的输入输出函数。熟练掌握输入输出数据格式的控制，是正确处理输入输出文件的重要前提，也是保证算法程序正确性的一个基本前提。</p>
<p>把要输出的内容缓存到一个内存空间内，待所有数据准备完毕后一次性把结果写出到输出设备中，可以一定程度地提高程序的运行效率。当然，这需要在内存的占用空间和算法效率之间做一些权衡。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>算法题目都是要求对于给定的输入，在规定时间内把结果输出到指定的设备上。因此输入输出是做算法的最基本条件。</p>
<h1 id="输入">输入</h1><p>C++中输入有两种常见的形式：来自标准输入设备<code>stdin</code>和来自文件。</p>
<h2 id="标准输入设备stdin">标准输入设备stdin</h2><h3 id="输入重定向">输入重定向</h3><p>默认情况下<code>stdin</code>来自于键盘的输入，然而我们可以把它重定向到任何其它可用的设备，比如常见的文件。在常见的系统中，对于一个控制台程序，我们可以用输入重定向来把标准输入重定向到文件设备。例如下列代码把程序<code>test</code>的标准输入重定向到了文件<code>file1.txt</code>:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test &lt; file1.txt</span><br></pre></td></tr></table></figure></p>
<p>这是一个非常实用的功能：在程序算法题中常见的输入是一个文件，如果通过把文件内容粘贴到控制台程序来实现输入会很不方便，尤其是当文件内容非常大的时候。</p>
<p>除输入重定向之外，还可以通过<code>freopen</code>来使一个已经存在的流<code>stream</code>指向目标文件。当然，<code>stdin</code>，<code>stdout</code>，以及<code>stderr</code>都是流的一种，因此我们可以用该函数来实现输入的重定向。下面的代码实现了把标准输入重定向到文件<code>file1.txt</code>:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">freopen(“file1.txt”, “r”, <span class="built_in">stdin</span>);</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="C++" scheme="http://blog.liushuping.com/tags/C/"/>
    
      <category term="算法" scheme="http://blog.liushuping.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="C++算法笔记" scheme="http://blog.liushuping.com/categories/C-%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Backbone router demo]]></title>
    <link href="http://blog.liushuping.com/2015/08/09/Backbone-router-demo/"/>
    <id>http://blog.liushuping.com/2015/08/09/Backbone-router-demo/</id>
    <published>2015-08-09T14:48:36.000Z</published>
    <updated>2015-10-25T10:40:14.000Z</updated>
    <content type="html"><![CDATA[<p>这是一个简单的关于Backbone router的演示，下面的例子演示了，通过Backbone的router和pushState来达到省略URL中的Hash符号的目的。</p>
<p>首先定义一个App需要的router，例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> AppRouter = Backbone.Router.extend(&#123;  </span><br><span class="line">    routes : &#123;  </span><br><span class="line">        <span class="string">'help'</span>: <span class="string">'help'</span>,  </span><br><span class="line">        <span class="string">'search/:query'</span>: <span class="string">'search'</span>, </span><br><span class="line">        <span class="string">'search/:query/:page'</span>: <span class="string">'search'</span></span><br><span class="line">    &#125;,   </span><br><span class="line"></span><br><span class="line">    search: <span class="function"><span class="keyword">function</span>(<span class="params">query, page</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (page == <span class="literal">null</span>) &#123;</span><br><span class="line">          alert(<span class="string">'query: '</span> + query);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          alert(<span class="string">'query: '</span> + query + <span class="string">', page: '</span> + page);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>接下来启动<code>history</code>的状态记录：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Backbone.history.start(&#123;pushState: <span class="literal">true</span>&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这里如果页面所在的目录不是根目录，则需要添加root参数。</p>
<p>然后我们就可以用router来控制URL状态了：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> router = <span class="keyword">new</span> AppRouter();</span><br><span class="line">router.navigate(<span class="string">'search/myquery/123'</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure></p>
<p>这很有用，然而并不是所有的状态变化都是我们通过代码来修改<code>router</code>的状态，更多的是可能交给用户去“导航”，比如<code>&lt;a&gt;</code>标签。然而不幸的是，<code>Backbone</code>并没有对<code>&lt;a&gt;</code>标签做任何的定制，也就是说如果不做任何处理的话，<code>&lt;a&gt;</code>标签的点击事件还是会触发浏览器向服务器发起HTTP请求的，这并不是我们想要的。</p>
<p>因此，我们应该做的是阻断a标签的<code>click</code>事件，在事件里面阻止<code>&lt;a&gt;</code>标签的默认行为，修改为我们的<code>router.navigate</code>行为。例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).on(<span class="string">'click'</span>, <span class="string">'a'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> href = $(<span class="keyword">this</span>).prop(<span class="string">'href'</span>);</span><br><span class="line">    href = href.slice(...) <span class="comment">// 去掉root部分</span></span><br><span class="line">    router.navigate(href, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果我们并不想这样处理所有的<code>&lt;a&gt;</code>标签，比如仍保留某些向服务器发送HTTP请求的功能。这可以通过有条件的选择，一个好的方式是把所有不期望向服务器发送请求的<code>&lt;a&gt;</code>标签的href都以<code>&#39;#&#39;</code>开头，否则则认为向服务器发送请求。此时阻断代码可以写成如下的样子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).on(<span class="string">'click'</span>, <span class="string">'a[href*="#"]'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> href = $(<span class="keyword">this</span>).prop(<span class="string">'href'</span>);</span><br><span class="line">    href = href.slice(...) <span class="comment">// 去掉root部分</span></span><br><span class="line">    router.navigate(href, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>点击下面的链接及浏览器的前进后退按钮查看运行效果：</p>
<p><base href="/2015/08/09/Backbone-router-demo/"></p>
<div id="demo"><br>  <a href="#help">help</a><br>  <a href="#search/myquery">search “myquery”</a><br>  <a href="#search/myquery/page1">search “myquery/page1”</a><br><br>  <script src="http://cdn.staticfile.org/jquery/2.1.1/jquery.min.js"></script><br>  <script src="http://cdn.staticfile.org/underscore.js/1.7.0/underscore-min.js"></script><br>  <script src="http://cdn.staticfile.org/backbone.js/1.1.2/backbone-min.js"></script><br>  <script src="/assets/backbone-router-demo.js"></script><br></div>]]></content>
    <summary type="html">
    <![CDATA[<p>这是一个简单的关于Backbone router的演示，下面的例子演示了，通过Backbone的router和pushState来达到省略URL中的Hash符号的目的。</p>
<p>首先定义一个App需要的router，例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> AppRouter = Backbone.Router.extend(&#123;  </span><br><span class="line">    routes : &#123;  </span><br><span class="line">        <span class="string">'help'</span>: <span class="string">'help'</span>,  </span><br><span class="line">        <span class="string">'search/:query'</span>: <span class="string">'search'</span>, </span><br><span class="line">        <span class="string">'search/:query/:page'</span>: <span class="string">'search'</span></span><br><span class="line">    &#125;,   </span><br><span class="line"></span><br><span class="line">    search: <span class="function"><span class="keyword">function</span>(<span class="params">query, page</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (page == <span class="literal">null</span>) &#123;</span><br><span class="line">          alert(<span class="string">'query: '</span> + query);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          alert(<span class="string">'query: '</span> + query + <span class="string">', page: '</span> + page);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="Backbone" scheme="http://blog.liushuping.com/tags/Backbone/"/>
    
      <category term="Route" scheme="http://blog.liushuping.com/tags/Route/"/>
    
      <category term="Backbone" scheme="http://blog.liushuping.com/categories/Backbone/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode OJ 238 Product of Array Except Self]]></title>
    <link href="http://blog.liushuping.com/2015/07/26/LeetCode-OJ-238-Product-of-Array-Except-Self/"/>
    <id>http://blog.liushuping.com/2015/07/26/LeetCode-OJ-238-Product-of-Array-Except-Self/</id>
    <published>2015-07-26T14:17:39.000Z</published>
    <updated>2015-10-25T10:41:23.000Z</updated>
    <content type="html"><![CDATA[<p>给定一个有<code>n</code>个元素且<code>n</code>大于<code>1</code>的一维数组<code>nums</code>，计算并返回一个数组<code>output</code>，使其任一元素<code>output[i]</code>的值是数组<code>nums</code>除<code>nums[i]</code>外的其它所有元素的乘积。要求不能使用除法，且在<code>O(n)</code>的时间复杂度和常数空间复杂度内完成计算。</p>
<p>例如，给定数组<code>[1,2,3,4]</code>，则返回数组<code>[24,12,8,6]</code></p>
<p>注：返回数组所占空间不在本题的空间复杂度的计算范围内。</p>
<a id="more"></a>
<h2 id="问题分析">问题分析</h2><p>按照常规的思维，最直接的计算方式是先对所有元素乘积，然后分别除以数组中的每个元素，其复杂度也在O(n)内。不幸的是，题目要求不能使用除法。然而我们可以从这个思路中尝试分析其它的解决方案。</p>
<p>首先，假设数组的n个元素分别为：a1, a2, a3, … an, 令P = a1 <em> a2 </em> a3 <em> … an,所以目标结果数组应为P/a1, P/a2, P/a3, … P/an。约掉分母可得：a2</em>a3<em>…an, a1</em>a3<em>…an, … a1</em>a2*…a(n-1).对结果数组的每一个元素的乘法进行分组可得如下形式：</p>
<p>(1) <em>* (a2</em>a3*…an)</p>
<p>(a1) <em>* (a3</em>a4*…an)</p>
<p>(a1<em>a2) </em> (a4<em>a5</em>…an)</p>
<p>(a1<em>a2</em>…a(n-2)) * (an)</p>
<p>(a1<em>a2</em>…a(n-1)) * (1)</p>
<p>以垂直方向看，左侧括号内部分是a1一直到a(n-1)的阶乘，而以垂直方向逆序来看，右侧括号内部分是an到a2的阶乘。 因此问题迎刃而解，可以用两个循环来迭代阶乘，也可以用一个循环分别从首尾迭代两组阶乘。</p>
<h2 id="代码">代码</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        // 两个迭代变量，t1从数组低位</span><br><span class="line">        // 向高位迭代；t2从数组高位</span><br><span class="line">        // 向低位迭代。</span><br><span class="line">        int t1(1), t2(1);</span><br><span class="line"></span><br><span class="line">        // 缓存数组的长度</span><br><span class="line">        int size(nums.size());</span><br><span class="line"></span><br><span class="line">        // 初始化返回数组的所有元素为 1</span><br><span class="line">        vector&lt;int&gt; result(size, 1);</span><br><span class="line"></span><br><span class="line">        // 做(数组长度-1)次数的迭代</span><br><span class="line">        for (int i(1); i &lt; size; ++i) &#123;</span><br><span class="line">            // 通过迭代来达到如下赋值</span><br><span class="line">            // result(i) &lt;- ProductOf(nums(0), nums(1) ... nums(i-1))</span><br><span class="line">            // 即返回数组的第i个元素的值等于输入数组的前i个元素的乘积。</span><br><span class="line">            t1 *= nums[i - 1];</span><br><span class="line">            result[i] *= t1;</span><br><span class="line"></span><br><span class="line">            // 在t1迭代计算的结果基础上，t2以反方向进行与t1完全类似的计算，</span><br><span class="line">            // 把计算结果累积乘积到输出数组上。</span><br><span class="line">            t2 *= nums[size - i];</span><br><span class="line">            result[size - 1 - i] *= t2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>给定一个有<code>n</code>个元素且<code>n</code>大于<code>1</code>的一维数组<code>nums</code>，计算并返回一个数组<code>output</code>，使其任一元素<code>output[i]</code>的值是数组<code>nums</code>除<code>nums[i]</code>外的其它所有元素的乘积。要求不能使用除法，且在<code>O(n)</code>的时间复杂度和常数空间复杂度内完成计算。</p>
<p>例如，给定数组<code>[1,2,3,4]</code>，则返回数组<code>[24,12,8,6]</code></p>
<p>注：返回数组所占空间不在本题的空间复杂度的计算范围内。</p>]]>
    
    </summary>
    
      <category term="Array" scheme="http://blog.liushuping.com/tags/Array/"/>
    
      <category term="LeetCode" scheme="http://blog.liushuping.com/categories/LeetCode/"/>
    
      <category term="Algorithm" scheme="http://blog.liushuping.com/categories/LeetCode/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[NFC SIM卡的尴尬]]></title>
    <link href="http://blog.liushuping.com/2015/07/22/NFC-SIM%E5%8D%A1%E7%9A%84%E5%B0%B4%E5%B0%AC/"/>
    <id>http://blog.liushuping.com/2015/07/22/NFC-SIM卡的尴尬/</id>
    <published>2015-07-22T15:50:39.000Z</published>
    <updated>2015-10-25T10:41:38.000Z</updated>
    <content type="html"><![CDATA[<p>近日NFC又一次出现在新闻中，如<em>今日头条</em>的<a href="http://toutiao.com/a4762553742/" target="_blank" rel="external">千万不要忽略了手机上NFC功能，你会后悔的</a>。我终于觉得有必要介绍一下自己几个月来NFC使用的体验了。</p>
<p>首先，NFC是一项重要的技术，在我们的日常生活中扮演着重要的作用。公交，地铁，饭卡等等很多近距离通信设备都是使用的NFC技术。</p>
<p>手机在我们的日常生活中同样扮演着越来越重要的作用，智能手机已成为大多数人时刻带在身上的设备，甚至包含上厕所的时间。因此，让手机具备NFC的功能也就是理所应该的了。在现阶段，具备NFC功能的手机还需要一张NFC SIM卡，这也是可以理解的。然而在使用了几个月的手机NFC功能后，其中的尴尬还是不少的。</p>
<a id="more"></a>
<h2 id="NFC标签">NFC标签</h2><p>听起来很酷炫的功能，但目前阶段看来，除了炫耀一下似乎没有什么其它务实的应用场景。然而，当把手机和钱包放在一起时，麻烦也便来了: 钱包里通常放各种银行卡，会员卡等等，或多或少的总有那么一两张卡有NFC功能。所以，当手机和钱包在一起时，手机立马会跳出对话框询问用什么程序访问当前NFC设备，并伴随着声音的提示。 然而多数时候我们并无此意，仅仅是把两者放在一起而已。什么？你问我为什么把手机和钱包放在一起？当两者变成人们寸步不离的个人物品时，放在一起的机会总是很多的。</p>
<h2 id="NFC乘坐公交地铁">NFC乘坐公交地铁</h2><p>此处下所述都是我在北京交通的体会，不代表其它城市的状态。先来一句猜测性的话阐述观点：北京的公交和地铁读卡设备在投入生产之前可能没有对非公交卡片之外的其它设备做足够的质量验收测试(仅代表个人猜测)。</p>
<p><strong>先说地铁</strong></p>
<p>几个月的使用体验结论是：地铁的读卡设备比公交上的读卡设备迟钝，且容易出错。当我以帅气的姿势在闸机上刷手机并期待吸引目光的时候，通常会有很大几率(大概三分之一吧)把自己陷入尴尬的境地：机器会无情地回以尖锐的错误声音，错误通常有以下几类：</p>
<ol>
<li>无效的卡片</li>
<li>错误，多张卡片</li>
<li>错误，0x12cf02…</li>
</ol>
<p>此刻只能尴尬地漫无目的地在手机上操作一番，然后重试。幸运的是通常重试后会成功，且地铁内有足够的空闲闸机及时间供我重试。</p>
<p><strong>再说公交</strong> </p>
<p>前面说了，地铁的读卡设备没有公交的读卡设备敏感，是不是说公交上就没问题了呢？恰恰相反，公交上容易造成多扣票款(在几个月的使用中，地铁没却发生过)，粗略估计有五分之一的概率发生吧。</p>
<p>这要从手机刷公交的“姿势”说起。不同于地铁闸机的刷卡处是一个倾斜的台面，公交的刷卡设备大多悬空且表面垂直于地面。因此，需要把公交卡贴近刷卡，这对有韧性的塑料卡来说不是难事。然而，用手机刷的体验就大不相同了。手机不具备韧性(什么？柔性屏？呵呵)，且手机有比较大的质量，比较大的体积(大屏手机变为主流), 还有手机卡在手机内部因此拉大了刷卡的距离。这些都要求手机刷公交要有一定的“姿势”，且要在人流拥挤，空间狭窄的公交车上，更要命的是后面的乘客还看着你并等着你，给你无形中造成了压力。好吧，在这些压力下，你的手在刷手机的时候抖了一下，或者是你觉得刷的“姿势”不对，微微地调节了一下。清脆的刷卡成功声音响起，然而在未来得及高兴前，你却听到了紧接着的第二声响起。这就是敏感的设备在你手抖的那一瞬间两次读取了你的卡，并扣取了你的钱。</p>
<p>第二天，面对公交拥挤的人群，狭小的空间，担心着手机掉落的可能，颤抖着双手刷下去了手机。</p>
<p>滴-滴。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>近日NFC又一次出现在新闻中，如<em>今日头条</em>的<a href="http://toutiao.com/a4762553742/">千万不要忽略了手机上NFC功能，你会后悔的</a>。我终于觉得有必要介绍一下自己几个月来NFC使用的体验了。</p>
<p>首先，NFC是一项重要的技术，在我们的日常生活中扮演着重要的作用。公交，地铁，饭卡等等很多近距离通信设备都是使用的NFC技术。</p>
<p>手机在我们的日常生活中同样扮演着越来越重要的作用，智能手机已成为大多数人时刻带在身上的设备，甚至包含上厕所的时间。因此，让手机具备NFC的功能也就是理所应该的了。在现阶段，具备NFC功能的手机还需要一张NFC SIM卡，这也是可以理解的。然而在使用了几个月的手机NFC功能后，其中的尴尬还是不少的。</p>]]>
    
    </summary>
    
      <category term="Mobile" scheme="http://blog.liushuping.com/tags/Mobile/"/>
    
      <category term="NFC" scheme="http://blog.liushuping.com/tags/NFC/"/>
    
      <category term="New Tech" scheme="http://blog.liushuping.com/categories/New-Tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode OJ 234 Palindrome Linked List]]></title>
    <link href="http://blog.liushuping.com/2015/07/22/LeetCode-OJ-234-Palindrome-Linked-List/"/>
    <id>http://blog.liushuping.com/2015/07/22/LeetCode-OJ-234-Palindrome-Linked-List/</id>
    <published>2015-07-22T14:35:42.000Z</published>
    <updated>2015-10-25T10:40:01.000Z</updated>
    <content type="html"><![CDATA[<p>在时间复杂度为O(n),空间复杂度为O(1)的范围内，判断一个给定的单向列表是否为<a href="https://en.wikipedia.org/wiki/Palindrome" target="_blank" rel="external">回文</a>。</p>
<h2 id="问题分析">问题分析</h2><p>O(n)时间复杂度要求对链表全遍历(即访问一次链全部元素)的次数应为固定常数次，不应随链表长度的变化而变化；O(1)的空间复杂度要求额外定义的变量应为常数个，而不应随链表长度的变化而变化。</p>
<p>而对于回文的判定，唯一的办法是依次以中间对称的方式对比左右每个元素的值。通常在做算法题，或者有良好软件工程的程序人员都会“潜在地”去保持一些良好的习惯，或遵守某些常见的约定。比如“判断某链表是否某某结构”，“某树形数据结构是否符合某某结构”等等问题，有良好习惯的程序员会尽量保持函数不修改要判断的数据结构。然后，诸如本题目之类则是对优秀程序员的一种“伤害”，因为在不修改数据结构的前提下，可能无法在要求的复杂度内完成任务。但是，出题者一点小小的改进，例如在题目中提及一下数据结构或内容允许被修改，则既可保持程序题目的趣味性，又避免了程序员对题目要求的种种猜测。</p>
<p>在明确了链表的结构可被修改的前提下，问题的解决方案便可很容易分析得出：主体思路是修改链表的前或后半部分，使其链表内节点指向相反方向，然后依次对比前半部分和后半部分链表各个节点。 因此关键点是如何逆序重组链表的一半？有很多方案，例如以下：</p>
<ol>
<li>方案一：第一遍循环定位出中间节点(注意偶数和奇数节点总数的细微差别)，然后以中间节点为起点(链表后半部分)或为终点(链表前半部分)逆序重组链表的一半。依次对比链表前后部分的各个节点。</li>
<li>方案二：定义快慢两个指针，分别对应移动2步和1步。当快指针结束遍历链表时，慢指针位于链表中间。然后逆序重组从慢指针至链表结尾的节点。依次对比链表前后部分的各个节点。</li>
</ol>
<a id="more"></a>
<p>以下示例代码采取了第二种方案.</p>
<h2 id="代码">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *t, *t1, *t2;</span><br><span class="line">        t1 = head;</span><br><span class="line">        t2 = head; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 快指针遍历整个链表后，</span></span><br><span class="line">        <span class="comment">// 慢指针停留在中间节点</span></span><br><span class="line">        <span class="keyword">while</span>(t2)&#123;</span><br><span class="line">            t2 = t2-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (t2) </span><br><span class="line">                t2 = t2-&gt;next;</span><br><span class="line">            t1 = t1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 以慢指针(中间节点)为开始</span></span><br><span class="line">        <span class="comment">// 逆序重组后续节点</span></span><br><span class="line">        <span class="comment">// t用来辅助交换指针</span></span><br><span class="line">        <span class="keyword">while</span>(t1) &#123;</span><br><span class="line">            t = t1;</span><br><span class="line">            t1 = t1-&gt;next;</span><br><span class="line">            t-&gt;next = t2;</span><br><span class="line">            t2 = t;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 重组完成后，t2指向后半部分链表</span></span><br><span class="line">        <span class="comment">// 的开始， 而重新置t1于原始链表</span></span><br><span class="line">        <span class="comment">// 的头部， 并开始比较各个节点</span></span><br><span class="line">        t1 = head;</span><br><span class="line">        <span class="keyword">while</span>(t2 &amp;&amp; t1) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t1-&gt;val != t2-&gt;val)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            t1 = t1-&gt;next;</span><br><span class="line">            t2 = t2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>在时间复杂度为O(n),空间复杂度为O(1)的范围内，判断一个给定的单向列表是否为<a href="https://en.wikipedia.org/wiki/Palindrome">回文</a>。</p>
<h2 id="问题分析">问题分析</h2><p>O(n)时间复杂度要求对链表全遍历(即访问一次链全部元素)的次数应为固定常数次，不应随链表长度的变化而变化；O(1)的空间复杂度要求额外定义的变量应为常数个，而不应随链表长度的变化而变化。</p>
<p>而对于回文的判定，唯一的办法是依次以中间对称的方式对比左右每个元素的值。通常在做算法题，或者有良好软件工程的程序人员都会“潜在地”去保持一些良好的习惯，或遵守某些常见的约定。比如“判断某链表是否某某结构”，“某树形数据结构是否符合某某结构”等等问题，有良好习惯的程序员会尽量保持函数不修改要判断的数据结构。然后，诸如本题目之类则是对优秀程序员的一种“伤害”，因为在不修改数据结构的前提下，可能无法在要求的复杂度内完成任务。但是，出题者一点小小的改进，例如在题目中提及一下数据结构或内容允许被修改，则既可保持程序题目的趣味性，又避免了程序员对题目要求的种种猜测。</p>
<p>在明确了链表的结构可被修改的前提下，问题的解决方案便可很容易分析得出：主体思路是修改链表的前或后半部分，使其链表内节点指向相反方向，然后依次对比前半部分和后半部分链表各个节点。 因此关键点是如何逆序重组链表的一半？有很多方案，例如以下：</p>
<ol>
<li>方案一：第一遍循环定位出中间节点(注意偶数和奇数节点总数的细微差别)，然后以中间节点为起点(链表后半部分)或为终点(链表前半部分)逆序重组链表的一半。依次对比链表前后部分的各个节点。</li>
<li>方案二：定义快慢两个指针，分别对应移动2步和1步。当快指针结束遍历链表时，慢指针位于链表中间。然后逆序重组从慢指针至链表结尾的节点。依次对比链表前后部分的各个节点。</li>
</ol>]]>
    
    </summary>
    
      <category term="Linked List" scheme="http://blog.liushuping.com/tags/Linked-List/"/>
    
      <category term="Two Pointers" scheme="http://blog.liushuping.com/tags/Two-Pointers/"/>
    
      <category term="LeetCode" scheme="http://blog.liushuping.com/categories/LeetCode/"/>
    
      <category term="Algorithm" scheme="http://blog.liushuping.com/categories/LeetCode/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[基于NodeJS的ASCII树形文本生成模块]]></title>
    <link href="http://blog.liushuping.com/2015/07/21/generate-ascii-tree-from-input-string-with-node/"/>
    <id>http://blog.liushuping.com/2015/07/21/generate-ascii-tree-from-input-string-with-node/</id>
    <published>2015-07-21T14:51:16.000Z</published>
    <updated>2015-10-25T10:38:56.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://blog.liushuping.com/ascii-tree/">Ascii-tree</a>是一个简单的NodeJS模块，用来对指定格式的输入文本输出树形结构的ASCII文本。指定格式的输入文本要求每一个节点都要以一定数量的引导字符开始，根节点以1个引导字符开始；子节点引导字符以此类推，如下列输入文本：<br><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="special">#</span>root node<span class="command">\r</span><span class="command">\n</span><span class="special">#</span><span class="special">#</span>node1<span class="command">\r</span><span class="command">\n</span><span class="special">#</span><span class="special">#</span><span class="special">#</span><span class="command">\r</span><span class="command">\nnode</span>1<span class="command">\r</span><span class="command">\n</span><span class="special">#</span><span class="special">#</span>node2</span><br></pre></td></tr></table></figure></p>
<p>代表的是这样的一段ASCII树形文本：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root <span class="keyword">node</span><span class="identifier"></span><br><span class="line"></span><span class="title">├─ node1</span></span><br><span class="line">│  └─ node11</span><br><span class="line">└─ node2</span><br></pre></td></tr></table></figure></p>
<p><a href="http://blog.liushuping.com/ascii-tree/">Ascii-tree</a>就是这样的一个基于Node的ASCII Tree生成模块。链接：<a href="http://blog.liushuping.com/ascii-tree/">http://blog.liushuping.com/ascii-tree/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://blog.liushuping.com/ascii-tree/">Ascii-tree</a>是一个简单的NodeJS模块，用来对指定格式的输入文本输出树形结构的ASCII文本。指定格式的输入文本要求每一个节点都要以一定数量的引导字符开始，根]]>
    </summary>
    
      <category term="ASCII" scheme="http://blog.liushuping.com/tags/ASCII/"/>
    
      <category term="Node" scheme="http://blog.liushuping.com/tags/Node/"/>
    
      <category term="Tree" scheme="http://blog.liushuping.com/tags/Tree/"/>
    
      <category term="Ascii-tree" scheme="http://blog.liushuping.com/categories/Ascii-tree/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在Ubuntu15上用squid3部署HTTP代理]]></title>
    <link href="http://blog.liushuping.com/2015/07/21/setup-HTTP-proxy-server-with-squid3/"/>
    <id>http://blog.liushuping.com/2015/07/21/setup-HTTP-proxy-server-with-squid3/</id>
    <published>2015-07-21T13:06:59.000Z</published>
    <updated>2015-10-25T10:42:14.000Z</updated>
    <content type="html"><![CDATA[<p>Squid3 是一个简单易用、功能强大的HTTP代理软件，本文简要介绍了在Ubuntu 15.04上安装squid3以及基本配置的步骤。</p>
<h2 id="安装">安装</h2><p>通过命令<code>$ sudo apt-get install squid3</code>可以很方便地安装squid3,如下图：<br><img src="http://78rehp.com1.z0.glb.clouddn.com/blog/squid3-install-1.png" alt="squid 3安装"></p>
<a id="more"></a>
<h2 id="检查安装">检查安装</h2><p>通过<code>$ whereis squid3</code>命令来确认一下squid3是否已经安装正确：<br><img src="http://78rehp.com1.z0.glb.clouddn.com/blog/squid3-whereis.png" alt="whereis squid3"><br>正确安装后的squid3应该出现路径<code>/etc/squid3</code>。如果没有发现可以尝试重启系统后重新检查一下。</p>
<h2 id="代理配置">代理配置</h2><p>squid3提供了丰富的配置项，<code>/etc/squid3/squid.conf</code>文件内注释有每一个选项的作用。</p>
<h3 id="配置端口号">配置端口号</h3><p>squid3默认接受3128端口号，可以通过在文件<code>squid.conf</code>中添加<code>http_port &lt;port&gt;</code>来改变这个端口号:<br><img src="http://78rehp.com1.z0.glb.clouddn.com/blog/squid-edit-conf-2.png" alt="squid3 http_port"></p>
<h3 id="配置信任的客户端">配置信任的客户端</h3><p>在未配置信任客户端的情况下，squid3是不接受任何连接的。最简单的方案是接受任何客户端的请求，这可以通过添加<code>http_access allow all</code>选项来实现：<br><img src="http://78rehp.com1.z0.glb.clouddn.com/blog/squid-edit-conf-3.png" alt="squid3 http_access allow all"></p>
<h3 id="基本的访问控制配置">基本的访问控制配置</h3><p><code>http_access allow all</code>规则允许所有连接的客户端访问，不能很好地控制用户的访问权限，也存在潜在的安全问题。一种方案是通过允许一定区段的IP地址访问，这可以通过在配置文件中定义一个值为一段IP的acl的变量，并通过<code>http_access</code>选项来对其授权：<br><img src="http://78rehp.com1.z0.glb.clouddn.com/blog/squid-edit-conf-4.png" alt="squid3 acl ip group"></p>
<p>另一种更加可靠的识别用户的方式是通过MAC地址来认证，示例命令如下：<br><img src="http://78rehp.com1.z0.glb.clouddn.com/blog/squid-edit-conf-5.png" alt="squid3 acl arp"></p>
<h2 id="squid3的启动与关闭">squid3的启动与关闭</h2><p>squid3的启动，关闭，重新启动的命令：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>sudo service squid3 start</span><br><span class="line"><span class="variable">$ </span>sudo service squid3 stop</span><br><span class="line"><span class="variable">$ </span>sudo service squid3 restart</span><br></pre></td></tr></table></figure></p>
<h2 id="参考引用">参考引用</h2><p>更多的squid3配置选项，及完整的说明文档，请参考：<a href="https://help.ubuntu.com/lts/serverguide/squid.html" target="_blank" rel="external">https://help.ubuntu.com/lts/serverguide/squid.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Squid3 是一个简单易用、功能强大的HTTP代理软件，本文简要介绍了在Ubuntu 15.04上安装squid3以及基本配置的步骤。</p>
<h2 id="安装">安装</h2><p>通过命令<code>$ sudo apt-get install squid3</code>可以很方便地安装squid3,如下图：<br><img src="http://78rehp.com1.z0.glb.clouddn.com/blog/squid3-install-1.png" alt="squid 3安装"></p>]]>
    
    </summary>
    
      <category term="HTTP" scheme="http://blog.liushuping.com/tags/HTTP/"/>
    
      <category term="Proxy" scheme="http://blog.liushuping.com/tags/Proxy/"/>
    
      <category term="Squid3" scheme="http://blog.liushuping.com/tags/Squid3/"/>
    
      <category term="Ubuntu" scheme="http://blog.liushuping.com/tags/Ubuntu/"/>
    
      <category term="HTTP" scheme="http://blog.liushuping.com/categories/HTTP/"/>
    
      <category term="Proxy" scheme="http://blog.liushuping.com/categories/HTTP/Proxy/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode OJ 235 Lowest Common Ancestor of a Binary Search Tree]]></title>
    <link href="http://blog.liushuping.com/2015/07/17/LeetCode-OJ-235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree/"/>
    <id>http://blog.liushuping.com/2015/07/17/LeetCode-OJ-235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree/</id>
    <published>2015-07-17T15:24:07.000Z</published>
    <updated>2015-10-25T10:40:43.000Z</updated>
    <content type="html"><![CDATA[<p>对于给定的一颗二叉查找树和其中的两个节点，找出它们的最低公共祖先（LCA）</p>
<p>根据<a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor" target="_blank" rel="external">Wikipedia对LCA的定义</a>：</p>
<blockquote>
<p>The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).</p>
</blockquote>
<p>也就说：最低公共祖先指的是在一颗树中，节点v和节点w的最低的公共节点。这里允许节点可以是它本身的祖先。</p>
<p>例如，在下面的二叉查找树中，节点2和8的最低公共祖先是6。而节点2和4的最低公共祖先是2（节点可以是它本身的祖先）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">        ______6_____</span><br><span class="line">       /                    \</span><br><span class="line">  ___2__            ___8__</span><br><span class="line"> /          \          /          \</span><br><span class="line"><span class="number">0</span>         _4_      <span class="number">7</span>           <span class="number">9</span></span><br><span class="line">          /     \</span><br><span class="line">         <span class="number">3</span>      <span class="number">5</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="问题分析">问题分析</h2><p>由于题目限定查找的范围是一颗二叉查找树，所以可以利用树的左侧值比右侧值小的这个特性来快速查找目标的最低公共祖先。具体可以分五步：</p>
<ol>
<li>若目标节点之一等同于root节点，则root为所求目标。</li>
<li>若两个目标节点重合，则目标节点为所求目标。</li>
<li>在不符合上述两种情况下，若两个目标节点的值都大于根节点值，则递归遍历右子树获得结果。</li>
<li>在不符合上述三种情况下，若两个目标节点的值都小于根节点值，则递归遍历左子树获得结果。</li>
<li>最后一种情况表明两个目标节点分布在根节点的左右两侧，因此根节点为最终结果。</li>
</ol>
<h2 id="代码">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (p == q) <span class="keyword">return</span> p;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (p-&gt;val &gt; root-&gt;val &amp;&amp; q-&gt;val &gt; root-&gt;val) </span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> (p-&gt;val &lt; root-&gt;val &amp;&amp; q-&gt;val &lt; root-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>对于给定的一颗二叉查找树和其中的两个节点，找出它们的最低公共祖先（LCA）</p>
<p>根据<a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor">Wikipedia对LCA的定义</a>：</p>
<blockquote>
<p>The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).</p>
</blockquote>
<p>也就说：最低公共祖先指的是在一颗树中，节点v和节点w的最低的公共节点。这里允许节点可以是它本身的祖先。</p>
<p>例如，在下面的二叉查找树中，节点2和8的最低公共祖先是6。而节点2和4的最低公共祖先是2（节点可以是它本身的祖先）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">        ______6_____</span><br><span class="line">       /                    \</span><br><span class="line">  ___2__            ___8__</span><br><span class="line"> /          \          /          \</span><br><span class="line"><span class="number">0</span>         _4_      <span class="number">7</span>           <span class="number">9</span></span><br><span class="line">          /     \</span><br><span class="line">         <span class="number">3</span>      <span class="number">5</span></span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="Tree" scheme="http://blog.liushuping.com/tags/Tree/"/>
    
      <category term="LeetCode" scheme="http://blog.liushuping.com/categories/LeetCode/"/>
    
      <category term="Algorithm" scheme="http://blog.liushuping.com/categories/LeetCode/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode OJ 236 Lowest Common Ancestor of a Binary Tree]]></title>
    <link href="http://blog.liushuping.com/2015/07/15/LeetCode-OJ-236-Lowest-Common-Ancestor-of-a-Binary-Tree/"/>
    <id>http://blog.liushuping.com/2015/07/15/LeetCode-OJ-236-Lowest-Common-Ancestor-of-a-Binary-Tree/</id>
    <published>2015-07-15T14:45:07.000Z</published>
    <updated>2015-10-25T10:40:56.000Z</updated>
    <content type="html"><![CDATA[<p>对于给定的一颗二叉树和其中的两个节点，找出它们的最低公共祖先（LCA）</p>
<p>根据<a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor" target="_blank" rel="external">Wikipedia对LCA的定义</a>：</p>
<blockquote>
<p>The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).</p>
</blockquote>
<p>也就说：最低公共祖先指的是在一颗树中，节点v和节点w的最低的公共节点。这里允许节点可以是它本身的祖先。</p>
<p>例如，在下面的树中，节点5和1的最低公共祖先是3。而节点4和5的最低公共祖先是5（节点可以是它本身的祖先）。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="cpp">     _______3______</span><br><span class="line">    /              \</span><br><span class="line"> ___5__          ___1__</span><br><span class="line">/      \        /      \</span><br><span class="line"><span class="number">6</span>      _2       <span class="number">0</span>       <span class="number">8</span></span><br><span class="line">      /  \</span><br><span class="line">      <span class="number">7</span>   <span class="number">4</span></span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="问题分析">问题分析</h2><p>该问题可以分为两个步骤来分析：1.遍历整棵树直到两个目标节点全部被发现； 2.从第二个节点被找到时刻开始回溯节点，一直到两个目标节点的第一个共同祖先为止。所以，问题的全部难点都集中在第二步中。</p>
<p>难点一：如何回溯？<br>事实上，对于递归函数，函数的每一次返回(return)都是一次弹“栈”的过程，也就是一次回溯的过程。</p>
<p>难点二：在回溯过程中，如何判断某个节点是两个目标节点的共同祖先？<br>在回溯到某一个节点时，计算该节点及所有子节点包含目标节点的个数，一旦达到两个则表明共同祖先节点找到。</p>
<p>计算过程：如果当前节点是两个目标节点中一个，则该节点值为1，用同样的道理计算该节点左右子树的值，最后加和即是该节点为根的树所包含目标节点的个数。</p>
<p>特殊情况：如果两个目标节点是同一个节点，那么它就是要求的最终节点。</p>
<h2 id="代码">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 存储最低公共祖先结果</span></span><br><span class="line">    TreeNode* result;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录在遍历树的过程中已经发现的目标节点个数</span></span><br><span class="line">    <span class="comment">// 当count == 2时，全部节点找到，停止遍历，</span></span><br><span class="line">    <span class="comment">// 开始回溯。计算回溯路径上每一个节点为根</span></span><br><span class="line">    <span class="comment">// 的子树所包含目标节点的个数，一旦达到2，则</span></span><br><span class="line">    <span class="comment">// 表明最低公共祖先找到。</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        tranverse(root, p, q);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">tranverse</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">	<span class="comment">// 标识当前节点是否是目标节点之一</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">mark</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (root == p) &#123;</span><br><span class="line">            <span class="comment">// 是目标节点之一</span></span><br><span class="line">            mark++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (root == q) &#123;</span><br><span class="line">            <span class="comment">// 是目标节点，且两个目标相同</span></span><br><span class="line">            mark++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (mark &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 两个目标全部找到，标识LCA</span></span><br><span class="line">            <span class="keyword">if</span> (result == <span class="literal">NULL</span>) result = root;</span><br><span class="line">            <span class="keyword">return</span> mark;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 继续遍历左子树</span></span><br><span class="line">        mark += tranverse(root-&gt;left, p, q);</span><br><span class="line">        <span class="keyword">if</span> (mark &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (result == <span class="literal">NULL</span>) result = root;</span><br><span class="line">            <span class="keyword">return</span> mark;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">	<span class="comment">// 继续遍历右子树</span></span><br><span class="line">        mark += tranverse(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">if</span> (mark &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (result == <span class="literal">NULL</span>) result = root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mark;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>对于给定的一颗二叉树和其中的两个节点，找出它们的最低公共祖先（LCA）</p>
<p>根据<a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor">Wikipedia对LCA的定义</a>：</p>
<blockquote>
<p>The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).</p>
</blockquote>
<p>也就说：最低公共祖先指的是在一颗树中，节点v和节点w的最低的公共节点。这里允许节点可以是它本身的祖先。</p>
<p>例如，在下面的树中，节点5和1的最低公共祖先是3。而节点4和5的最低公共祖先是5（节点可以是它本身的祖先）。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="cpp">     _______3______</span><br><span class="line">    /              \</span><br><span class="line"> ___5__          ___1__</span><br><span class="line">/      \        /      \</span><br><span class="line"><span class="number">6</span>      _2       <span class="number">0</span>       <span class="number">8</span></span><br><span class="line">      /  \</span><br><span class="line">      <span class="number">7</span>   <span class="number">4</span></span></span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="Tree" scheme="http://blog.liushuping.com/tags/Tree/"/>
    
      <category term="LeetCode" scheme="http://blog.liushuping.com/categories/LeetCode/"/>
    
      <category term="Algorithm" scheme="http://blog.liushuping.com/categories/LeetCode/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode OJ 237 - Delete Node in a Linked List]]></title>
    <link href="http://blog.liushuping.com/2015/07/15/LeetCode-OJ-237-Delete-Node-in-a-Linked-List/"/>
    <id>http://blog.liushuping.com/2015/07/15/LeetCode-OJ-237-Delete-Node-in-a-Linked-List/</id>
    <published>2015-07-15T14:00:32.000Z</published>
    <updated>2015-10-25T10:41:11.000Z</updated>
    <content type="html"><![CDATA[<p>给定一个链表中的某一个非末尾节点，要求实现一个函数把该节点从链表中删除。</p>
<p>例如有链表：1-&gt;2-&gt;3-&gt;4，且给定的是值为3的那个节点，要求调用该函数后，链表变为1-&gt;2-&gt;4</p>
<h2 id="问题分析">问题分析</h2><p>常见的链表节点删除问题是已知某节点的前继节点，通过设置前继节点的后续节点为目标节点的后续节点来到达删除该节点的目标。该题目无法得知目标节点的前继节点，因此该方法不可行。换一种思路，可以采取把目标节点的全部内容（value, next）修改为后续节点相同的内容，从而达到从链表中“删除”该节点的目的。</p>
<p>题目声明目标节点非末尾节点，因此函数无需对目标节点以及目标节点的直接后续节点做“非空”检查。事实上，在前继节点未知的情况下，是无法删除链表中最后一个节点的。</p>
<a id="more"></a>
<h2 id="代码">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 目标节点非末尾节点，因此目标节点及其后续</span></span><br><span class="line">        <span class="comment">// 节点无需做“非空”检查。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让目标节点的值等于其后续节点的值</span></span><br><span class="line">        node-&gt;val = node-&gt;next-&gt;val;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让目标节点的next值等于其后续节点的next值</span></span><br><span class="line">        node-&gt;next = node-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>给定一个链表中的某一个非末尾节点，要求实现一个函数把该节点从链表中删除。</p>
<p>例如有链表：1-&gt;2-&gt;3-&gt;4，且给定的是值为3的那个节点，要求调用该函数后，链表变为1-&gt;2-&gt;4</p>
<h2 id="问题分析">问题分析</h2><p>常见的链表节点删除问题是已知某节点的前继节点，通过设置前继节点的后续节点为目标节点的后续节点来到达删除该节点的目标。该题目无法得知目标节点的前继节点，因此该方法不可行。换一种思路，可以采取把目标节点的全部内容（value, next）修改为后续节点相同的内容，从而达到从链表中“删除”该节点的目的。</p>
<p>题目声明目标节点非末尾节点，因此函数无需对目标节点以及目标节点的直接后续节点做“非空”检查。事实上，在前继节点未知的情况下，是无法删除链表中最后一个节点的。</p>]]>
    
    </summary>
    
      <category term="Linked List" scheme="http://blog.liushuping.com/tags/Linked-List/"/>
    
      <category term="LeetCode" scheme="http://blog.liushuping.com/categories/LeetCode/"/>
    
      <category term="Algorithm" scheme="http://blog.liushuping.com/categories/LeetCode/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[javascript-how-do-you-check-types]]></title>
    <link href="http://blog.liushuping.com/2014/08/25/javascript-how-do-you-check-types/"/>
    <id>http://blog.liushuping.com/2014/08/25/javascript-how-do-you-check-types/</id>
    <published>2014-08-25T15:13:17.000Z</published>
    <updated>2015-10-25T10:36:18.000Z</updated>
    <content type="html"><![CDATA[<p>JavaScript的数据是动态类型，运行时可以动态改变变量的数据类型。然而程序中仍然有很多情况需要判断当前变量的数据类型。那么有什么有效的方法吗？</p>
<p>JavaScript中数据类型有<code>String</code>, <code>Number</code>, <code>Boolean</code>, <code>Array</code>, <code>Object</code> 和<code>undefined</code>类型。另外，正则表达式类型<code>RegExp</code>，<code>Function</code>类型和时间类型<code>Date</code>也是常见的类型。因此，我们希望能对一个变量正确地检查出这些类型。</p>
<a id="more"></a>
<h2 id="typeof">typeof</h2><p><code>typeof</code> 是JavaScript的关键字，能检查出给定变量的类型。对上述类型用<code>typeof</code>做一个测试：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">123</span> <span class="comment">//"number"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">'abc'</span> <span class="comment">//"string"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> <span class="comment">//"boolean"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="comment">//"object"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">//"undefined"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> (<span class="keyword">new</span> <span class="built_in">Date</span>) <span class="comment">//"object"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Function</span> <span class="comment">//"function"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> /abc/ <span class="comment">//"object"</span></span><br></pre></td></tr></table></figure></p>
<p>因此，不难看出<code>typeof</code>能很好的识别出<code>Number</code>, <code>String</code>, <code>Boolean</code>和<code>undefined</code>类型（输出的类型名都为小写），而对于复合类型都输出<code>object</code>。对复合类型的输出虽然正确，但不能准确定位具体类型。</p>
<h2 id="toString-NaN">toString</h2><p><code>toString</code>这儿指的是全局的函数，在浏览器中是<code>window.toString</code>，在node.js中指的是<code>global.toString</code>。对目标变量运行toString也能打印它的数据类型，测试如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">toString.call(<span class="number">123</span>); <span class="comment">//"[object Number]"</span></span><br><span class="line"></span><br><span class="line">toString.call(<span class="string">'abc'</span>); <span class="comment">//"[object String]"</span></span><br><span class="line"></span><br><span class="line">toString.call(<span class="literal">true</span>); <span class="comment">//"[object Boolean]"</span></span><br><span class="line"></span><br><span class="line">toString.call([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">//"[objet Array]"</span></span><br><span class="line"></span><br><span class="line">toString.call(<span class="literal">undefined</span>); <span class="comment">//"[object Undefined]"</span></span><br><span class="line"></span><br><span class="line">toString.call(<span class="keyword">new</span> <span class="built_in">Date</span>); <span class="comment">//"[object Date]"</span></span><br><span class="line"></span><br><span class="line">toString.call(<span class="built_in">Function</span>); <span class="comment">//"[object Function]"</span></span><br><span class="line"></span><br><span class="line">toString.call(<span class="regexp">/abc/</span>); <span class="comment">//"[object RegExp]"</span></span><br></pre></td></tr></table></figure></p>
<p>因此，<code>toString</code>能更好地检测数据的类型。</p>
<p>那么对于自定义的数据类型<code>typeof</code>和<code>toString</code>能给出什么结果呢？假设有如下自定义数据类型<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyObject</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'MyObject'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>typeof</code>和<code>toString</code>的检测结果是<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> MyObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> obj; <span class="comment">//"object"</span></span><br><span class="line"></span><br><span class="line">toString.call(obj); <span class="comment">//"[object Object]"</span></span><br></pre></td></tr></table></figure></p>
<p>因此，对于自定义类型， <code>typeof</code>和<code>toString</code>都不能满足我们的需求。</p>
<h2 id="instanceof">instanceof</h2><p>对于检测自定义类型，使用<code>instanceof</code>是一个有效的方法，它能判断给定的数据是否是某一类型的一个实例。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> MyObject;</span><br><span class="line"></span><br><span class="line">obj <span class="keyword">instanceof</span> MyObject; <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<h2 id="oftype-js">oftype.js</h2><p><code>oftype.js</code>是一个简单小巧的检查JavaScript变量运行时的库，在node.js中通过命令<code>npm install oftype</code>安装。通过下面的代码来检查变量类型：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oftype = <span class="built_in">require</span>(<span class="string">'oftype'</span>);</span><br><span class="line">oftype(some_var, EXPECTED_TYPE);</span><br></pre></td></tr></table></figure></p>
<p>例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oftype = <span class="built_in">require</span>(<span class="string">'oftype'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">123</span>;</span><br><span class="line">oftype(x, <span class="built_in">Number</span>); <span class="comment">//true;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> y = <span class="string">'abc'</span>;</span><br><span class="line">oftype(y, <span class="built_in">String</span>); <span class="comment">//true;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> z = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">oftype(z, <span class="built_in">Date</span>); <span class="comment">//true;</span></span><br></pre></td></tr></table></figure></p>
<p>对于自定义类型数据也可以检查，例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyObj</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'ABC'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oftype = <span class="built_in">require</span>(<span class="string">'oftype'</span>);</span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> MyObj();</span><br><span class="line"></span><br><span class="line">oftype(x, MyObject); <span class="comment">//true;</span></span><br></pre></td></tr></table></figure></p>
<p><code>undefined</code>和<code>null</code>是两个特殊的类型，<code>undefined</code>是一个类型标识符，该类型只有一个值，也就是其本身<code>undefined</code>. 因此对<code>undefined</code>的类型检查有如下代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">var</span> oftype = <span class="built_in">require</span>(<span class="string">'oftype'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅在x是undefined的情况下返回true</span></span><br><span class="line">oftype(x, <span class="literal">undefined</span>); <span class="comment">//true;</span></span><br></pre></td></tr></table></figure></p>
<p><code>null</code>是一个特殊的值，不属于任何类型，所以检查它的代码应该是如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> oftype = <span class="built_in">require</span>(<span class="string">'oftype'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅在x是null的情况下返回true</span></span><br><span class="line">oftype(x, <span class="literal">null</span>); <span class="comment">//true;</span></span><br></pre></td></tr></table></figure></p>
<p>然而，有时我们希望null是Object类型的一个特殊值，因此可以加一个参数<code>nullAsObject: true</code>到函数调用中：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> oftype = <span class="built_in">require</span>(<span class="string">'oftype'</span>);</span><br><span class="line"></span><br><span class="line">oftype(x, <span class="built_in">Object</span>); <span class="comment">//false;</span></span><br><span class="line">oftye(x, <span class="built_in">Object</span>, &#123;nullAsObject: <span class="literal">true</span>&#125;); <span class="comment">//true;</span></span><br></pre></td></tr></table></figure></p>
<p>更多的时候，我们可能希望一次设置参数后，整个程序能检测<code>null</code>为<code>Object</code>类型，而不需要每次函数调用都给传参数。这时，可以通过设置<code>oftype</code>的全局参数来实现:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oftype = <span class="built_in">require</span>(<span class="string">'oftype'</span>);</span><br><span class="line">oftype.nullAsObject = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> y = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">oftype(x, <span class="built_in">Object</span>); <span class="comment">//true;</span></span><br><span class="line">oftype(y, <span class="built_in">Object</span>); <span class="comment">//true;</span></span><br></pre></td></tr></table></figure></p>
<p>参数<code>nullAsObject</code>的默认值是<code>false</code></p>
<p>值得一提的是，原始数据类型（primitive types）的声明有两种方式：字面量（literal）和构造函数方式。理论上，通过构造函数构造的原始类型归属Object类型。然而这种情况下我们仍然期望它是原始数据类型。这时可以通过<code>primitiveObject</code>参数来控制：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oftype = <span class="built_in">require</span>(<span class="string">'oftype'</span>);</span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">oftype(x, <span class="built_in">Number</span>, &#123;primitiveObject: <span class="literal">true</span>&#125;); <span class="comment">//true;</span></span><br></pre></td></tr></table></figure></p>
<p>同<code>nullObject</code>参数类似，这个参数也可以全局设置。这个参数的默认值是<code>true</code>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>JavaScript的数据是动态类型，运行时可以动态改变变量的数据类型。然而程序中仍然有很多情况需要判断当前变量的数据类型。那么有什么有效的方法吗？</p>
<p>JavaScript中数据类型有<code>String</code>, <code>Number</code>, <code>Boolean</code>, <code>Array</code>, <code>Object</code> 和<code>undefined</code>类型。另外，正则表达式类型<code>RegExp</code>，<code>Function</code>类型和时间类型<code>Date</code>也是常见的类型。因此，我们希望能对一个变量正确地检查出这些类型。</p>]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.liushuping.com/tags/JavaScript/"/>
    
      <category term="JavaScript" scheme="http://blog.liushuping.com/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[抽象的思考]]></title>
    <link href="http://blog.liushuping.com/2014/08/19/think-in-abstraction/"/>
    <id>http://blog.liushuping.com/2014/08/19/think-in-abstraction/</id>
    <published>2014-08-19T13:12:02.000Z</published>
    <updated>2015-10-25T10:35:56.000Z</updated>
    <content type="html"><![CDATA[<p>抽象是人类在解决复杂问题，尤其是逻辑相关问题时的一个强有力的工具。在今天，在计算机科学和软件工程领域里，抽象更是解决复杂系统的有力方法之一。没有抽象，就不可能有今天众多复杂软件的产生。</p>
<p>人类文明的发展，少不了抽象的重要作用。比如人类数字的发明就是一个重要的抽象。数字是什么？是一种物体吗？当然不是。那么是一种精神状态吗？也不是。它是一个符号，一个代表了某种抽象逻辑的符号。那么这种抽象逻辑是什么？不难得出，代表的是对某种事物的数量计数的一种逻辑。之所以叫抽象逻辑，是因为它并不关心被计数的是什么具体事物，事实上它更像一种“模板”可以应用到任何事物上。</p>
<p>近日学习<a href="http://book.douban.com/subject/1148282/" target="_blank" rel="external">《计算机程序的构造和解释》</a>一书，对抽象有了些许进一步的理解，在此从计算机程序的角度上，以数字的表示这个例子对抽象的力量做一下不全面的分析。</p>
<a id="more"></a>
<h2 id="由数数想到的">由数数想到的</h2><p>在中文里对事物的计数过程叫做“数数”。其中第一个“数”指的是计数这个动作；第二个“数”指的是标识事物量的一个符号。前后是两个相同的“数”字，难道是在“暗示”着什么吗？仔细思考，不禁感叹汉字的博大精神及其蕴含的深刻思想。</p>
<p>以计算机程序的观点来看，计数的这个动作可以叫做过程，而标识事物量的这个数可以叫做数字或数据。那么从两个“数”子相同的这个现象来看，过程和数据是两个完全不同的概念吗？两者有严格的界限吗？或者是一者可以表示另一者？</p>
<h2 id="再回到“数”上">再回到“数”上</h2><p>姑且不论这里讨论的“数”是计数还是“数量”，先看一下这个概念被提出的原因。人类祖先为了解决统计同类事物量的难题，使用了很多方法，比如可以堆石块，或者用树枝在地面上画线。其目的都是为了使人看到它后还能还原做同样的“数”的过程。因此，是否可以说“数”的过程就在一定范畴内代表了“数”这个数据的意思？或者说过程和数据本来界限就很模糊？</p>
<h2 id="“数”在程序中的过程表示">“数”在程序中的过程表示</h2><p>应该是所有的计算机语言都有内在的对数字的符号表示，即默认都识别1，2，100 等符号。现在假如程序语言本身没定义数字，那么有什么方法表示吗？假如讨论的范围是非负整数。</p>
<p>让我们抛弃过程和数据之间有明显界限的偏见。根据前面的分析，为实现表示一个数字的目的，只要能达到还原一个“计数”的过程即可。现在令“计数”的这个过程叫<code>f</code>，假如某个事物是<code>x</code>，因此<code>1</code>可以表示为如下对事物<code>x</code>的一次计数过程：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f</span> x</span><br></pre></td></tr></table></figure></p>
<p>以此类推，<code>5</code>可表示为如下对事物<code>x</code>的五次计数过程：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f</span> f f f f x</span><br></pre></td></tr></table></figure></p>
<p>用程序语言来表示，它的形式应该是这个样子：<code>f(f(f(f(f(x)))))</code>。值得强调的是，<code>5</code>是指的这5个<code>f</code>对x的求值的过程，而不是求值后的结果。</p>
<p>现在给<code>1</code>起一个名字叫<code>one</code>。因此用JavaScript来表示，它的定义应该是这个样子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// one 是一个过程</span></span><br><span class="line"><span class="keyword">var</span> one = <span class="function"><span class="keyword">function</span> (<span class="params">f</span>) </span>&#123;  <span class="comment">//给定f为计数过程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;   <span class="comment">//1则表示为一次计数过程</span></span><br><span class="line">        <span class="keyword">return</span> f(x);  <span class="comment">//x的任意性代表了计数过程的抽象性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因此，只要再定义一个对某个数字加一的过程我们就可以表示所有的正整数。给定这个过程名字叫<code>inc</code>，则它的定义可以表示为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inc = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">f</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> f(n(f)(x)); <span class="comment">//在给定数字n的基础上，做额外一次的同样计数(f)动作。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以，<code>2</code>就可以这样来实现：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> two = inc(one);</span><br></pre></td></tr></table></figure></p>
<p>至此，抽象正整数的定义完成。也许您会觉得这有点儿过于抽象，作为一个具体的例子，我们就来模拟一下我们祖先计数（比如羊皮skin)的例子。假定每数一张羊皮就画一个<code>*</code>的符号，则这个计数的过程<code>f</code>应该表示为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'*'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以数一张羊皮的代码应该是这个样子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">one(f)(<span class="string">'skin'</span>);</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">*</span></span><br></pre></td></tr></table></figure></p>
<p>数两张羊皮的代码应该是这个样子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">two(f)(<span class="string">'skin'</span>);</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span></span><br></pre></td></tr></table></figure></p>
<p><code>0</code>是一个特殊的数字，它代表“无”或“没有”，或者我们可以从另一个角度去理解：<code>0</code>代表没有去做计数过程。基于这样的理解，<code>0</code>就可以用下面的过程代码表示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> zero = <span class="function"><span class="keyword">function</span> (<span class="params">f</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样，<code>one</code>的表示就可以替换为<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> one = inc(zero);</span><br></pre></td></tr></table></figure></p>
<h2 id="总结">总结</h2><p>抽象是强有力的工具，能帮助我们看到现象后面的本质。然而，抽象本身又是一个复杂的思考过程，辅助性的工具符号等能帮助我们简化抽象过程的掌控，比如数字符号的发明大大简化了人类对计数这样一抽象过程的使用。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>抽象是人类在解决复杂问题，尤其是逻辑相关问题时的一个强有力的工具。在今天，在计算机科学和软件工程领域里，抽象更是解决复杂系统的有力方法之一。没有抽象，就不可能有今天众多复杂软件的产生。</p>
<p>人类文明的发展，少不了抽象的重要作用。比如人类数字的发明就是一个重要的抽象。数字是什么？是一种物体吗？当然不是。那么是一种精神状态吗？也不是。它是一个符号，一个代表了某种抽象逻辑的符号。那么这种抽象逻辑是什么？不难得出，代表的是对某种事物的数量计数的一种逻辑。之所以叫抽象逻辑，是因为它并不关心被计数的是什么具体事物，事实上它更像一种“模板”可以应用到任何事物上。</p>
<p>近日学习<a href="http://book.douban.com/subject/1148282/">《计算机程序的构造和解释》</a>一书，对抽象有了些许进一步的理解，在此从计算机程序的角度上，以数字的表示这个例子对抽象的力量做一下不全面的分析。</p>]]>
    
    </summary>
    
      <category term="Abstract" scheme="http://blog.liushuping.com/tags/Abstract/"/>
    
      <category term="Abstract" scheme="http://blog.liushuping.com/categories/Abstract/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Web API 的URL和HTTP Verb 的使用]]></title>
    <link href="http://blog.liushuping.com/2014/07/03/http-url-verb-usage-in-web-api/"/>
    <id>http://blog.liushuping.com/2014/07/03/http-url-verb-usage-in-web-api/</id>
    <published>2014-07-03T05:52:43.000Z</published>
    <updated>2015-10-25T10:39:15.000Z</updated>
    <content type="html"><![CDATA[<p>根据<a href="http://en.m.wikipedia.org/wiki/Web_API" target="_blank" rel="external">维基百科的定义</a>：Web API是指面向Web服务器或者Web浏览器以及其它HTTP客户端的API(应用程序编程接口)。Web API有不同的实现风格，比如常见的RPC和REST风格。而任何一种实现都是在HTTP基础之上的，HTTP消息的结构是Web API构成的主要元素，如HTTP URL，状态码(Status Code)和HTTP 方法(Verb)等。 </p>
<p>随着Web的蓬勃发展，大量的信息和数据出现在网络。因此，基于资源(Resource)的RESTful Web API变的异常流行。数量众多的关于如何设计优秀的REST API的文章等层出不穷。比如阮一峰的<a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html" target="_blank" rel="external">RESTful API 设计指南</a> ，其中也提到了一篇不错的文章<a href="http://codeplanet.io/principles-good-restful-api-design/" target="_blank" rel="external">Principle of good RESTful API design</a>。文章都提到了很多关于RESTful API的实用方法和原则。遗憾的是，有一些关于URL和HTTP Verb使用中容易误解的细节都没有被提及。 </p>
<p>结合我在学习和使用Web API的过程中的一些心得，我想就URL和HTTP Verb的几个小细节谈一下。由于讨论不局限在REST上，因此是Web API的讨论。 </p>
<a id="more"></a>
<h2 id="关于URL">关于URL</h2><p>在按照RESTful来设计的Web API中，URL所代表的正是它字面上所描述的意思：统一资源定位。也就是说URL在RESTful Web API中是对资源的位置标识。 </p>
<p>因此一条规则是：<em>在RESTful  Web API的URL中尽量不要附加跟资源定位无关的信息</em>  </p>
<p>比如下面示例都是良好的RESTful Web API可能的URL，URL中的所有信息都是用来定位资源的。 </p>
<pre><code><span class="regexp">/api/</span>books 
<span class="regexp">/api/</span>books/book-id 
<span class="regexp">/api/</span>books?author=crockford
</code></pre><p>而下面的这个例子则可能不是一些优秀的RESTful Web API所具备的URL，因为books资源的定位完全不依赖于访问这个API的用户登录时间。 </p>
<pre><code>/api/books?user_login_on=<span class="number">2014</span>-<span class="number">07</span>-<span class="number">1</span>
</code></pre><p>然而以RPC风格设计的Web API中，URL失去了它字面所描述的意思。这时设计者期望的URL更是一个过程(procedure)名字，一个存在于服务器上的过程的名字。这种情况下，过程需要的”参数”都放在HTTP请求的body中。如下面的示例： </p>
<pre><code>/api/<span class="preprocessor">get</span>-all-<span class="keyword">books </span>
/api/<span class="preprocessor">get</span>-<span class="keyword">book </span>
/api/update-<span class="keyword">book</span>
</code></pre><p>“过程”需要的参数都建议放在HTTP body中。参数若放到URL中，便会破坏以URL来描述过程名的目的。比如下面的代码： </p>
<pre><code>/api/<span class="keyword">get</span>-book?<span class="property">id</span>=<span class="number">123</span>
</code></pre><p>从URL的整体来看，这已经不能算是一个过程的描述了，它带有了一些多余的干扰信息。 </p>
<h2 id="关于HTTP_Verb">关于HTTP Verb</h2><p>合理地配合URL使用HTTP Verb(动词)则可以定义语义良好的Web API。语义良好是用户能直观从API名本身了解其用途的基础，而不需过多地依赖相关解释性文档。 </p>
<p>在RESTful的Web API中，HTTP Verb的使用是应该尽量按照每一个Verb本身字面的意思来使用的。这样CRUD的做操作很容易映射到POST，GET，PUT，DELETE。当然还有一些其它的Verb也都可以映射到一些相关的操作，比如PATCH可以映射到Resource的局部更新。这儿需要提及一点的是，REST的使用一定要做到实用主义，而不是教条主义。教条主义也许会要求所有的Verb都严格地映射到相关指定的操作，然而受到各种实际情况的限制，这样的要求通常很难达到。比如限制读取操作一定要用GET方法，那么当Resource的描述超过浏览器对URL长度限制的情况时，API的实现就陷入两难境地。因此做为实用主义的RESTful Web API，我们首选RESTful的相关规则，然而在特殊情况下允许变通。 </p>
<p>下面的示例URL是一下良好的RESTful Web API的URL和Verb组合： </p>
<pre><code>HTTP <span class="number">1.1</span> GET /api/books  
HTTP <span class="number">1.1</span> POST /api/books 
HTTP <span class="number">1.1</span> GET /api/books/<span class="number">123</span> 
HTTP <span class="number">1.1</span> PUT /api/books/<span class="number">123</span> 
HTTP <span class="number">1.1</span> DELETE /api/books/<span class="number">123</span>
</code></pre><p>那么在RPC风格的Web API中Verb的使用有什么规则呢？在前面介绍了，RPC风格的Web API中URL用做描述一个过程的名字，过程就代表了一个“动作”或“方法”。因此，HTTP Verb本身所表示的意思在RPC风格的Web API中也便不再重要，或者说是与URL所描述的“过程”有些冲突。然而，HTTP要求请求中必须有Verb，因此在实现RPC风格的Web API中只要选取一致的Verb即可。 </p>
<p>下面的示例就是一些不合适的URL和Verb组合，容易给使用者造成困惑： </p>
<pre><code><span class="label">HTTP</span> <span class="number">1</span>.<span class="number">1</span> <span class="preprocessor">GET</span> /api/<span class="preprocessor">get</span>-<span class="keyword">books </span>
<span class="label">HTTP</span> <span class="number">1</span>.<span class="number">1</span> <span class="preprocessor">GET</span> /api/<span class="preprocessor">get</span>-<span class="keyword">book </span>
<span class="label">HTTP</span> <span class="number">1</span>.<span class="number">1</span> PUT /api/update-<span class="keyword">book </span>
<span class="label">HTTP</span> <span class="number">1</span>.<span class="number">1</span> DELETE /api/delete-<span class="keyword">book</span>
</code></pre><p>那么选取那个Verb呢？还是在前面的介绍中，建议把“过程”需要的参数放在HTTP body中。因此GET verb就被排除在外了（因为HTTP标准定义GET类型的HTTP请求不带body）。综合分析一下其它Verb后，POST便是一个不错的选择。PUT和DELETE都具有明显的意义，容易让用户产生一定误解。在RPC风格的Web API中，就可以把POST理解成“执行”。发一个HTTP请求就可理解为：执行一个由URL所描述的存在于服务器的远程过程。 </p>
<p>下面的示例URL就是一些不错的RPC风格的Web API例子： </p>
<pre><code><span class="label">HTTP</span> <span class="number">1</span>.<span class="number">1</span> POST /api/<span class="preprocessor">get</span>-<span class="keyword">books </span>
<span class="label">HTTP</span> <span class="number">1</span>.<span class="number">1</span> POST /api/<span class="preprocessor">get</span>-<span class="keyword">book </span>
<span class="label">HTTP</span> <span class="number">1</span>.<span class="number">1</span> POST /api/update-<span class="keyword">book </span>
<span class="label">HTTP</span> <span class="number">1</span>.<span class="number">1</span> POST /api/delete-<span class="keyword">book</span>
</code></pre><h2 id="总结">总结</h2><p>总结有如下几点： </p>
<ul>
<li>在RESTful Web API的URL中尽量不要附加跟资源定位无关的信息。</li>
<li>在RPC风格的Web API中，URL用来描述“过程”的名字，过程需要的参数建议放在HTTP body中。</li>
<li>在RESTful Web API中，HTTP Verb的使用要尽量保持其本身的语义性，把不同Verb映射到CRUD操作上。</li>
<li>在RPC风格的Web API中，POST方法是一个不错的选择。可以把POST理解为“执行”。因此一次请求可以理解为：“执行”（POST）一个由URL所描述的存在于服务器的“远程过程”。 </li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>根据<a href="http://en.m.wikipedia.org/wiki/Web_API">维基百科的定义</a>：Web API是指面向Web服务器或者Web浏览器以及其它HTTP客户端的API(应用程序编程接口)。Web API有不同的实现风格，比如常见的RPC和REST风格。而任何一种实现都是在HTTP基础之上的，HTTP消息的结构是Web API构成的主要元素，如HTTP URL，状态码(Status Code)和HTTP 方法(Verb)等。 </p>
<p>随着Web的蓬勃发展，大量的信息和数据出现在网络。因此，基于资源(Resource)的RESTful Web API变的异常流行。数量众多的关于如何设计优秀的REST API的文章等层出不穷。比如阮一峰的<a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html">RESTful API 设计指南</a> ，其中也提到了一篇不错的文章<a href="http://codeplanet.io/principles-good-restful-api-design/">Principle of good RESTful API design</a>。文章都提到了很多关于RESTful API的实用方法和原则。遗憾的是，有一些关于URL和HTTP Verb使用中容易误解的细节都没有被提及。 </p>
<p>结合我在学习和使用Web API的过程中的一些心得，我想就URL和HTTP Verb的几个小细节谈一下。由于讨论不局限在REST上，因此是Web API的讨论。 </p>]]>
    
    </summary>
    
      <category term="HTTP" scheme="http://blog.liushuping.com/tags/HTTP/"/>
    
      <category term="REST" scheme="http://blog.liushuping.com/tags/REST/"/>
    
      <category term="Web API" scheme="http://blog.liushuping.com/tags/Web-API/"/>
    
      <category term="Web API" scheme="http://blog.liushuping.com/categories/Web-API/"/>
    
  </entry>
  
</feed>
