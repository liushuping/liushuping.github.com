<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Shuping LIU]]></title>
  <subtitle><![CDATA[A JavaScript and C# developer]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://blog.liushuping.com/"/>
  <updated>2016-06-25T15:26:58.000Z</updated>
  <id>http://blog.liushuping.com/</id>
  
  <author>
    <name><![CDATA[Shuping LIU]]></name>
    <email><![CDATA[lsp.lhh@gmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[反推Sigmoid公式的形成]]></title>
    <link href="http://blog.liushuping.com/2016/06/25/%E5%8F%8D%E6%8E%A8Sigmoid%E5%85%AC%E5%BC%8F%E7%9A%84%E5%BD%A2%E6%88%90/"/>
    <id>http://blog.liushuping.com/2016/06/25/反推Sigmoid公式的形成/</id>
    <published>2016-06-25T12:55:18.000Z</published>
    <updated>2016-06-25T15:26:58.000Z</updated>
    <content type="html"><![CDATA[<p><a href="2016/06/24/Sigmoid什么鬼/">[Sigmoid什么鬼？]</a>一文介绍了Sigmoid函数因其公式简单，形状同正态分布函数的积分函数形状类似，从而被用在了机器学习中。那么这个函数是如何被构造出来的呢？其原始过程无从得知，但ghost同学愿意从个人的理解出发，尝试反推一下Sigmoid函数的构造形成。</p>
<a id="more"></a>
<p>我们对Sigmoid有这些特性要求</p>
<ol>
<li>值范围在(0, 1)内</li>
<li>自变量取值范围在(-∞, +∞)</li>
<li>函数曲线经过(x=0, y=0.5)点，且以该点中心对称</li>
<li>函数单调递增，连续可导（光滑)</li>
<li>随着自变量的增大，函数快速接近1；随着自变量的变小，函数快速接近0</li>
</ol>
<p>逐项解释一下每项特性要求的原因。</p>
<ol>
<li>取值(0, 1)是为了满足逻辑分析的需求（是与否的问题）。取值是一个区间而不是0和1两个离散值，是因为期望以概率的形式分析逻辑问题，这比离散值更有应用意义。</li>
<li>自变量的取值范围可以是任何实数。</li>
<li>曲线经过(x=0, y=0.5)点，是为了保证50%的概率是曲线的中心位置。正态分布的函数的积分函数形状是中心对称。</li>
<li>单调递增，无需解释；连续可导反映了事件的发生过程是个累积过程，而不是一个突变过程。可导也保证了计算的简单性。</li>
<li>最后一条也是模拟了正态函数的积分函数形状的。</li>
</ol>
<p>接下来ghost尝试按照上面的要求，从最简单的公式开始，一步步推导出Sigmoid函数方程。</p>
<p>首先第1，2条要求的数学表达式为：</p>
<p><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Fsigmoid_f1.png" alt="img"></p>
<p>要把自变量从（-∞,∞)映射到（0,1)的范围，并没有很直接的办法。因此，可以把问题分解为多个步骤。</p>
<p>第一步可以把自变量映射到非负值范围内，最容易想到的是绝对值函数:</p>
<p><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Fsigmoid_f2.png" alt="img"></p>
<p>但绝对值函数不符合第4条要求，因为在所有实数的取值空间范围内，绝对值函数不光滑。</p>
<p>从最简单的函数挑选起，只能选指数函数了：</p>
<p><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Fsigmoid_f3.png" alt="img"></p>
<p>恩，指数函数可以完美地把自变量从（-∞,∞)映射到（0, ∞)区间。</p>
<p>接下里要把映射空间从(0,∞)缩小到(0,1)内。把一个半无限空间映射到一个小的有限空间的有效办法是：对映射关系取倒数：</p>
<p><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Fsigmoid_f4.png" alt="img"></p>
<p>然而由于半无限空间的下限是0,对其取倒数会使映射结果重新回到无穷大值。一个简单有效的办法是对其进行平移一个合适的值，从而可以把值空间缩放到需要的范围内。对于我们的例子，只需水平右移1个单位即可：</p>
<p><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Fsigmoid_f5.png" alt="img"></p>
<p>但是这个函数是单调递减的，不符合第4条要求。解决的办法非常简单，只需要调换自变量x的符号即可：</p>
<p><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Fsigmoid_f6.png" alt="img"></p>
<p>对着之前的五条要求验证一下，现在我们的函数符合所有条件，可以划上等号了：</p>
<p><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Fsigmoid_f7.png" alt="img"></p>
<p>解释一下第5条要求：指数函数能很好地保证函数曲线快速接近0和1的要求。</p>
<p>最后还有一个问题，常数a取值多少好呢？这个问题没有标准的答案，然而当取值多少都可以时，我们应该取一个能让函数导数计算最为方便的值。</p>
<p>函数f(x)导数计算的复杂度完全取决于函数内指数函数部分。而所有指数函数的导数计算中，自然常数e的导数计算最为简单（是其本身）。于是我们的Sigmoid函数最终成了这个样子：</p>
<p><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Fsigmoid_f8.png" alt="img"></p>
<p>当然了，您可以练习证明一下Sigmoid函数的导数公式，5-10分钟的事情，对思维训练还是有好处的。</p>
<p><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Fsigmoid_f9.png" alt="img"></p>
<p>本文所有的公式都是通过<a href="http://latex.codecogs.com/" target="_blank" rel="external">http://latex.codecogs.com/</a> 网站编辑生成的，在此特别致谢！</p>
<h2 id="咖啡时间">咖啡时间</h2><p><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Fsigmoid_10.png" alt="img"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="2016/06/24/Sigmoid什么鬼/">[Sigmoid什么鬼？]</a>一文介绍了Sigmoid函数因其公式简单，形状同正态分布函数的积分函数形状类似，从而被用在了机器学习中。那么这个函数是如何被构造出来的呢？其原始过程无从得知，但ghost同学愿意从个人的理解出发，尝试反推一下Sigmoid函数的构造形成。</p>]]>
    
    </summary>
    
      <category term="Machine Learning" scheme="http://blog.liushuping.com/tags/Machine-Learning/"/>
    
      <category term="Math" scheme="http://blog.liushuping.com/tags/Math/"/>
    
      <category term="Sigmoid" scheme="http://blog.liushuping.com/tags/Sigmoid/"/>
    
      <category term="Math" scheme="http://blog.liushuping.com/categories/Math/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Sigmoid什么鬼?]]></title>
    <link href="http://blog.liushuping.com/2016/06/24/Sigmoid%E4%BB%80%E4%B9%88%E9%AC%BC/"/>
    <id>http://blog.liushuping.com/2016/06/24/Sigmoid什么鬼/</id>
    <published>2016-06-24T13:48:37.000Z</published>
    <updated>2016-06-24T13:49:51.000Z</updated>
    <content type="html"><![CDATA[<p>本文介绍的是机器学习中频繁出现的一个函数Sigmoid, 但不了解机器学习并不影响您对本文的理解。</p>
<p>如果您对机器学习有些涉猎，您会发现Sigmoid是一个应用频繁的函数。在逻辑回归分析和神经网络计算中都有它的身影。那么为什么选取这么个函数呢？首先来看一下它的公式：<br><a id="more"></a></p>
<p><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Fsigmoid_equation.png" alt="img"></p>
<p>恩，看起来没啥特别的，公式中的<code>e</code>是自然常数（约为2.71828）。把它画到笛卡尔坐标系下是这个样子的：</p>
<p><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Fsigmoid_curve.png" alt="img"></p>
<p>它的取值范围在0到1之间，且绝大部分值分布在0或者1附近，中间为过渡部分。那么为什么这个形式的函数会用在机器学习的逻辑回归分析和神经网络中呢？ 这需要从逻辑回归分析的需求谈起。</p>
<p>逻辑回归分析是说通过已有的历史数据来建立一个数学模型，以达到该模型能预测未来数据的目的。预测时，输入未来数据的特征值，计算未来数据，而由于是逻辑回归，所以结果只有两种情况：是和否也即0和1。从结果取值范围的角度来看，Sigmoid是符合逻辑回归需求的。逻辑回归分析又可以称为对未来“事件”是否会发生的一种预测，而预测通常不会完全分布在100%的发生和100%的不发生上，更多的预测会给出事件发生的概率。如果预测说该事件发生的概率是60%，我们则认为它可能会发生；如果概率是95%，我们则认为它极有可能发生。50%的概率是事件发生与不发生的一个临界点。从这个临界点来看，Sigmoid也符合需求，曲线基于0.5值处中心对称。</p>
<p>Sigmoid虽然符合了逻辑回归分析的需求，但是取值在0-1之间且以0.5值处中心对称的曲线函数有无数种，为啥唯独选取Sigmoid呢？</p>
<p>这需要去了解我们如何去看待一个事件的概率分布。大多数情况下，并没有办法知道未知事件的概率分布形式，而在无法得知的情况下，正态分布是一个最好的选择，因为它是所有概率分布中最可能的表现形式。</p>
<p>概率的正态分布又叫高斯分布，它的函数是这个样子的：</p>
<p><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Fnorm_distribution_equation.png" alt="img"></p>
<p>吓死宝宝了，好复杂！简单解释一下里面的几个参数，<code>e</code>就是自然常数；<code>μ</code>是统计平均值，又叫数学期望；<code>σ^2</code>是方差。不了解这些概念也没关系，不影响接下来内容的理解:-)</p>
<p>在笛卡尔坐标系下，正态分布的函数呈现出“钟”形，如下图。图中四条曲线代表参数不同的四个正态分布。<br><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2FNormal_Distribution_PDF.png" alt="img"><br>[图片来自维基百科]</p>
<p>在假定某个事件的概率分布符合正态分布的规律后，要分析其可能发生的概率，就要看它的积分形式。我尝试着做了一下积分，没算出来 :-(。 上网查了一下，正态分布的积分形式是一个超越函数，普通高等数学能积出来才怪呢。。。</p>
<p>好吧，那只能看曲线的样子了：</p>
<p><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2FNormal_Distribution_CDF.png" alt="img"><br>[图片来自维基百科]</p>
<p>到这里应该发现什么了吧！Sigmoid函数和正态分布函数的积分形式形状非常类似。所以说，如果在需要大规模数值计算的机器学习领域中计算正态分布的积分函数，计算代价是很大的，而Sigmoid的形式跟它相似，却由于其公式简单，计算量非常的小，因此被选为替代函数。</p>
<p>在机器学习计算中，还需要大量计算一个函数的微分形式，当然了正态分布函数的积分形式的微分形式（有点儿绕…)就是正态分布函数本身，它的公式如上面所示有点而复杂，所以计算代价也有点儿高。 用Sigmoid作为替代的另外一个重要原因是它的微分形式非常简单，完全可以用Sigmoid本身通过代数运算得到，公式如下：</p>
<p><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Fsigmoid_deri_equation.png" alt="img"></p>
<p>这个可以很容易地被推导证明。</p>
<p>Sigmoid的这些优点可以使大规模计算节省很多时间。</p>
<p>在神经网络的模型训练中，为了让网络更加智能，对不同数据是否能通过某个节点要做限制。这个限制函数通常叫做激活函数，它也是一个返回是与否的函数，因此Sigmoid也是一个不错的选择。</p>
<p>现在了解了为什么Sigmoid会被用在机器学习中了吧？ :-)</p>
<h2 id="咖啡时间">咖啡时间</h2><p>Sigmoid还有个别名，叫S型函数或S型曲线。而一想到S曲线，我首先想到的居然是芙蓉姐姐。<br><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Ffurongjiejie.jpg" alt="img"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文介绍的是机器学习中频繁出现的一个函数Sigmoid, 但不了解机器学习并不影响您对本文的理解。</p>
<p>如果您对机器学习有些涉猎，您会发现Sigmoid是一个应用频繁的函数。在逻辑回归分析和神经网络计算中都有它的身影。那么为什么选取这么个函数呢？首先来看一下它的公式：<br>]]>
    
    </summary>
    
      <category term="Machine Learning" scheme="http://blog.liushuping.com/tags/Machine-Learning/"/>
    
      <category term="Math" scheme="http://blog.liushuping.com/tags/Math/"/>
    
      <category term="Math" scheme="http://blog.liushuping.com/categories/Math/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Anti Gravity]]></title>
    <link href="http://blog.liushuping.com/2016/06/23/Anti-Gravity/"/>
    <id>http://blog.liushuping.com/2016/06/23/Anti-Gravity/</id>
    <published>2016-06-23T14:14:31.000Z</published>
    <updated>2016-06-23T14:16:30.000Z</updated>
    <content type="html"><![CDATA[<p>一个好的创意一定要配一个牛B闪闪的名字。</p>
<p>一个好的算法或模型一定要足够简单。</p>
<p>Anti Gravity就是一个。</p>
<p>单纯从名字上看，Anti Gravity也许是一个航天计划的一部分，事实上它却没有这么高大上，而是仅仅来源于一个编程游戏里面非常简单的一个算法。前些日子公司举行了一场编程游戏竞赛，题目用的就是IBM一个非常非常老的个人项目<a href="http://robocode.sourceforge.net/" target="_blank" rel="external">Robocode</a>。如果你很熟悉这个项目，那么你就暴露年龄了。</p>
<a id="more"></a>
<p>游戏的大致规则：根据游戏平台提供的接口，编程实现一个坦克类，然后比赛双方把坦克放到一个矩形区域范围内的战场中，坦克移动、扫描、射击对方。游戏中涉及到很多策略和技巧，几何学的，统计概率学的等等。坦克在移动过程中，有可能碰到对方坦克，也有可能碰撞到墙壁，任何碰撞都会损失能量，因此如何有效地躲避墙壁是游戏中众多策略中的一个，也是非常简单的一个。</p>
<p>Anti Gravity是实现躲避墙壁的算法之一，而之所以介绍它，是因为它虽然只利用了简单的数学公式，却充分体现了数学之美。由于各种原因，这个算法最终并没有用在我的游戏策略实现中，但是它却是我在整个活动中最大的收获。</p>
<h2 id="Anti_Gravity基本原理">Anti Gravity基本原理</h2><p>Anti Gravity的核心原理就是万有引力定律和向量运算。</p>
<p>万有引力定律是说任意两个物体之间的引力与质量成正比，与距离成反比。在一个矩形围墙围起的区域内，坦克受到四面墙的引力作用，其大小和方向如下图示意。</p>
<p><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Fgravity_in_region.png" alt="img"></p>
<p>在这个系统中坦克出于追击敌人，躲避子弹等目的需要沿不同方向移动，这种移动的需求可以转化为某个方向的力的大小。比如下图中，箭头所指的方向代表坦克移动的方向，而箭头的长度代表沿该方向移动“意愿”的强弱，我们用力的大小来表示。</p>
<p><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Fmove_force.png" alt="img"></p>
<p>因此我们把坦克的期望移动、墙壁对坦克可能的作用等都“正规化”到笛卡尔坐标系下力的作用了。在这个系统下，如果期望坦克的移动避开墙壁，则只需要在坦克上定义四个“反引力”用来抵销来自四面墙壁的引力，然后把代表坦克移动方向的力与之叠加，结果就是坦克真正应该移动的方向和力度了。在一个矩形的区域内，四个“反引力”都落在笛卡尔坐标系的坐标轴方向上，只需把坦克的移动力投影分解到坐标轴上，然后和“反引力”代数求和，即可最后求出总和。</p>
<p><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Fdestruct_force.png" alt="img"></p>
<p>在这个模型下，要保证坦克不撞墙还需要一个条件：当坦克很接近墙壁时所需要的反引力（或引力）要非常大，以至于它能主导坦克的运动方向。一个很简单的数学公式可以达成这个目的：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">force = constant / distance</span><br></pre></td></tr></table></figure></p>
<p>或者其它形式<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">force = constant / (distance ^ power)</span><br></pre></td></tr></table></figure></p>
<p>在距离接近于<code>0</code>时，产生的反引力会接近无穷大，足够使坦克避开。</p>
<p>需要注意的是，避开墙壁通常是次要目的，主要目的是追击敌人或躲避子弹，因此不能让反引力对坦克原有的运行轨道产生过大的影响，这就是数学模型的参数选取和调节的问题了。把坦克自身的移动力定义的足够大，如此这样只有在坦克足够靠近墙壁时反引力才能对原运行轨道产生比较大的影响。</p>
<p>当墙壁是非矩形的情况下，或者考虑其它非墙壁产生的反引力时，施加在坦克上的力通常不会落在坐标轴方向上，此时只需要把所有的力分解到坐标轴方向，做代数计算最后合成即可。</p>
<p><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Fdestruct_all_forces.png" alt="img"></p>
<p>当然了，这其实是一个多矢量的叠加计算。</p>
<p><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Fvectors_calc.png" alt="img"></p>
<h2 id="咖啡时间">咖啡时间</h2><p>打开python解释器，输入并运行<code>import anti-gravity</code>，你就可以做到下图中的事情了。</p>
<p><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Fman_on_moon.jpg" alt="img"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>一个好的创意一定要配一个牛B闪闪的名字。</p>
<p>一个好的算法或模型一定要足够简单。</p>
<p>Anti Gravity就是一个。</p>
<p>单纯从名字上看，Anti Gravity也许是一个航天计划的一部分，事实上它却没有这么高大上，而是仅仅来源于一个编程游戏里面非常简单的一个算法。前些日子公司举行了一场编程游戏竞赛，题目用的就是IBM一个非常非常老的个人项目<a href="http://robocode.sourceforge.net/">Robocode</a>。如果你很熟悉这个项目，那么你就暴露年龄了。</p>]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://blog.liushuping.com/tags/Algorithm/"/>
    
      <category term="Math" scheme="http://blog.liushuping.com/tags/Math/"/>
    
      <category term="Math" scheme="http://blog.liushuping.com/categories/Math/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[循环内的await是你想象的运行方式吗?]]></title>
    <link href="http://blog.liushuping.com/2016/06/22/%E5%BE%AA%E7%8E%AF%E5%86%85%E7%9A%84await%E6%98%AF%E4%BD%A0%E6%83%B3%E8%B1%A1%E7%9A%84%E8%BF%90%E8%A1%8C%E6%96%B9%E5%BC%8F%E5%90%97/"/>
    <id>http://blog.liushuping.com/2016/06/22/循环内的await是你想象的运行方式吗/</id>
    <published>2016-06-22T14:15:52.000Z</published>
    <updated>2016-06-22T14:26:12.000Z</updated>
    <content type="html"><![CDATA[<p><a href="/2016/06/22/C-中特别的无限循环/">《C#中特别的无限循环》</a>一文提到了无限循环内以<code>await</code>的方式异步调用其它方法的例子，然而程序开发中这样的情况并不多，更容易碰到有限循环中的异步调用，例如下面的代码：</p>
<a id="more"></a>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> task = <span class="keyword">new</span> Task(Check);</span><br><span class="line">    task.Start();</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">Check</span>(<span class="params"></span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sites = <span class="keyword">new</span>[]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"http://www.baidu.com"</span>,</span><br><span class="line">        <span class="string">"http://www.qq.com"</span>,</span><br><span class="line">        <span class="string">"http://www.jd.com"</span>,</span><br><span class="line">        <span class="string">"http://www.mi.com"</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> site <span class="keyword">in</span> sites)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> client = <span class="keyword">new</span> HttpClient();</span><br><span class="line">        <span class="keyword">await</span> client.GetAsync(site);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相信不少C#开发人员写过类似结构的代码，但并非所有的人这都清楚该代码的执行方式是否符合其真正意图。如果这样问代码的作者：“<code>foreach</code>循环内代码是同步还是异步的？” 这个问题本身就是很“微妙”（tricky）的，或者说它存在严重的歧义。这种问法所得到的回答通常是“对的，是异步的”，但提问者和回答者存在理解的不同。</p>
<p>所以，要把问题描述清楚：“你期望代码中被<code>foreach</code>所遍历的四个站点是依次先后被访问，还是并发同时被访问？” 有很大比例的情况是代码的作者希望四个站点被同时异步访问，然而不幸的是，四个站点是依次先后顺序被访问的。为了验证，我们先在代码中加入输出信息标记代码的执行顺序，如下：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> task = <span class="keyword">new</span> Task(Check);</span><br><span class="line">    task.Start();</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">Check</span>(<span class="params"></span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sites = <span class="keyword">new</span>[]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"http://www.baidu.com"</span>,</span><br><span class="line">        <span class="string">"http://www.qq.com"</span>,</span><br><span class="line">        <span class="string">"http://www.jd.com"</span>,</span><br><span class="line">        <span class="string">"http://www.mi.com"</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> site <span class="keyword">in</span> sites)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> client = <span class="keyword">new</span> HttpClient();</span><br><span class="line">        Console.WriteLine($<span class="string">"&#123;site&#125; start"</span>);</span><br><span class="line">        <span class="keyword">await</span> client.GetAsync(site);</span><br><span class="line">        Console.WriteLine($<span class="string">"&#123;site&#125; end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后可以看到这样的运行效果：<br><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Fasync-foreach.gif" alt="gif"><br>因此，代码并没有按照（不正确）“预期”去执行，更悲剧的是程序员有可能一直认为它是并发执行了，所以一个问题就隐藏在那儿了。</p>
<p>其实 <code>await</code>关键字后面的方法是异步执行了的，但不能把这种异步执行理解成整个<code>foreach</code>代码块内部是异步不等待的，而<code>await</code>正是告诉<code>foreach</code>说：“请等待当前所正在异步执行的代码，完成后再进入下一次循环”。换一句话说，被调用的<code>XXXAsync</code>方法无论如何都是异步发生了，而加不加<code>await</code>关键字是告诉程序是否等待这个异步代码完成而进入下一条语句。</p>
<p>当然，如果把代码中的<code>await</code>去掉就会达到预期效果了，但一定要注意分析整个程序代码的设计结构，要考略上层代码是否还需要<code>await</code>这一段代码，如果需要则不能轻易去掉。</p>
<h2 id="咖啡时间">咖啡时间</h2><p>咖啡和游戏已经准备就绪，缺一台电脑，谁借我一用？<br><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Fshouwangxianfeng.JPG" alt="img"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="/2016/06/22/C-中特别的无限循环/">《C#中特别的无限循环》</a>一文提到了无限循环内以<code>await</code>的方式异步调用其它方法的例子，然而程序开发中这样的情况并不多，更容易碰到有限循环中的异步调用，例如下面的代码：</p>]]>
    
    </summary>
    
      <category term="Async" scheme="http://blog.liushuping.com/tags/Async/"/>
    
      <category term="C#" scheme="http://blog.liushuping.com/tags/C/"/>
    
      <category term="C#" scheme="http://blog.liushuping.com/categories/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C# 中特别的无限循环]]></title>
    <link href="http://blog.liushuping.com/2016/06/22/C-%E4%B8%AD%E7%89%B9%E5%88%AB%E7%9A%84%E6%97%A0%E9%99%90%E5%BE%AA%E7%8E%AF/"/>
    <id>http://blog.liushuping.com/2016/06/22/C-中特别的无限循环/</id>
    <published>2016-06-22T14:13:42.000Z</published>
    <updated>2016-06-22T14:23:33.000Z</updated>
    <content type="html"><![CDATA[<p>通常来说无限循环主要用在一个程序的主方法内，用来实现该程序重复不断地执行特定的操作，比如Windows程序的消息轮询机制，比如<code>REPL</code>类型程序的重复流程。这种无限循环程序的结构一般是这个样子的：</p>
<a id="more"></a>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"Hello World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的结构存在一个小问题，程序只能强制<code>Ctrl + C</code>结束，显得不太那么优雅，且程序的结束时刻之前的运行状态不可确定。因此一般会在循环内判断循环结束退出的条件，比如下面的<code>REPL</code>程序：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">string</span> input = Console.ReadLine();</span><br><span class="line">        <span class="keyword">if</span> (Regex.IsMatch(input, <span class="string">@"\s*[qQ]\s*"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Console.WriteLine(input);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="异步的无限循环">异步的无限循环</h2><p>加入了<code>Task</code>异步功能后，有些异步的无限循环看起来就有些迷惑性了，比如下面的例子：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    Foo();</span><br><span class="line">    Console.WriteLine(<span class="string">"Hello World"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">Foo</span>(<span class="params"></span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> client = <span class="keyword">new</span> HttpClient();</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> client.GetAsync(<span class="string">"http://example.com"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在初次接触<code>async</code>, <code>await</code>等关键字且面对<code>Foo</code>这个方法时，程序员容易产生一种困惑：“不能调用<code>Foo</code>方法，否则代码会永远卡在这儿，直到强制退出”。然而，如果运行一下这段代码会发现<code>Main</code>方法是不会卡在<code>Foo</code>方法处的，它会立刻输出<code>Hello World</code>并结束。</p>
<p>像类似<code>Foo</code>结构的方法，都是有些约定的：</p>
<ul>
<li>方法的返回值是<code>Task</code>，但方法体内并没有任何的<code>return</code>语句， 因为此种形式的方法体整体就是返回值<code>Task</code>的定义。</li>
<li>调用<code>Foo</code>方法的过程（例如<code>Main</code>调用了<code>Foo</code>），就是把<code>Foo</code>方法体所代表的<code>Task</code>异步执行。</li>
<li>既然是异步执行，<code>Main</code>方法内的<code>Foo()</code>调用并不会阻止后续语句的执行。</li>
</ul>
<p>然而，这是否代表我们可以定义这种包含无限循环的异步方法了呢？这是一种不好的做法，虽然该异步方法不会阻止调用方法的继续执行，但它在另外一个线程内无限循环执行，唯一结束的办法是强制退出，因此一定带有不确定状态的可能。</p>
<p>如果能确定该方法只是用在<code>Main</code>方法中，该方法还是可以接受的，因为该方法的生命周期和主程序同步，两者同时结束。否则，尤其在开发类库中，是不能定义这样的方法的，至少方法应该能接受一个结束条件，以主动退出。</p>
<h2 id="await_Task-FromResult是同步还是异步？">await Task.FromResult<t>是同步还是异步？</t></h2><p>在保持上面代码异步的结构和类型不变的前提下，只做小小的改动，<code>Main</code>方法就会完全卡在<code>Foo</code>方法的执行上了：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    Foo();</span><br><span class="line">    Console.WriteLine(<span class="string">"Hello World"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">Foo</span>(<span class="params"></span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> Task.FromResult(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>方法的签名、结构完全一样，只是把<code>HttpClient</code>替换成了<code>Task.FromResult(0)</code>，为什么就变成同步的了呢？@cx001提示说有可能是因为代码中没有需要异步执行的逻辑，被编译优化成同步了，这个问题有待继续分析。</p>
<h2 id="我喜欢的一个同步无限循环">我喜欢的一个同步无限循环</h2><p>异步的无限循环还可以理解，同步的无限循环就很费解了：只要方法被调用，程序就会完全进入死循环了啊。其实，只要一个同步的无限循环足够的”Lazy”，很多情况下它是不会阻止程序继续运行的，看代码：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> allFabonaciNumbers = GetAllFabonaciNumbers();</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> number <span class="keyword">in</span> allFabonaciNumbers)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (number &gt; <span class="number">100</span>) <span class="keyword">break</span>;</span><br><span class="line">        Console.WriteLine(number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> IEnumerable&lt;<span class="keyword">long</span>&gt; <span class="title">GetAllFabonaciNumbers</span>(<span class="params"></span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> b;</span><br><span class="line">        <span class="keyword">long</span> t = a + b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先方法<code>GetAllFabonaciNumbers</code>并不是无限循环，因为<code>long</code>类型数据是有范围的。代码中，<code>GetAllFabonaciNumbers</code>返回了“所有的”（<code>long</code>类型所能表达范围内的）Fabonaci数，其内部的循环可近似看作“无限循环”。 然而，调用该方法时只要不全部遍历（<code>foreach</code>）结果集，是不会造成“无限”循环的。利用<code>IEnumberable&lt;T&gt;</code>是惰性求值的特性，配合“无限循环”，C#可以很好地模拟表达很多函数式语言所特有的惰性数值，比如:所有的自然数，所有的素数等等。</p>
<p>事实上，<code>IEnumberable&lt;T&gt;</code>还能实现其它一些更有趣的功能呢，留作以后讨论吧。:-)</p>
<h2 id="咖啡时间">咖啡时间</h2><p>我爱美人鱼<br><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Fstarbuck.jpg" alt="img"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>通常来说无限循环主要用在一个程序的主方法内，用来实现该程序重复不断地执行特定的操作，比如Windows程序的消息轮询机制，比如<code>REPL</code>类型程序的重复流程。这种无限循环程序的结构一般是这个样子的：</p>]]>
    
    </summary>
    
      <category term="Async" scheme="http://blog.liushuping.com/tags/Async/"/>
    
      <category term="C#" scheme="http://blog.liushuping.com/tags/C/"/>
    
      <category term="C#" scheme="http://blog.liushuping.com/categories/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于跨域请求一些常见的误解]]></title>
    <link href="http://blog.liushuping.com/2016/06/20/%E5%85%B3%E4%BA%8E%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AF%AF%E8%A7%A3/"/>
    <id>http://blog.liushuping.com/2016/06/20/关于跨域请求一些常见的误解/</id>
    <published>2016-06-20T14:44:37.000Z</published>
    <updated>2016-06-20T14:51:55.000Z</updated>
    <content type="html"><![CDATA[<p>自从不做Web前端开发一年多来，发现开始慢慢地遗忘一些前端知识，近来突然发现对跨域请求（同“源”策略）的知识遗忘太多，以至于对其基本原理产生了一些误解。借此机会，把容易产生误解的一些知识点写出来，帮助自己加强记忆，也希望能对读者有所帮助。</p>
<a id="more"></a>
<h2 id="跨域请求的实现方式">跨域请求的实现方式</h2><p>跨域请求常见的两种实现方式是：<code>JSONP</code>和<code>COR</code>，<code>JSONP</code>是<code>COR</code>标准出现之前的一种方案，<code>COR</code>出现后<code>JSONP</code>的应用渐少，本文讨论的范围是<code>COR</code>。</p>
<h2 id="COR简介">COR简介</h2><p><code>COR</code>的全称是Cross Origin Request，即跨域请求（严格来说应该是跨“源”请求，但本文保留了常见的叫法“跨域请求”），是通过在返回的HTTP响应（response）中加入一些标准定义的头信息（header）来声明该资源允许来自于哪些“源”的请求。而“源”是由<code>scheme</code>，<code>host name</code>和<code>port</code>三部分组成的（有些浏览器，如部分版本IE是不考虑端口号的），如果这三部分中的任何一部分不同则说明两个“域”不同。例如：<code>http://example.com</code>, <code>https://example.com</code>, <code>http://www.example.com</code>和<code>http://example.com:1234</code>分属四个不同的“源”。</p>
<h2 id="“同源策略”的有效范围">“同源策略”的有效范围</h2><p>标准Uer Agent如标准浏览器，出于安全因素考虑，默认是不允许<code>Ajax</code>异步请求访问不同于当前站点“源”的资源的。需要特别说明的一点是，除<code>Ajax</code>异步请求外，其它方式如通过<code>&lt;script&gt;</code>,<code>&lt;img&gt;</code>等标签是允许访问不同“源”的资源的。因此，说浏览器默认是不允许任何形式的跨域请求是一个误解。</p>
<p>值得一提的是，<code>JSONP</code>正是基于<code>&lt;script&gt;</code>标签不受“同源策略”限制这个特点来实现的，此处不做详解，感兴趣者，请留言讨论。</p>
<p>然而，由于复杂业务的需求，很多后台的API等都需要部署在另外一个不同的域名上，或者应用程序需要访问第三方的API，<code>COR</code>的出现就是为了在保证安全的前提下满足这个需求的。<code>COR</code>通过在HTTP响应的头信息中加入一些跨域限制，例如<code>Access-Control-Allow-Origin:http://*.example.com</code>来允许任何来自<code>example.com</code>站点的访问请求。通过严格控制允许访问的域名，是可以保证安全的。</p>
<h2 id="“同源策略”所保护的对象">“同源策略”所保护的对象</h2><p>另一个容易产生的误解是：“同源策略”保护的是请求者还是被请求者？当把这个问题同<code>XSS</code>等问题混在一起时容易产生误解：<code>XSS</code>是说当站点存在安全缺陷时，容易被注入恶意<code>JavaScript</code>代码，而注入的恶意代码通常会把该站点的信息发回攻击者事先部署好的一个服务器上。在这种情况下，容易把“同源策略”理解成是保护请求发起者，因为假如“同源策略”能限制该站点不能发送任何请求到除自身站点外的任何站点，似乎攻击者的脚本就起不到作用了。不过，事实上“同源策略”的作用是在保证被请求资源的安全下，允许受信的站点访问该资源，所以说它是为了保护被请求资源的。</p>
<h2 id="跨域请求是否发生">跨域请求是否发生</h2><p>最后一个容易产生的误解是：“不被<code>COR</code>允许的请求是不会被浏览器发出的”。这是一个错误的理解，且很容易从<code>COR</code>的实现方式来推导证明：<code>COR</code>的实现是通过在HTTP响应中加入相应的头信息来声明该资源可以被哪些站点访问，这种实现方式势必决定了浏览器必须发出请求并检查响应才能做出决定。因此，不被<code>COR</code>允许的请求仍然被浏览器发出且被接收了，只是浏览器并没有把结果反馈给JavaScript，而是汇报了一个“同源”错误。</p>
<p><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Fcor_baidu.gif" alt="gif"></p>
<p>事实上，有一种请求是会被浏览器阻止而不会被发出的，那就是HTTP和HTTPS请求混用的情况，比如在一个HTTPS的站点下尝试<code>Ajax</code>请求HTTP类型的资源。</p>
<p><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Fmixed_request_baidu.gif" alt="gif"></p>
<h2 id="Access-Control-Allow-Origin:_*">Access-Control-Allow-Origin: *</h2><p>“我”做了一个非常了不起的API，想让任何有权限的客户都能访问我的API，因此我需要完全取消“同源策略”的限制：<code>&quot;Access-Control-Allow-Origin: *&quot;</code> 。这样做我需要注意什么？安全是一个最重要的考虑，例如DDos。“了不起”且已经这样做了的API有很多，GitHub API就是一个例子：</p>
<p><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Fcurl-github.gif" alt="gif"></p>
<h2 id="咖啡时间">咖啡时间</h2><p>不知从何时起，我喜欢上了喝咖啡。<br><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Fcoffe-and-keyboard.jpg" alt="img"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>自从不做Web前端开发一年多来，发现开始慢慢地遗忘一些前端知识，近来突然发现对跨域请求（同“源”策略）的知识遗忘太多，以至于对其基本原理产生了一些误解。借此机会，把容易产生误解的一些知识点写出来，帮助自己加强记忆，也希望能对读者有所帮助。</p>]]>
    
    </summary>
    
      <category term="COR" scheme="http://blog.liushuping.com/tags/COR/"/>
    
      <category term="Web" scheme="http://blog.liushuping.com/categories/Web/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Think Bigger]]></title>
    <link href="http://blog.liushuping.com/2016/04/21/Think-Bigger/"/>
    <id>http://blog.liushuping.com/2016/04/21/Think-Bigger/</id>
    <published>2016-04-21T14:00:09.000Z</published>
    <updated>2016-04-21T16:56:53.000Z</updated>
    <content type="html"><![CDATA[<h1 id="变形金刚">变形金刚</h1><p>《变形金刚》是我童年最喜欢的一部动画片，对它的疯狂追捧活动贯穿了我整个小学生涯。我喜欢它片中众多性格鲜明的角色，喜欢它恢弘的剧情，更喜欢它无尽的创意。今天说一下我记忆中印象深刻的一个创意。</p>
<p>话说威震天领导的狂派终于在某天厌倦了同擎天柱领导的博派之间的收效甚微的常规战争了，于是他们制定了一个大计划，并悄悄地准备了很长的时间。在一个风和日丽的日子，正常上班的人们穿梭于大街小巷，疾驶地汽车行驶在繁忙的公路上。突然在毫无征兆的情况下，道路、桥梁、大厦等都动了起来向一个方向聚拢，一个变形金刚的变形上演了：现代化的城市变形成了一个巨型的变形金刚–铁甲龙。<br><a id="more"></a><br><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Ftiejialong.jpg" alt="铁甲龙"></p>
<p>这就是狂派的铁甲龙大型计划。威震天领导着狂派霸天虎暗地里充分利用了一个现代化城市的基础设施， 将之改造成了一个巨大的变形金刚，从而壮大了狂派的阵营。我喜欢这个创意，因为作者敢于想象，敢于 Think Bigger!</p>
<h1 id="AlphaGo">AlphaGo</h1><p>长期以来代表最高水平的人工智能也仅限于挑战国际象棋、模拟人类对话等活动，直到前些日子Google的AlphaGo终于做出了突破，成功地挑战了围棋的顶级选手。如果单纯从所有可能性角度来讲，围棋有10^171种可能，超过了全宇宙的原子数量（10^80)。但是AlphaGo不会傻到去穷举所有可行步骤来决定如何下棋，它采取了蒙特卡洛树的有效剪枝算法，大大提高了程序的效率。</p>
<p><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Falphago.jpg" alt="AlphaGo"></p>
<p>AlphaGo赢得比赛后，无数的网民、评论家等又拾起往日旧话题–“人工智能是否会最终超越人类”，“人类最终是否会被人工智能或机器人取代”等等一些列对人类未来忧心忡忡的话题。</p>
<p>此类的评论或担忧并非完全没有道理，然而几乎所有讨论这类话题的人都没有找到正确的依据。如果仅从AlphoGo的智能表现来作为依据，幻想假如我们尽可能的扩大AlphaGo系统的计算机资源，或许它的智能会有很大的提高。那么，让我们来看看AlphaGo的现状：</p>
<ul>
<li>1200个CPU</li>
<li>下赢了围棋世界选手</li>
</ul>
<p>那么这1200个CPU知道它们自己在做什么吗？应该是不知道的。然而找一个围棋不入门的人让他来下围棋，他也是知道自己在做什么的。那么你认为AlphaGo这类计算模型离能取代人类智能还需多久？我就不需要拿出人类“感情”这种让人工智能难以企及的东西了，更不需要拿出“意识”与“梦”这种让人工智能彻底绝望的东西了。</p>
<p>那么我是说人工智能永远无法跟人类智能相比了？其实不然，至少我觉得还是有一定希望的。要了解这种希望，就要了解人工智能是如何学习进步的。</p>
<h1 id="机器学习">机器学习</h1><p>在经历了“逻辑分析”的种种瓶颈后，人工智能终于青睐了基于统计与概率数学模型的“机器学习”这个方向。这其中尤为炙手可热的领域是“人工神经网络”，它模拟了人类大脑的思维与学习方式，让机器具备自我学习进步的能力，这也许是让很多网友再次相信人工智能会超越人类的一个重要依据。</p>
<p><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Fann.jpg" alt="人工神经网络"></p>
<p>人工神经网络很好地模拟了人类大脑的结构，人类大脑又被认为是人类智慧的根源。然而像AlphaGo这种人工智能的学习模型是有严重缺点的，它仅有非常有限的感知“神经元”。比如现在的AlphaGo只能感知围棋这一类信息。可模拟人类交谈的智能机器人只能感知语言。其它人工智能类似地也只能感知“光”、“运动”等一项或少数的几项输入。然而人类智能的产生是通过大量不同类型感知“神经”进行漫长时间的感知积累而获得的。</p>
<p>因此，现有的人工智能模型是没有希望超过人类的。只有增加人工智能的“输入”，也就是增加它的感知“神经”，且需要尽可能多的可长时间运行的人工感知“神经”才有希望。那么什么才是这些人工感知“神经”呢？答案是“传感器”。</p>
<h1 id="传感器">传感器</h1><p>200多年的工业革命以来，人类已经生产出了无数的传感器，可以用它们来采集各种数据：时间，温度，速度，重力，磁场，光线，压力等等等等。几乎人类感官系统所能感知的变化，都有对应的传感器能进行更精确的采集。</p>
<p>一个传感器无法对人工智能产生足够的影响，那么如何把这些传感器组合起来用在人工智能上？物联网。</p>
<h1 id="物联网">物联网</h1><p>2015年全球大约有130亿台设备接入物联网，到2020年大约有250亿台设备将会接入物联网，这些设备中有很大一部分是传感器或者带有传感器功能。运动手环，空气质量检测仪，情绪检测仪，健康监测仪，空调，微波炉，冰箱等等你能想到的和你不想到的都会接入如物联网。从整个物联网系统来看，它有可以和人类相媲美的“神经系统”了。</p>
<p>那么“大脑”在哪儿？云。</p>
<h1 id="云">云</h1><p>物联网的一端连接着无数的设备，另一端连接着云端的互联网。而云端的互联网，有着浩若繁星的大数据和各种各样的人工神经网络等机器学习模型。因此，云端的互联网是一个“大脑”。它有“思考的可能”。</p>
<h1 id="超级人工智能">超级人工智能</h1><p>试问从古至今人类社会所能了解的所有系统中，哪个系统是最“去中心化”和“不受控”的？毋庸置疑的答案是“互联网”，因此云端的互联网是一个不“受控”的“大脑”。</p>
<p>当物联网的规模真正发展起来后，您是否认为“铁甲龙”即将“站”起来了呢？</p>
<h1 id="智能家居">智能家居</h1><p>在“铁甲龙”这个超级人工智能怪物“站”起来前，最先可能出现井喷式增长的物联网领域将会是家居电器，人口最多的中国将是这个领域的前沿。</p>
<p>把所有家电以集成的方式接入物联网实现更合理的智能家居，将是您助力超级人工智能的一个重要贡献。如果您喜欢Think Bigger，如果您对智能家居的集成感到兴奋，我很乐于推荐我的一位好友和同学@liuganyihao 认识，来设计激动人心的集成智能家居解决方案。我们的智能家居计划的目标是：“控制是为了不控制”，灵感来源于陶行知老先生的“教育是为了不教育”一句话。计划大致可以分为三步：</p>
<ol>
<li>家庭全屋物联网控制与监控，人为主动干预阶段。</li>
<li>家庭全屋智能控制，定时、延时、变频等智能控制来实现节能，节时等需求。</li>
<li>不控制，在前两步一定时间累积基础上，云端系统深度系统学习家庭成员生活习惯，全自动管理全屋物联网设备，无需人员干预。</li>
</ol>
<h1 id="安全">安全</h1><p>如果您不希望“站”起来的超级人工智能是一个专职破坏的“铁甲龙”，而是全自动的方便人类生活的超级大都市“猛大帅”（请自行百度变形金刚），那么我们很乐意跟您讨论物联网的安全领域问题。</p>
<p><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Fmendashuai.jpg" alt="猛大帅"></p>
<h1 id="Think_Bigger">Think Bigger</h1><p>是的，这是一篇软文。</p>
<p>是的，这是一条硬广。</p>
<p>是的，我们Think Bigger！</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="变形金刚">变形金刚</h1><p>《变形金刚》是我童年最喜欢的一部动画片，对它的疯狂追捧活动贯穿了我整个小学生涯。我喜欢它片中众多性格鲜明的角色，喜欢它恢弘的剧情，更喜欢它无尽的创意。今天说一下我记忆中印象深刻的一个创意。</p>
<p>话说威震天领导的狂派终于在某天厌倦了同擎天柱领导的博派之间的收效甚微的常规战争了，于是他们制定了一个大计划，并悄悄地准备了很长的时间。在一个风和日丽的日子，正常上班的人们穿梭于大街小巷，疾驶地汽车行驶在繁忙的公路上。突然在毫无征兆的情况下，道路、桥梁、大厦等都动了起来向一个方向聚拢，一个变形金刚的变形上演了：现代化的城市变形成了一个巨型的变形金刚–铁甲龙。<br>]]>
    
    </summary>
    
      <category term="IoT" scheme="http://blog.liushuping.com/tags/IoT/"/>
    
      <category term="智能家居" scheme="http://blog.liushuping.com/tags/%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85/"/>
    
      <category term="IoT" scheme="http://blog.liushuping.com/categories/IoT/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[map reduce 与 MapReduce]]></title>
    <link href="http://blog.liushuping.com/2016/04/12/map-reduce-%E4%B8%8E-MapReduce/"/>
    <id>http://blog.liushuping.com/2016/04/12/map-reduce-与-MapReduce/</id>
    <published>2016-04-12T14:58:27.000Z</published>
    <updated>2016-04-12T17:28:13.000Z</updated>
    <content type="html"><![CDATA[<p>昨天一个偶然的机会跟同事讨论了<a href="https://en.wikipedia.org/wiki/MapReduce" target="_blank" rel="external">MapReduce</a>这个产品和<a href="http://baike.baidu.com/view/1711147.htm" target="_blank" rel="external">函数式编程</a>中最出名的两个函数<a href="https://en.wikipedia.org/wiki/Map_(higher-order_function" target="_blank" rel="external">map</a>和<a href="https://en.wikipedia.org/wiki/Map_(higher-order_function" target="_blank" rel="external">reduce/fold</a>之间的关系。是仅仅的名字巧合吗？还是存在着某种关系？<a id="more"></a><a href="https://en.wikipedia.org/wiki/MapReduce" target="_blank" rel="external">Wikipedia</a>对两者的关系有明确的解释：</p>
<blockquote>
<p>The model is inspired by the map and reduce functions commonly used in functional programming,[6] although their purpose in the MapReduce framework is not the same as in their original forms.[7] The key contributions of the MapReduce framework are not the actual map and reduce functions, but the scalability and fault-tolerance achieved for a variety of applications by optimizing the execution engine once. </p>
</blockquote>
<p>意思是说，MapReduce的名字受函数式编程中的map和reduce两个函数的名字启发，但是在MapReduce中，”map”和”reduce”不是函数式编程中的map和reduce的本意。</p>
<p>我们也讨论到MapReduce其实是一个Divide and Conquer的算法，那么它为什么不叫DivideConquer这个名呢？个人认为，就针对这个产品而言，DivideConquer这个名字比MapReduce逊色很多。要了解MapReduce的命名，我们需要从了解函数式编程中的map和reduce(或fold)两个函数入手。</p>
<h2 id="函数式编程中的map和reduce">函数式编程中的map和reduce</h2><p>map和reduce是函数式编程中两个最出名，最重要的<a href="https://en.wikipedia.org/wiki/Higher-order_function" target="_blank" rel="external">高阶函数(High Order Function)</a>。什么是高阶函数？它和初中时学的高次（高阶）方程同属一个概念。简单来说，一个函数能被称为高阶函数，它应具备下列2个要素中的至少一点：</p>
<ol>
<li>它能接受另外一个函数作为参数</li>
<li>它的返回值可以是另外一个函数</li>
</ol>
<p>毫无疑问，map和reduce函数都能满足上述两点。这里又引出了另外一个概念：<a href="https://en.wikipedia.org/wiki/First-class_function" target="_blank" rel="external">函数是一等公民(First-class Function)</a>。此处“一等公民”并非指社会地位高下的概念，而是指First-class Function要求编程语言支持把函数作为参数传递或能作为另外一个函数的返回值。因此，函数式编程语言支持First-class Function，而高阶函数的整套体系是构建在其基础之上的。</p>
<p>那么为什么高阶函数是函数式编程的一个核心概念？因为高阶提供了高层次的抽象，而<a href="http://blog.liushuping.com/2014/08/19/think-in-abstraction/">抽象是解决复杂问题（比如软件问题）的强有力工具</a>。</p>
<p>世间函数千千万，那么为什么唯独map，reduce两个函数如此与众不同？这就需要我们去关注一下函数所操作的数据对象，大致可以分为两类：个体或少量几个数据；某类数据的一个集合。对于个体或少量数据，能应用于它们的函数通常各不相同，共性比较少；而可应用于集合类数据的函数，大多具有通用的模式：</p>
<ul>
<li>模式一：对集合内每一个数据做某种转换处理，返回具有同等数量的不同类型集合</li>
<li>模式二：对集合内数据做累积操作，返回一个数据或另外一个不同数量的集合</li>
</ul>
<p>很明显的，模式一可以归纳出一个名字叫”map”，即把某种“转换处理”应用到集合中的每一个元素去。而这种“转换处理”有无数种可能，因此我们把“转换处理”这个函数以参数的形式传给map这个高阶函数。</p>
<p>同理，模式二可以归纳出一个名字叫”reduce”，即把某种“累积操作”逐步应用到集合中的每一个元素去，并最后把累加结果返回。而这种“累积操作”有无数种可能，因为我们把函数以参数的形式传给reduce这个高阶函数。</p>
<h2 id="MapReduce的命名为何对map和reduce函数情有独钟？">MapReduce的命名为何对map和reduce函数情有独钟？</h2><p>MapReduce是一个基于计算机集群的并行、分布式计算框架。它在很大程度上受函数式编程语言中的map和reduce所启发，对分布式计算进行高阶抽象，去除变化的部分，保留不变的框架。它认为：大多数分布式计算可以归纳为下列两种操作的多种组合：</p>
<ul>
<li>对所有数据块（分布于多台计算机上）进行“某种操作”</li>
<li>对局部或所有数据块做数据“汇总操作”</li>
</ul>
<p>看！这是多么的美妙！完全符合之前提到的两个模式。</p>
<p>Hadoop充分吸纳了map，reduce两个函数的精华：在集群机器间移动数据是很耗费资源的，因此它们选择移动函数，函数是一等公民的绝妙应用！</p>
<h2 id="为什么是MapReduce而不是”DivideConquer”?">为什么是MapReduce而不是”DivideConquer”?</h2><p>从本质上来说MapReduce框架属于Divide Conquer的一种。然而针对这个产品，“DividerConquer” 这个命名比MapReduce逊色很多，主要有两点：</p>
<ul>
<li>Divider conquer明确提出了“分而治之”的思路，却没有明确提出“汇总“这个在MapReduce产品中占1/2的思想</li>
<li>MapReduce更加具体地描述了产品的工作流，属于准确的抽象–既有抽象的高可用性，又不失抽象的准确性与实用性。</li>
</ul>
<h2 id="打开另一个世界的大门">打开另一个世界的大门</h2><p>如果您对本文的理解存在困难，我强烈您阅读一些函数式编程的书籍和文章。相信我，一旦您掌握了它，您就打开了一扇通往另一个编程世界的大门（假如面向对象和面向过程是您已经打开的两扇大门）。门的另一侧，是一个美轮美奂的世界。</p>
<p>如果从来没了解过函数式编程，那么我建议您从最纯正的函数语言<a href="https://www.haskell.org/" target="_blank" rel="external">Haskell</a>开始。</p>
<p><a href="http://learnyouahaskell.com/" target="_blank" rel="external">Learn You a Haskell for Great Good!</a>一书妙语连珠，妙趣横生，深入浅出，有趣有料。作者自己画的插画更是生动活泼！我一直坚信：会画画的程序员是非常有前途的！(这个以后详细展开来说)。<br><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Flearnyouahaskell.png" alt="learn you a haskell for great good!"></p>
<p>如果您想找一本更加系统详实的Haskell书，那么看<a href="http://book.realworldhaskell.org/" target="_blank" rel="external">Real World Haskell</a>吧。它介绍了Haskell语言的每一个细节，当然你要有足够的耐心和毅力。</p>
<p>如果您想偏理论角度地研究一下为什么高阶函数很重要，那么我推荐您看一下这篇学术文章：High Order + Polymorphic = Reuse: <a href="http://citeseerx.ist.psu.edu/showciting?cid=577419" target="_blank" rel="external">http://citeseerx.ist.psu.edu/showciting?cid=577419</a></p>
<p>如果您想理论性地研究一下函数式编程，那么我推荐您看一下这篇神作，神作，神作：Theorems for free：<a href="http://ecee.colorado.edu/ecen5533/fall11/reading/free.pdf" target="_blank" rel="external">http://ecee.colorado.edu/ecen5533/fall11/reading/free.pdf</a> 在这篇文章里您可以学到如何用lambda组合子（或<a href="https://en.wikipedia.org/wiki/Fixed-point_combinator#Fixed_point_combinators_in_lambda_calculus" target="_blank" rel="external">Y Combinator</a>）来实现匿名函数的递归。《黑客与画家》的作者成立的创业孵化公司Y Combinator的名字就是来源于函数式编程。（想想吧，这又是一个美妙的名字)</p>
<p>好吧，如果您对函数式编程的纯理论性研究感兴趣，这完全超出我的能力了，但您去看<a href="https://en.wikipedia.org/wiki/Lambda_calculus" target="_blank" rel="external">Lambda Caculus</a>一准儿是没错的了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>昨天一个偶然的机会跟同事讨论了<a href="https://en.wikipedia.org/wiki/MapReduce">MapReduce</a>这个产品和<a href="http://baike.baidu.com/view/1711147.htm">函数式编程</a>中最出名的两个函数<a href="https://en.wikipedia.org/wiki/Map_(higher-order_function">map</a>和<a href="https://en.wikipedia.org/wiki/Map_(higher-order_function">reduce/fold</a>之间的关系。是仅仅的名字巧合吗？还是存在着某种关系？]]>
    
    </summary>
    
      <category term="map, reduce, MapReduce" scheme="http://blog.liushuping.com/tags/map-reduce-MapReduce/"/>
    
      <category term="Functional Programming" scheme="http://blog.liushuping.com/categories/Functional-Programming/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[伪基站之害]]></title>
    <link href="http://blog.liushuping.com/2016/03/29/%E4%BC%AA%E5%9F%BA%E7%AB%99%E4%B9%8B%E5%AE%B3/"/>
    <id>http://blog.liushuping.com/2016/03/29/伪基站之害/</id>
    <published>2016-03-29T13:44:51.000Z</published>
    <updated>2016-03-29T15:50:24.000Z</updated>
    <content type="html"><![CDATA[<p>或许你不清楚什么是伪基站，但你一定遭受过伪基站的骚扰或者欺骗（希望你没有蒙受损失），因为大多数手机诈骗短信都来自于伪基站。</p>
<h1 id="伪基站">伪基站</h1><p>什么事伪基站呢？<a href="http://baike.baidu.com/view/8940201.htm" target="_blank" rel="external">百度百科</a>上的解释:</p>
<blockquote>
<p>伪基站”即假基站，设备一般由主机和笔记本电脑组成，通过短信群发器、短信发信机等相关设备能够搜取以其为中心、一定半径范围内的手机卡信息，通过伪装成运营商的基站，冒用他人手机号码强行向用户手机发送诈骗、广告推销等短信息。</p>
</blockquote>
<a id="more"></a>
<p>受伪基站影响的手机会有什么异常吗？<a href="http://baike.baidu.com/view/8940201.htm" target="_blank" rel="external">百度百科</a>上说：</p>
<blockquote>
<p>伪基站设备运行时，用户手机信号被强制连接到该设备上，导致手机无法正常使用运营商提供的服务，手机用户一般会暂时脱网8～12 秒后恢复正常，部分手机则必须开关机才能重新入网。此外，它还会导致手机用户频繁地更新位置，使得该区域的无线网络资源紧张并出现网络拥塞现象，影响用户的正常通信。</p>
</blockquote>
<p>事实上，现在伪基站可以强制手机连接到其设备上长达将近2分钟了。而这2分钟内用户可能完全觉察不出来任何异常。今天就说一下我切身经历过且觉察到的这2分钟。</p>
<h1 id="我的经历">我的经历</h1><p>下午去银行办一个业务。由于涉及到的金额相对比较大，营业员需要面对面地验证所登记的手机号码归我本人所有。营业员拿起银行专用电话（外观跟遥控器类似）拨我的手机号，然后让我现场出示来电显示以确定号码归我所有。然后，奇怪的事情就发生了。</p>
<p>第一次拨打，营业员表示电话打通了，然而我的手机却没有响铃。因为是面对面地验证手机，我便仔细关注着手机，也得以巧合地看到了此时在几秒内手机信号强度变化的过程是：<code>4G -&gt; E -&gt; G -&gt; E</code>。反应快的你也许看出来了，此时手机已经从一个信号源切换到另一个信号源了。当然，也不排除手机信号由强到弱又到强的可能性。现在想来，营业员刚刚拨通我手机的那一刻，我的手机信号被伪基站给强制切换了，以至于手机还未来得及响铃。然后，这几秒钟的微小变化是很难引起手机用户怀疑的。</p>
<p>我跟营业员确认了一下手机号码没有登记错误。营业员接着进行了第二次拨打，同时我也略微紧张地盯着手机屏幕，生怕一不看就会错过铃声的响起。有时候担心是一种很奇妙的体验：你所担心的事情总是有很大几率发生，哪怕你从逻辑上分析这件事情的发生概率很小。在常规的铃声等待时间内手机并没有响起，取而代之的是手机突然收到了一条短信。还是反应快的你，应该猜到短信不是发自银行，而是来自伪基站的欺骗短信——这是伪基站捕获手机后要干的事情。<br><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Fpirate_station_msg" alt="img"></p>
<p>这里要感谢一下腾讯手机管家，很好地识别出了伪基站欺骗，能有效地提高用户的警惕性。当然了，短信中显而易见的伪造网址是完全欺骗不了我的，我根本不会去访问那个网址的。得益于所从事的工作，我对网站的安全以及欺骗相关知识还略知一二，然而对网络（不是“网站”）和设备层的安全，我还处于新手阶段。因此，我仍然没有意识到手机已经连到了一个非法设备上了。</p>
<p>接下来是第三次拨打电话。那时那刻，我已经有些紧张了：营业员不会怀疑我有什么不轨举动吧？当然这也是短暂的想法，很快就恢复了平静，因为我确认我是诚信地办理着合法的业务。</p>
<p>终于如愿以偿地手机在第四次拨打时响起了铃声，我也在手机上看到了满格的4G信号。手机归属验证通过后，营业员分两次发送手机验证码的方式完成了我的业务办理。我不清楚，如果在验证码发送期间手机被伪基站劫持会发生什么。。。</p>
<p>故事没有结束。直到业务办理完毕，我都没有意识到手机被伪基站劫持过。业务办理完毕，出来银行，心情放松了一下，就习惯性地打开手机随便点了一个程序。然后。。。。我的手机再一次被伪基站劫持（或者是一直被劫持？）。我要再一次感谢腾讯手机管家，因为这次它给了我明确地提醒：<br><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Fpirate_station_warn" alt="img"></p>
<p>然而这并没有结束，再一次反应快的你会从上面的截图（右下角）发现手机还有被<a href="http://baike.baidu.com/item/%E6%B5%81%E9%87%8F%E5%8A%AB%E6%8C%81" target="_blank" rel="external">流量劫持</a>的嫌疑。至此，我终于意识到问题的严重性，关掉网络与手机信号并离开这个伪基站覆盖范围。</p>
<h1 id="伪基站在哪儿？">伪基站在哪儿？</h1><p>它可能在银行周边的某个角落里；某个阴暗房间里；门口某个人的背包里；某个人的拉杆箱里；或者旁边某车的后备箱甚至副驾驶座上。总之，那个人跟我相距不远。事实上，在上午来办业务时，那个人就有可能在那里了（1公里范围内）。因为上午我就发现了信号的<code>4G -&gt; (3G) -&gt; E -&gt; G -&gt; E -&gt; (3G) -&gt; 4G</code>可疑过程了（在一个信号良好的区域），只是上午没用到手机而已。</p>
<p>如果你在大街上、公路上，看到有普通车辆外置长长的或短短的“天线”，抑或在靠近车窗玻璃的某个位置看见内置“天线”，不要天真地认为那是车主想听“BBC”广播。那有可能根本不是个“接收”天线，而是个“发射”天线，连接天线的末端很有可能就是一台伪基站。</p>
<h1 id="什么最不安全？">什么最不安全？</h1><p>有个不争的事实：在所有的技术中，互联网是最不安全的。现在我认为，如果电话系统不能归为互联网大类中的话，那么电话系统是最不安全的：无加密，随意被劫持，易被监听等。一个小学文化水平的行骗者，可以花较少的钱（几千人民币）伪造任意的电话号码。而一个网站域名，在没有<a href="http://baike.baidu.com/subview/3163602/3163602.htm" target="_blank" rel="external">DNS劫持</a>或<a href="http://baike.baidu.com/view/4040394.htm" target="_blank" rel="external">DNS污染</a>的情况下，是极难（个人认为不可能）被伪造的。而DNS劫持或污染的难度又很大。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>或许你不清楚什么是伪基站，但你一定遭受过伪基站的骚扰或者欺骗（希望你没有蒙受损失），因为大多数手机诈骗短信都来自于伪基站。</p>
<h1 id="伪基站">伪基站</h1><p>什么事伪基站呢？<a href="http://baike.baidu.com/view/8940201.htm">百度百科</a>上的解释:</p>
<blockquote>
<p>伪基站”即假基站，设备一般由主机和笔记本电脑组成，通过短信群发器、短信发信机等相关设备能够搜取以其为中心、一定半径范围内的手机卡信息，通过伪装成运营商的基站，冒用他人手机号码强行向用户手机发送诈骗、广告推销等短信息。</p>
</blockquote>]]>
    
    </summary>
    
      <category term="Security" scheme="http://blog.liushuping.com/tags/Security/"/>
    
      <category term="Security" scheme="http://blog.liushuping.com/categories/Security/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[完成Coursera Machine Learning课程]]></title>
    <link href="http://blog.liushuping.com/2016/03/01/%E5%AE%8C%E6%88%90Cousera-Machine-Learning%E8%AF%BE%E7%A8%8B/"/>
    <id>http://blog.liushuping.com/2016/03/01/完成Cousera-Machine-Learning课程/</id>
    <published>2016-03-01T14:40:57.000Z</published>
    <updated>2016-03-02T16:45:46.000Z</updated>
    <content type="html"><![CDATA[<h1 id="完成了一个目标">完成了一个目标</h1><p>经过了十周多的奋斗，我终于完成了<a href="http://baike.baidu.com/view/10853998.htm?fromtitle=Andrew+Ng" target="_blank" rel="external">Andrew Ng</a>的<a href="https://www.coursera.org/learn/machine-learning" target="_blank" rel="external">Machine Learning</a>课程并获得证书，这也是2016年我完成的第一个个人目标。<br><a id="more"></a></p>
<p><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Fcoursera-machine-learning-cert" alt="cert"></p>
<h1 id="过程值的回忆">过程值的回忆</h1><p>过去的十周内，有多少个夜深人静的夜晚，当他人已经进入梦乡，我仍在观看着视频、调试着程序。期间也经历了突击课程进度的艰难过程，为的是能提前完成春节期间的课程。大多数的课程都开始于下班回家，且给闺女讲完睡前故事之后，通常是晚上9点以后了。</p>
<p>课程注册之初，大致预测了一下可能会遇到的困难，总结有：数学的障碍，<a href="http://www.gnu.org/software/octave/" target="_blank" rel="external">Octave</a>陌生的语言，时间问题（晚上要先陪闺女玩儿）等等。然而最终的事实证明，这些都不是问题。而最大的问题是：宽带通！（此处预留一个<a href="http://blog.liushuping.com/2016/02/23/I-will-call-you-back/">Callback</a>，待以后详解。）</p>
<h1 id="目标要以总结结束">目标要以总结结束</h1><p>学完一门课程，做一些简单的总结，总是有好处的。喜欢对一件复杂的事情做一些通俗易懂的描述，让尽可能多的人理解（显然，我无法做到让隔壁的老奶奶也能听懂的极致）。数学公式是尽量避免去用的，虽然它是Machine Learning的灵魂，但是概念性的普及介绍却不必使用它。</p>
<p>Machine Learning很有趣，很有用，也很有挑战性。它又依赖于系统的软件工程。</p>
<ul>
<li>有趣：<a href="http://www.msxiaoice.com/DesktopLanding" target="_blank" rel="external">微软小冰</a>等有趣应用都是Machine Learning的具体应用</li>
<li>有用：照片、文字识别，自动驾驶等等极大地方便了生活</li>
<li>挑战：参考Google的<a href="http://baike.baidu.com/item/%E9%98%BF%E5%B0%94%E6%B3%95%E5%9B%B4%E6%A3%8B?fromtitle=AlphaGo" target="_blank" rel="external">阿尔法狗(AlphaGo)</a></li>
<li>软件工程：只有良好的系统架构、编码才能实现真正的Machine Learning应用</li>
</ul>
<p>用简短的话介绍<a href="https://www.coursera.org/" target="_blank" rel="external">Coursera</a>上<a href="http://baike.baidu.com/view/10853998.htm?fromtitle=Andrew+Ng" target="_blank" rel="external">Andrew Ng</a>的<a href="https://www.coursera.org/learn/machine-learning" target="_blank" rel="external">Machine Learning</a>课程。我的片面总结如下：</p>
<h2 id="Machine_Learning之基本思路">Machine Learning之基本思路</h2><p>Machine Learning用大量的数据，通过一定的学习算法让计算机具有一定的“智能”，比如预测、分类等。在面对大量数据时，计算机不可能一次完成学习任务，因此我们需要设计一个“渐进”的学习方式，让计算机逐渐完善其“智能”水平。这个“渐进”的过程，在程序代码的领域来讲，就是“迭代”。不断地迭代，调整参数，从而达到提高机器“学习”效果的目的。</p>
<h2 id="Machine_Learning“之学习效果”的评估">Machine Learning“之学习效果”的评估</h2><p>如何在迭代的基本框架下，来评价当前参数下的“学习”效果呢？我们很容易想到的是建立一个误差函数，对已知的输入数据，应用当前的学习算法，得到预测的结果。根据预测的结果和实际结果，计算<a href="http://baike.baidu.com/view/172036.htm" target="_blank" rel="external">方差</a>或<a href="http://baike.baidu.com/view/78339.htm" target="_blank" rel="external">标准差</a>，即可以作为我们的误差函数。这种以已知数据作为参考的“学习”过程被称为<a href="http://baike.baidu.com/view/2759226.htm" target="_blank" rel="external">“监督学习”</a>或<a href="https://en.wikipedia.org/wiki/Supervised_learning" target="_blank" rel="external">“Supervised Learning”</a>。而<a href="http://baike.baidu.com/view/2759226.htm" target="_blank" rel="external">“监督学习”</a>又可分为<a href="http://baike.baidu.com/view/449540.htm" target="_blank" rel="external">“线性回归”</a>(<a href="https://en.wikipedia.org/wiki/Linear_regression" target="_blank" rel="external">“Linear Regression”</a>)和<a href="http://baike.baidu.com/item/logistic%E5%9B%9E%E5%BD%92?fromtitle=%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92&amp;type=syn" target="_blank" rel="external">“逻辑回归”</a>(<a href="https://en.wikipedia.org/wiki/Logistic_regression" target="_blank" rel="external">“Logistic Regression”</a>)等常见类别。</p>
<h2 id="Machine_Learning之“学习方法”的改善">Machine Learning之“学习方法”的改善</h2><p>通常我们从随机化学习算法的参数开始，因为参数是我们最终要得到的，而开始之初我们并不知道它。因此我们希望每一步迭代都对参数做微小的改动，以使算法结果不断<a href="http://baike.baidu.com/subview/513233/8059330.htm" target="_blank" rel="external">“收敛”</a>，又或者说是使误差函数产生的结果越来越小。那么怎么做呢？</p>
<p>假如我们把误差函数画出来，以三维的一个曲面为例（高维空间无法绘制，但是具有相同的性质），误差函数结果最小的点就是三维曲面的最低点。我们的目标就是采取一种有效的措施来改变参数使误差函数的结果沿着三维空间坡度最陡的方向向下移动。用数学的概念来介绍，就是<a href="http://baike.baidu.com/view/30958.htm" target="_blank" rel="external">导数</a>，或者更准确一点，<a href="http://baike.baidu.com/view/1029405.htm" target="_blank" rel="external">偏导数</a>。因此，迭代过程内对参数做的微小改动就是对每个参数减去该参数所对应“特征”的<a href="http://baike.baidu.com/view/1029405.htm" target="_blank" rel="external">偏导数</a>。</p>
<p>参数的这种改变方式从本质上来说是<a href="http://baike.baidu.com/view/150456.htm" target="_blank" rel="external">连续</a>的，它适合被用在<a href="http://baike.baidu.com/view/449540.htm" target="_blank" rel="external">“线性回归”</a>问题上。但当一个问题是<a href="http://baike.baidu.com/item/logistic%E5%9B%9E%E5%BD%92?fromtitle=%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92&amp;type=syn" target="_blank" rel="external">“逻辑回归”</a>（如根据某些数据判断某个操作是否来自于人或机器等这种是非问题的判断）时怎么办呢？其实很简单：只需对<a href="http://baike.baidu.com/view/449540.htm" target="_blank" rel="external">“线性回归”</a>问题的学习方程进行一次转换，使其输出结果只有两种可能：0或1。适合这个问题的一个常用函数是<a href="http://baike.baidu.com/view/1176976.htm" target="_blank" rel="external">sigmoid函数</a>。关于<a href="http://baike.baidu.com/view/1176976.htm" target="_blank" rel="external">sigmoid函数</a>，此处也留一个<a href="http://blog.liushuping.com/2016/02/23/I-will-call-you-back/">Callback</a>。</p>
<h2 id="Machine_Learning之人工神经网络">Machine Learning之人工神经网络</h2><p><a href="http://baike.baidu.com/view/449540.htm" target="_blank" rel="external">“线性回归”</a>和<a href="http://baike.baidu.com/item/logistic%E5%9B%9E%E5%BD%92" target="_blank" rel="external">“逻辑回归”</a>都是通过建立一个<a href="http://baike.baidu.com/view/6156797.htm" target="_blank" rel="external">多项式函数</a>来实现对训练数据最大程度的拟合，比如最简单的函数 <code>y = ax + b</code>。<a href="http://baike.baidu.com/view/449540.htm" target="_blank" rel="external">“线性回归”</a>和<a href="http://baike.baidu.com/item/logistic%E5%9B%9E%E5%BD%92" target="_blank" rel="external">“逻辑回归”</a>的任务都是通过迭代来不断优化参数<code>a</code>和<code>b</code>(对于一阶方程来说)来实现最大程度地减少误差。然而，有很多问题我们很难找到一个合适的<a href="http://baike.baidu.com/view/6156797.htm" target="_blank" rel="external">多项式函数</a>来对数据进行<a href="http://baike.baidu.com/subview/133261/5033269.htm" target="_blank" rel="external">数学建模</a>，或者是<a href="http://baike.baidu.com/view/6156797.htm" target="_blank" rel="external">多项式函数</a>过于复杂，带来的计算量非常大。这时可以考虑使用<a href="http://baike.baidu.com/view/19743.htm" target="_blank" rel="external">人工神经网络</a>。</p>
<p>概括地来说，<a href="http://baike.baidu.com/view/19743.htm" target="_blank" rel="external">人工神经网络</a>的<a href="http://baike.baidu.com/subview/133261/5033269.htm" target="_blank" rel="external">数学模型</a>是一个由很多节点组成的网状结构。每个节点都是一个处理单元，能对接收到的数据做计算，其输出结果将是下层网络节点的计算输入。通过调节网络的层数、每层上计算节点的个数，以及对每个节点的参数等来优化<a href="http://baike.baidu.com/subview/133261/5033269.htm" target="_blank" rel="external">数学模型</a>，从而实现对训练数据的模拟，以及对未来数据的分析预测。<a href="http://baike.baidu.com/view/19743.htm" target="_blank" rel="external">人工神经网络</a>是一个很大的话题，本文仅做一般认识性介绍。</p>
<h2 id="Machine_Learning之聚类分析">Machine Learning之聚类分析</h2><p>然而，并不是所有的问题都是根据历史数据预测未来结果。还有一类问题是：给定一些数据，让计算机智能地对数据进行分类。这类问题叫<a href="http://baike.baidu.com/view/903740.htm" target="_blank" rel="external">“聚类分析”</a>，解决这类问题的一个重要算法是“<a href="http://baike.baidu.com/view/3066906.htm" target="_blank" rel="external">K均数</a>”算法。这个算法是如此简单而有效地应用了基本的数学知识对数据进行了分类！我强烈推荐您了解一下。</p>
<h2 id="Machine_Learning之主成份分析">Machine Learning之主成份分析</h2><p>对于给定的数据，在有些情况下数据所包涵的众多特征中，仅有几个特征起主导作用。此时，我们可以对数据进行<a href="http://baike.baidu.com/view/45376.htm" target="_blank" rel="external">主成分分析(Principle Component Analysis)</a>，选取几个主要成份来代表数据，从而达到数据压缩的目的。比如，要对某大量数据做Machine Learning分析，但发现由于数据太大，计算过程非常耗时，此时可以尝试用主成份分析来对数据进行压缩。<a href="http://baike.baidu.com/view/45376.htm" target="_blank" rel="external">主成分分析</a>的另外一个应用是图像的压缩，可以通过分析图像的前16种主颜色成份，把图像从256色压缩到16色。</p>
<h2 id="Machine_Learning之性能优化">Machine Learning之性能优化</h2><p>性能优化永远是Machine Learning领域的一个重要话题，因为数据容量是如此之大，每一点计算过程的优化都有可能带来整体效率上的显著提高。在<a href="http://baike.baidu.com/view/10853998.htm?fromtitle=Andrew+Ng" target="_blank" rel="external">Andrew Ng</a>的<a href="https://www.coursera.org/learn/machine-learning" target="_blank" rel="external">Machine Learning</a>课程中最让人拍案叫绝的一段数学证明是<a href="https://en.wikipedia.org/wiki/Support_vector_machine" target="_blank" rel="external">Support Vector Machine</a>如何有效地改善了<a href="http://baike.baidu.com/view/2759226.htm" target="_blank" rel="external">“监督学习”</a>中的分类算法。</p>
<p>另一个重要的性能优化则完全来自于计算机科学，那就是<a href="https://en.wikipedia.org/wiki/Array_programming" target="_blank" rel="external">Vectorization</a>。最擅长做<a href="https://en.wikipedia.org/wiki/Array_programming" target="_blank" rel="external">Vectorization</a>的是<a href="https://en.wikipedia.org/wiki/Graphics_processing_unit" target="_blank" rel="external">GPU</a>，当然现如今的大多数<a href="https://en.wikipedia.org/wiki/Central_processing_unit" target="_blank" rel="external">CPU</a>也已经支持<a href="https://en.wikipedia.org/wiki/Array_programming" target="_blank" rel="external">Vectorization</a>了。因此，在代码的实现上，软件工程师时刻牢记<a href="https://en.wikipedia.org/wiki/Array_programming" target="_blank" rel="external">Vectorization</a>的实现方式是至关重要的。</p>
<p>然而无论如何，超大规模的Machine Learning是不可能在一台机器上完成的，当需要在多台甚至成千上万台机运行时，就需要<a href="http://baike.baidu.com/view/2902.htm" target="_blank" rel="external">MapReduce</a>等类似的分布式框架来帮忙了。</p>
<h1 id="结论">结论</h1><p>Machine Learning很有趣，它需要一些数学知识、算法和软件工程思想来实现。<a href="http://baike.baidu.com/view/10853998.htm?fromtitle=Andrew+Ng" target="_blank" rel="external">Andrew Ng</a>的<a href="https://www.coursera.org/learn/machine-learning" target="_blank" rel="external">Machine Learning</a>课程深入浅出，循序渐进，有趣，有料！</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="完成了一个目标">完成了一个目标</h1><p>经过了十周多的奋斗，我终于完成了<a href="http://baike.baidu.com/view/10853998.htm?fromtitle=Andrew+Ng">Andrew Ng</a>的<a href="https://www.coursera.org/learn/machine-learning">Machine Learning</a>课程并获得证书，这也是2016年我完成的第一个个人目标。<br>]]>
    
    </summary>
    
      <category term="Coursera" scheme="http://blog.liushuping.com/tags/Coursera/"/>
    
      <category term="Machine Learning" scheme="http://blog.liushuping.com/tags/Machine-Learning/"/>
    
      <category term="Stanford" scheme="http://blog.liushuping.com/tags/Stanford/"/>
    
      <category term="Machine Learning" scheme="http://blog.liushuping.com/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[I will call you back]]></title>
    <link href="http://blog.liushuping.com/2016/02/23/I-will-call-you-back/"/>
    <id>http://blog.liushuping.com/2016/02/23/I-will-call-you-back/</id>
    <published>2016-02-23T15:05:38.000Z</published>
    <updated>2016-02-23T17:00:17.000Z</updated>
    <content type="html"><![CDATA[<p>春节前夕，一个偶然的机会我粗略地研究了一下ES6里异步代码的实现方式－－生成器（Generator），过程很是烧脑。决定首先重新审视一下JavaScript原有的异步代码实现方式－－回调（CallBack）。审视之初，大脑不由自主地发挥想象，滑稽却有趣。</p>
<h1 id="好莱坞原则">好莱坞原则</h1><p>Callback这个词几乎会出在现每日的工作中，平淡无奇，而此刻多年前的一个概念却突然浮现－－好莱坞原则：“Don’t call us, We will call you”。第一次了解到这个原则还是多年前学习设计模式时，那时好莱坞原则被用来说明观察者(Observer)等模式。当然，这个原则的本意是说“不要轮询来问我们，我们会通知你消息的”，这也很好地解释了观察者模式。</p>
<p><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Fhollywood.jpg" alt="image"></p>
<a id="more"></a>
<p>Callback让我回忆起了好莱坞原则，而好莱坞原则却貌似跟Callback没有直接关系。大脑接着想到了几年前参加的一个JavaScript会议中某演讲者讲的一个关于Callback的冷故事。我决定再一次地尝试对不同听众讲这个故事，并观察其反应。</p>
<p>除夕，看晚会，放烟花，没抢红包，当然更没咻。</p>
<h1 id="一个故事">一个故事</h1><p>春节后的一个下午，陪着闺女还有一个侄女玩耍。侄女提议讲故事玩，我和闺女都高兴地答应了。同时我也不怀好意地想到了那个关于Callback的故事，或者说是个笑话吧。</p>
<p>三个人依次按照顺序讲故事，侄女首先讲了一个《三只小猪》的故事，我们鼓掌表示鼓励。</p>
<p><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2F3_pigs.jpg" alt="image"></p>
<p>然后是我，讲了一个《白巧克力和黑巧克力》的故事，内容大致如下：</p>
<p>从前，有一块白巧克力和一块黑巧克力，他们在一起玩儿。白巧克力对黑巧克力说：“我们每人讲一个笑话给对方听吧，如果不能令对方发笑，就要被扔进大海里”。黑巧克力先讲了一个笑话，白巧克力没有笑，把黑巧克力扔进了大海。</p>
<p>侄女鼓掌表示故事好听，闺女像理解了我的套路似的（我之前没有跟闺女讲过该故事），仅仅象征性地拍了一下手掌。</p>
<p>接下来是闺女讲故事，她没有按套路出牌，而是给我们背了一首幼儿园学到的儿歌。当然，我和侄女也给了热烈的掌声。</p>
<p>故事进行到了第二轮，侄女又讲了一个《小红帽》的故事。</p>
<p><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Fxiaohongmao.png" alt="image"></p>
<p>然后又是我，讲了一个《两个小朋友钓鱼》的故事，内容大致如下：</p>
<p>从前，有两个好朋友，他们都很喜欢钓鱼。一天，他们像往常一样来到大海边开始钓鱼，不一会儿其中的一个小朋友就发现了鱼竿的晃动。于是他使劲往岸上拉，然而鱼竿似乎比往常重很多。终于在小伙伴的帮忙下，他把鱼钩拉上来了。猜：他们钓上什么来了？我对着侄女和闺女问。</p>
<p>侄女和闺女马上回答说是鱼。我提示我之前讲了一个《白巧克力和黑巧克力》的故事。话音未落，侄女马上回答说“钓上来的是黑巧克力”。我问为什么？她说，因为黑巧克力讲的笑话没使白巧克力笑，就被扔进大海里了，所以就被钓上来了。此刻，我可以验证，那次JavaScript会议上那位演讲者所讲的这个关于Callback的故事是成功的。</p>
<p>之后，小侄女又两次要求我重复讲述了《两个小朋友钓鱼》的故事，因为她说这个故事很好听！</p>
<h1 id="I_will_call_you_back!">I will call you back!</h1><p>在不少影视剧中，经常能看到这样的剧情：一个人在接电话，在简短的交谈后他会说一句“I’ll call you back”（或者国产剧的“我再打给你”），然后结束通话。这应该就是Callback的最初起源。</p>
<p>通话开始的简短交谈应该是Callback的“初始化”过程，它提供了足够的信息给Callback，以保证Callback能在正确的时刻以正确的方式发生。</p>
<p>一句“I’ll call you back”之后通话被结束，这是异步的本质。整个事情的处理过程尚未结束，当前过程挂起（hang up），后续过程等待由被呼叫者主动唤醒。唤醒过程被称之为Callback。</p>
<p>被呼叫者在完成相关任务后，呼叫主呼叫者，这是Callback的执行过程。被呼叫者呼叫主呼叫者的过程通常是以“我是谁谁谁”，“我们之前说的什么事”等等方式来提醒主呼叫者回忆起要处理的事情。这个过程叫Context restore。</p>
<p>如果你清楚了这个过程，就应该不难理解C# async里面的ConfigureAwait(boold)的作用了；也会更加清楚为什么有时代码会出现Context(如ASP.NET Context)丢失的问题了。</p>
<h1 id="Call_back">Call back</h1><p>好吧，思绪就飞这么远吧。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>春节前夕，一个偶然的机会我粗略地研究了一下ES6里异步代码的实现方式－－生成器（Generator），过程很是烧脑。决定首先重新审视一下JavaScript原有的异步代码实现方式－－回调（CallBack）。审视之初，大脑不由自主地发挥想象，滑稽却有趣。</p>
<h1 id="好莱坞原则">好莱坞原则</h1><p>Callback这个词几乎会出在现每日的工作中，平淡无奇，而此刻多年前的一个概念却突然浮现－－好莱坞原则：“Don’t call us, We will call you”。第一次了解到这个原则还是多年前学习设计模式时，那时好莱坞原则被用来说明观察者(Observer)等模式。当然，这个原则的本意是说“不要轮询来问我们，我们会通知你消息的”，这也很好地解释了观察者模式。</p>
<p><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Fhollywood.jpg" alt="image"></p>]]>
    
    </summary>
    
      <category term="Async" scheme="http://blog.liushuping.com/tags/Async/"/>
    
      <category term="JavaScript" scheme="http://blog.liushuping.com/tags/JavaScript/"/>
    
      <category term="Software" scheme="http://blog.liushuping.com/categories/Software/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[非windows平台上的.NET开发]]></title>
    <link href="http://blog.liushuping.com/2016/02/02/%E5%9C%A8%E9%9D%9EWindows%E5%B9%B3%E5%8F%B0%E4%B8%8A%E7%9A%84-NET%E5%BC%80%E5%8F%91/"/>
    <id>http://blog.liushuping.com/2016/02/02/在非Windows平台上的-NET开发/</id>
    <published>2016-02-02T14:25:39.000Z</published>
    <updated>2016-03-18T00:36:25.000Z</updated>
    <content type="html"><![CDATA[<p>长久以来，开发人员只能在Windows平台上进行.NET开发。在其它平台上，如Linux上只能依赖第三方的运行时，例如著名的<a href="http://www.mono-project.com/" target="_blank" rel="external">Mono</a>。但是从.NET  5开始，微软官方发布了真正跨平台的.NET运行环境<a href="https://github.com/dotnet/coreclr" target="_blank" rel="external">.NET Core</a>。.NET 的跨平台也步入了新的台阶。</p>
<a id="more"></a>
<p>本文介绍了如何在Mac上以C#进行.Net Core 5.0程序的开发。</p>
<h1 id="步骤概述">步骤概述</h1><p>不论是在Windows，Mac还是Linux平台上，.Net Core 5.0程序的开发都可以简要的总结为下列几个步骤：</p>
<ol>
<li>安装<a href="https://github.com/aspnet/dnvm/" target="_blank" rel="external">DNVM</a> - .NET版本管理器</li>
<li>通过DNVM安装指定版本的.NET CLR</li>
<li>创建.NET项目工程并编写代码</li>
<li>执行命令<code>dnu restore</code> － 安装程序运行依赖包(NuGet格式)</li>
<li>执行<code>dnx &lt;command&gt;</code> － 运行程序</li>
</ol>
<h1 id="安装DNVM">安装DNVM</h1><p><code>DNVM</code>是Dot Net Version Manager的缩写，它由几个脚本文件（Windows上PowerShell文件，Linux及Mac OS上是Shell文件）组成。按照<a href="https://docs.asp.net/en/latest/getting-started/installing-on-mac.html" target="_blank" rel="external">ASP官网</a>，通过下列命令来在Mac上下载并安装<code>DNVM</code>：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https://raw.githubusercontent.com/aspnet/Home/dev/dnvminstall.sh | DNX_BRANCH=dev sh &#38;&#38; source ~/.dnx/dnvm/dnvm.sh</span><br></pre></td></tr></table></figure></p>
<p>安装完成后，可以在Terminal下执行<code>DNVM</code>：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnvm</span><br></pre></td></tr></table></figure></p>
<p>如要列出机器上当前所安装的所有.NET 版本：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnvm list</span><br></pre></td></tr></table></figure></p>
<h1 id="安装CLR">安装CLR</h1><p>通过<code>DNVM</code>所管理的.NET 可以分为两类：.NET 4.5和.NET 5 Core。.NET 4.5在Mac上是基于Mono的，本文介绍的.NET 5 Core不依赖Mono，可以通过如下命令安装:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnvm upgrade -r coreclr</span><br></pre></td></tr></table></figure></p>
<p>安装完成后，可以通过<code>dnvm list</code>来查看所有已经安装的.NET 。例如我的电脑当前安装的版本信息显示如下：<br><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">Active</span> <span class="comment">Version</span>              <span class="comment">Runtime</span> <span class="comment">Architecture</span> <span class="comment">OperatingSystem</span> <span class="comment">Alias</span></span><br><span class="line"><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>              <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span></span><br><span class="line">       <span class="comment">1</span><span class="string">.</span><span class="comment">0</span><span class="string">.</span><span class="comment">0</span><span class="literal">-</span><span class="comment">rc1</span><span class="literal">-</span><span class="comment">final</span>      <span class="comment">coreclr</span> <span class="comment">x64</span>          <span class="comment">darwin</span>          </span><br><span class="line">  <span class="comment">*</span>    <span class="comment">1</span><span class="string">.</span><span class="comment">0</span><span class="string">.</span><span class="comment">0</span><span class="literal">-</span><span class="comment">rc1</span><span class="literal">-</span><span class="comment">update1</span>    <span class="comment">coreclr</span> <span class="comment">x64</span>          <span class="comment">darwin</span>          <span class="comment">default</span></span><br></pre></td></tr></table></figure></p>
<p>第一列中标星号的版本代表了当前默认版本，因此在该机器上的.NET 代码会被编译到该目标.NET 平台下。如果要切换目标.NET 平台，可以通过命令<code>dnvm use</code>来实现。具体使用方式，可以查看<code>DNVM</code>帮助。</p>
<h1 id="创建-NET项目">创建.NET项目</h1><p>前面的两步完成了对机器能编译运行.NET 程序的全部配置，因此可以进行.NET 的程序开发。然而从一个完全空白的文件或文件夹开始写源代码是非常不方便的。通常我们需要一个创建项目的模板，或者近几年更流行的名称是“脚手架”。针对.NET  5平台的脚手架的实现上，微软采取了充分利用开源社区资源的做法，既节省了成本又提高了广大开发者的认同度。</p>
<p>微软采取了通过<a href="https://www.npmjs.com/package/yo" target="_blank" rel="external">Yoeman</a>这个基于Node跨平台的脚手架工具来实现.NET  5项目工程文件创建的目的。具体地说，它开发了一个Yomean的插件<a href="https://www.npmjs.com/package/generator-aspnet" target="_blank" rel="external">generator-aspnet</a>来作为.NET 5的脚手架。</p>
<p>在Node的提示符下，输入如下命令可以进入.NET  5项目工程生成的引导步骤中：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">yo</span> aspnet</span><br></pre></td></tr></table></figure></p>
<p>值得一提的是，虽然命令行的参数叫<code>aspnet</code>，但是它却能创建大多数常见的.NET 工程类型，如<code>Console</code>, <code>UnitTest</code>等等。</p>
<h1 id="安装程序依赖包">安装程序依赖包</h1><p>.NET  5的所有依赖项都是通过NuGet来进行管理的，而这些依赖项都注册在工程主文件<code>project.json</code>中。通过脚手架生成的工程并没有把所依赖的包安装下载到工程所在目录。因此需要运行下面的命令来加载所有依赖项：<br><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnu <span class="built_in">restore</span></span><br></pre></td></tr></table></figure></p>
<h1 id="运行程序">运行程序</h1><p>运行程序所要执行的命令是<code>dnx</code>，其参数根据项目工程不同而不同，可以参考<code>project.json</code>文件中的<code>commands</code>属性。比如<code>Unit Test</code>的项目的<code>commands</code>属性是这样子的:<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"commands"</span>: &#123;</span><br><span class="line">    <span class="string">"test"</span>: <span class="string">"xunit.runner.dnx"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因此，运行该工程的命令是<code>dnx test</code>。如果执行<code>dnx</code>命令前并没有执行<code>dnu</code>命令，则<code>dnx</code>会先执行<code>dnu</code>。</p>
<h1 id="演示">演示</h1><p><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Faspnet-sample.gif" alt="demo"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>长久以来，开发人员只能在Windows平台上进行.NET开发。在其它平台上，如Linux上只能依赖第三方的运行时，例如著名的<a href="http://www.mono-project.com/">Mono</a>。但是从.NET  5开始，微软官方发布了真正跨平台的.NET运行环境<a href="https://github.com/dotnet/coreclr">.NET Core</a>。.NET 的跨平台也步入了新的台阶。</p>]]>
    
    </summary>
    
      <category term=".NET" scheme="http://blog.liushuping.com/tags/NET/"/>
    
      <category term="Cross-Platform" scheme="http://blog.liushuping.com/tags/Cross-Platform/"/>
    
      <category term=".NET" scheme="http://blog.liushuping.com/categories/NET/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[微软跨平台及开源的执行力之我见]]></title>
    <link href="http://blog.liushuping.com/2016/01/23/%E5%BE%AE%E8%BD%AF%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%8F%8A%E5%BC%80%E6%BA%90%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8A%9B%E4%B9%8B%E6%88%91%E8%A7%81/"/>
    <id>http://blog.liushuping.com/2016/01/23/微软跨平台及开源的执行力之我见/</id>
    <published>2016-01-23T13:18:04.000Z</published>
    <updated>2016-01-29T12:54:36.000Z</updated>
    <content type="html"><![CDATA[<p>首先说明，本文不是给微软写的软文，而是对微软近些年在跨平台以及开源社区等领域所做努力的一些个人所见。好多人说微软做的越来越不行了，好多产品越来越不好用或者不明白为啥那样做等等。然而，我却看到了不太一样的微软。</p>
<p>科技公司在经历长期的发展壮大后会变成老牌企业，而老牌的IT企业在面对新兴的互联网领域时经常会表现出转型、创新困难，抓不住机会的尴尬状况。除IBM是一个典型代表外，微软也已经归为IT老牌企业的行列了。然而，个人所见微软在面对互联网的浪潮时在跨平台及开源领域的执行力以及进展还是有卓越成果的。</p>
<a id="more"></a>
<h1 id="-NET">.NET</h1><p>.NET 是微软在开发领域的一个主力产品，是Java等其它基于虚拟机产品的有力竞争对手。长期以来.NET是闭源的，而它所声称的跨平台性在其它平台如Linux上也只能靠其它三方产品来实现，如<a href="http://www.mono-project.com/" target="_blank" rel="external">Mono</a>。近几年微软意识到了开源社区的力量，因此也对.NET 的Runtime(CLR)和Framework做了开源：</p>
<ul>
<li>CoreClr: <a href="https://github.com/dotnet/coreclr" target="_blank" rel="external">https://github.com/dotnet/coreclr</a></li>
<li>ColreFx: <a href="https://github.com/dotnet/corefx" target="_blank" rel="external">https://github.com/dotnet/corefx</a></li>
</ul>
<p>在.NET领域，除CLR和Framework之外编译器是另一个重要的角色。微软在多年前启动了<a href="http://www.eweek.com/c/a/Application-Development/Microsoft-Delivers-Roslyn-Compiler-as-a-Service-Preview-455946" target="_blank" rel="external">Compiler as a Service</a>的Roslyn项目。之后整个<a href="https://github.com/dotnet/roslyn" target="_blank" rel="external">Roslyn</a>的源代码也开源在Github上。<br><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2FRoslyn.jpg" alt="Roslyn">(图片来源：<a href="http://goo.gl/HCyxMB" target="_blank" rel="external">http://goo.gl/HCyxMB</a>)</p>
<p>虽然说.NET CLR+Framework+Compiler(Roslyn)几乎是.NET的全部，有了它们就可以做完全的.NET研究和开发，然而.NET的工程构建还是一套复杂的系统，微软是通过MSBuild来管理它的，并对<a href="https://github.com/Microsoft/msbuild/" target="_blank" rel="external">MSBuild进行了开源</a>。</p>
<p>做了这些工作后，可以说微软已经完全拥抱开源和跨平台了，通过<a href="http://dotnet.github.io/" target="_blank" rel="external">http://dotnet.github.io/</a> 你可以找到.NET Core的很多信息，从中可以看到.NET现在官方支持下列平台：</p>
<ul>
<li>Windows </li>
<li>Debian</li>
<li>Ubuntu</li>
<li>CentOS</li>
<li>OpenSuSE</li>
<li>Mac OS</li>
<li>Free BSD</li>
</ul>
<p>最后考虑到了在不同平台上配置不同的.NET Runtime，Framework以及编译等工作的复杂性，微软又推出了.NET的执行环境(Execution Environment)－－<a href="https://github.com/aspnet/dnx" target="_blank" rel="external">DNX</a>。通过它，开发人员可以快速简单地在任何支持的平台上配置好.NET开发及运行环境。当然，它也是开源的。</p>
<h1 id="Web">Web</h1><p>Web是互联网的关键字之一，在微软阵营Web就是IIS，ASP.NET和MVC了。把ASP.NET以及MVC开源出来是微软在Web上的第一步：</p>
<ul>
<li>ASP.NET: <a href="https://github.com/aspnet/home" target="_blank" rel="external">https://github.com/aspnet/home</a></li>
<li>MVC: <a href="https://github.com/aspnet/Mvc" target="_blank" rel="external">https://github.com/aspnet/Mvc</a></li>
</ul>
<p>ASP.NET是一个集合，除MVC之外还包含了EntityFramework和Identity等诸多库。然后在.NET开源及跨平台的基础上，ASP.NET和MVC在其它平台上的开发和运行就变成了可能。当然这里有个障碍需要清除：ASP.NET及MVC运行所依赖的IIS环境是不存在于其它平台（如Linux）的。因此微软大刀阔斧地对其Web生态(Ecosystem)做了重大的变革－－IIS已经不是必须的运行环境，取而代之的是微软重新实现了一个开源跨平台的Web服务器<a href="https://github.com/aspnet/KestrelHttpServer" target="_blank" rel="external">Kestrel</a>， 为ASP.NET的跨平台扫清了最后的障碍。值得一提的是，在实现Kestrel时，微软拥抱社区，采取了基于社区的成熟组件的架构－－Kestrel是基于<a href="https://github.com/libuv/libuv" target="_blank" rel="external">libuv</a>的，而libuv又是Node.js的HTTP请求处理引擎。</p>
<p><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Faspnet_vs2015.png" alt="ASP.NET and Visual Studio 2015">(图片来源：<a href="http://goo.gl/TFg1dF" target="_blank" rel="external">http://goo.gl/TFg1dF</a>)</p>
<h1 id="浏览器与JavaScript">浏览器与JavaScript</h1><p>IE浏览器由于历史包袱太沉重，一直受到前端开发者的诟病。微软也是壮士断腕决定<a href="http://tech.qq.com/a/20150802/004144.htm" target="_blank" rel="external">停止IE</a>这个产品。要想在互联网上走的远，一定要做出一些革命性的变革，微软推出的下一代浏览器<a href="http://www.microsoft.com/en-us/windows/microsoft-edge" target="_blank" rel="external">Edge</a>以全新的面貌出现。从终端用户角度来看，虽不完美但值的期待。但从开发者角度来看，这绝对是革命性的，因为Edge浏览器引擎代码<a href="https://github.com/Microsoft/ChakraCore" target="_blank" rel="external">Chakra开源了</a>。</p>
<p><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Fchakra-componentization.png" alt="Chakra Core">(图片来源：<a href="https://goo.gl/YsW8Eh" target="_blank" rel="external">https://goo.gl/YsW8Eh</a>)</p>
<p>开放Chakra源代码意味着在服务器端JavaScript引擎不再只有<a href="https://en.wikipedia.org/wiki/V8_(JavaScript_engine" target="_blank" rel="external">Google V8</a>一个选择，Node.js或许可以运行在Chakara上了。事实上，截止日期2016-01-23，已经有人实现了在Chakra上运行Node了，并给Node.js提了一个<a href="https://github.com/nodejs/node/pull/4765" target="_blank" rel="external">Pull Request</a>。</p>
<p>在语言层面上，微软的大神，Techinical Fellow, Anders Hejlsberg很早就对JavaScript做了全面的分析，并以开源的形式推出JavaScript的超集(super set) －－ <a href="https://github.com/Microsoft/TypeScript" target="_blank" rel="external">TypeScript</a>。 之后，微软的另一个大神Erich Gamma（Design Pattern作者GoF之一）领导了一个团队用TypeScript开发了非常好用的编辑器<a href="https://code.visualstudio.com/" target="_blank" rel="external">VSCode</a>。VSCode也并不是微软从0开始开发的一个新编辑器，而是基于<a href="https://github.com/atom/electron" target="_blank" rel="external">Electron</a>开发的。Github自家的编辑器<a href="https://github.com/atom/atom" target="_blank" rel="external">Atom</a>也是基于Electron的。</p>
<h1 id="标准">标准</h1><p>开发工具的跨平台和开源之外，微软还不遗余力地参与或主导了很多标准及协议的定制。例如.NET的开放Web接口<a href="http://owin.org/" target="_blank" rel="external">OWIN</a>。 </p>
<p><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2FOWIN-0.png" alt="OWIN">(图片来源：<a href="http://goo.gl/fE1xdp" target="_blank" rel="external">http://goo.gl/fE1xdp</a>)</p>
<p><a href="http://www.amqp.org/" target="_blank" rel="external">AMQP</a> 也是微软积极参与的一个协议。在微软的Azure云中，AMQP是一个重要的协议。类似的微软主导或参与的协议和标准还有很多。这样微软既提高了行业领导力，又增加了产品的跨平台性。</p>
<h1 id="社区">社区</h1><p>近些年来微软既积极地参与各类社区活动又从社区中学到不少做法。这儿列几个仅作为例子：</p>
<ul>
<li><a href="http://www.nuget.org/" target="_blank" rel="external">NuGet</a>。 其包的管理方式完全类似于Ruby，Node等社区的包管理方式。NuGet使.NET的开发模式变的类似其它社区的开发模式，这样大大降低了其它社区开发者参与.NET社区开发或.NET社区开发者参与其它社区开发的学习曲线。<br><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2FNuGet-Stickers.jpg" alt="image">(图片来源：<a href="http://goo.gl/j5HaRq" target="_blank" rel="external">http://goo.gl/j5HaRq</a>)</li>
<li>基于<code>.json</code>的项目管理文件。不同社区使用同样的项目管理文件，这又是一个降低开发人员进入到不同社区时的学习曲线的有效举措。</li>
<li>社区参与的文档开发。对Azure有了解的开发人员会意识到Azure的文档不再按照传统的方式以MSDN来管理了。取而代之的是微软完全把Azure的文档放在GitHub上，任何人都可以对文档，当然包含所有微软开源的代码，进行贡献。</li>
<li>积极参与社区的线上和线下技术活动。不管是微软官方举办的，还是各种第三方举办的活动，不论活动级别大小，总能见到微软。比如说，<a href="http://www.huodongxing.com/" target="_blank" rel="external">活动行</a> 中就有很多微软参与的活动。2015年的<a href="http://www.eepw.com.cn/event/action/IOT2015/schedule.html" target="_blank" rel="external">物联网开发者大会</a>上我也看到了微软的积极参与。其目的自然是宣传其Azure产品，但也足以说明微软对社区的重视和参与度。</li>
</ul>
<h1 id="其它">其它</h1><p>在跨平台上，微软还有其它很多很多的工具或是行动，比如<a href="https://blog.docker.com/2014/10/docker-microsoft-partner-distributed-applications/" target="_blank" rel="external">Windows和Docker的合作</a>。这样分布式系统就可以更容易地跨不同操作系统平台了。</p>
<p><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Fdocker-windows-servers.png" alt="Windows and Docker">(图片来源：<a href="http://goo.gl/sPGd7B" target="_blank" rel="external">http://goo.gl/sPGd7B</a>)</p>
<p>在C/C++的跨平台上，<a href="http://blogs.msdn.com/b/vcblog/archive/2015/12/04/introducing-clang-with-microsoft-codegen-in-vs-2015-update-1.aspx" target="_blank" rel="external">Visual Studio 2015开始支持CLang</a>，从而大大地提高了用Visual Studio编译的C/C++程序的可移植性。</p>
<p>在云平台上，相对于其它产品，Azure有更全面的跨平台开发支持。无论是Windows，Mac，Linux还是ARM，都能找到相关的SDK。我曾经在一个国产的ARM板上不做任何配置成功地安装并运行了Azure的Node版SDK。</p>
<p>在机器学习领域，微软开源了其深度学习的工具箱<a href="https://github.com/Microsoft/CNTK" target="_blank" rel="external">CNTK</a>。</p>
<h1 id="总结">总结</h1><p>个人认为微软在跨平台、开源及行业标准等领域是有很强执行力的，成果也是非常明显的。</p>
<hr>
<p>封面图片：<a href="http://goo.gl/FAUfuk" target="_blank" rel="external">http://goo.gl/FAUfuk</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>首先说明，本文不是给微软写的软文，而是对微软近些年在跨平台以及开源社区等领域所做努力的一些个人所见。好多人说微软做的越来越不行了，好多产品越来越不好用或者不明白为啥那样做等等。然而，我却看到了不太一样的微软。</p>
<p>科技公司在经历长期的发展壮大后会变成老牌企业，而老牌的IT企业在面对新兴的互联网领域时经常会表现出转型、创新困难，抓不住机会的尴尬状况。除IBM是一个典型代表外，微软也已经归为IT老牌企业的行列了。然而，个人所见微软在面对互联网的浪潮时在跨平台及开源领域的执行力以及进展还是有卓越成果的。</p>]]>
    
    </summary>
    
      <category term="Microsoft" scheme="http://blog.liushuping.com/tags/Microsoft/"/>
    
      <category term="OSS" scheme="http://blog.liushuping.com/tags/OSS/"/>
    
      <category term="Microsoft" scheme="http://blog.liushuping.com/categories/Microsoft/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据正规化]]></title>
    <link href="http://blog.liushuping.com/2016/01/04/%E6%95%B0%E6%8D%AE%E6%AD%A3%E8%A7%84%E5%8C%96/"/>
    <id>http://blog.liushuping.com/2016/01/04/数据正规化/</id>
    <published>2016-01-04T14:23:06.000Z</published>
    <updated>2016-01-04T16:00:13.000Z</updated>
    <content type="html"><![CDATA[<p>当对包含不同指标的数据样本进行分析时，数值较高的指标容易在分析中突显作用，而数值较低的指标的作用易被削弱。因此在对数据进行分析之前，需要对数据进行去量纲的正规化处理，使数据分布在相同的区间内。正规化的方法有很多，本文列出三种常用的方法。</p>
<a id="more"></a>
<h1 id="z-score_(zero-mean)_正规化">z-score (zero-mean) 正规化</h1><p>这是最常用的一种正规化方法，从名字中可以看出，经过z-score正规化的数据平均值是0。<br>z-score的公式是：</p>
<p><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Fzero-mean.png" alt="z-score image"></p>
<p>其中μ是样本的平均值（数学期望）</p>
<p><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Fzero-mean-mu.png" alt="z-score mu image"></p>
<p>而σ是样本的标准差(standard deviation)</p>
<p><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Fzero-mean-sigma.png" alt="z-score sigma image"></p>
<p>在数据是全部样本的情况下，标准差的计算中根号内的分母是n；但是在抽样数据的情况下，标准差计算中的根号内的分母是n-1。因为大多数分析数据是抽样数据，所以计算中取n-1。</p>
<p>z-score正规化适合指标的最大最小值未知或有数据超出范围的情况。</p>
<h1 id="min-max_正规化">min-max 正规化</h1><p>min-max正规化是把原始数据映射到[0-1]的无量纲区间内，该方法也叫离差标准化。公式：</p>
<p><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Fmin-max-norm.png" alt="min-max morm image"></p>
<h1 id="归一化">归一化</h1><p>归一化要求分析数据是非负数，该方法把数据映射到[0,1]的无量纲区间内，且所有正规化后的数据总和为1：</p>
<p><img src="http://78rehp.com1.z0.glb.clouddn.com/blog%2Fnorm-to-1.png" alt="归一化公式"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>当对包含不同指标的数据样本进行分析时，数值较高的指标容易在分析中突显作用，而数值较低的指标的作用易被削弱。因此在对数据进行分析之前，需要对数据进行去量纲的正规化处理，使数据分布在相同的区间内。正规化的方法有很多，本文列出三种常用的方法。</p>]]>
    
    </summary>
    
      <category term="Data" scheme="http://blog.liushuping.com/tags/Data/"/>
    
      <category term="Machine Learning" scheme="http://blog.liushuping.com/tags/Machine-Learning/"/>
    
      <category term="Data" scheme="http://blog.liushuping.com/categories/Data/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[nanopi2系统配置]]></title>
    <link href="http://blog.liushuping.com/2016/01/02/nanopi2%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/"/>
    <id>http://blog.liushuping.com/2016/01/02/nanopi2系统配置/</id>
    <published>2016-01-02T03:58:04.000Z</published>
    <updated>2016-01-02T12:36:11.000Z</updated>
    <content type="html"><![CDATA[<p>本文介绍了在nanopi2上安装Debian系统的简要步骤以及安装后的必要配置。</p>
<h1 id="烧录Debian系统">烧录Debian系统</h1><p><a href="http://wiki.friendlyarm.com/wiki/index.php/NanoPi_2/zh" target="_blank" rel="external">Nanopi2 wiki</a>上有对如何安装系统的详细介绍，这里以在Windows系统上安装Debian系统到SD/TF卡为例（安装Android请参考<a href="http://wiki.friendlyarm.com/wiki/index.php/NanoPi_2/zh" target="_blank" rel="external">wiki</a>)</p>
<ul>
<li>首先到<a href="http://wiki.friendlyarm.com/wiki/nanopi2/download/" target="_blank" rel="external">http://wiki.friendlyarm.com/wiki/nanopi2/download/</a> 下载需要的固件例如<code>nanopi2-debian-sd4g.img.zip</code>以及烧写工具<code>win32diskimager.rar</code></li>
<li>下载完成后运行<code>win32diskimager.exe</code>，选取下载的<code>Debian</code>固件，并指定正确的SD/TF卡盘符，然后烧写即可。</li>
</ul>
<p>写入完成后，在Windows上看到的卡容量会是64M。不必担心，这是因为64M是Windows能识别Boot分区，而其它分区是Linux分区，Windows并不能识别。</p>
<p>把TF卡插入Nanopi2的卡位1（靠近电源输入的一端），接入电源即可启动Nanopi2了。</p>
<a id="more"></a>
<h1 id="扩展磁盘分区">扩展磁盘分区</h1><p>通过<code>diskimager</code>写的SD／TF卡是不能很好地直接使用的，此时的系统只占用了大约3GB的空间，并没有足够的空间来安装必要的软件，因此无法用来做开发。在使用之前需要扩展分区空间到整个SD/TF卡空间。</p>
<p>网上介绍的方法是把SD／TF卡接入到一个Linux系统的电脑，并执行以下命令：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo umount <span class="regexp">/dev/</span>sdx</span><br><span class="line">sudo parted <span class="regexp">/dev/</span>sdx unit % resizepart <span class="number">2</span> <span class="number">100</span> unit MB <span class="keyword">print</span></span><br><span class="line">sudo resize2fs -f <span class="regexp">/dev/</span>sdx2</span><br></pre></td></tr></table></figure></p>
<p>其中<code>sdx</code>的<code>x</code>要替换成实际的挂载点，通常是<code>sdb</code>。然而多次尝试后，系统提示各种错误。因此，我尝试了图形化的分区工具<code>gparted</code>，并正确地扩展了分区空间。<br>首先在一台Linux电脑上安装<code>gparted</code><br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> install gparted</span><br></pre></td></tr></table></figure></p>
<p>然后运行<code>gparted</code>图形化分区程序，选取接入的SD／TF卡，会看到有两个分区，选择第二个分区，然后选择卸载，检查。执行操作，分区扩展就完成了。</p>
<h1 id="配置无线连接">配置无线连接</h1><p>Nanopi2 wiki上有无线配置的详细步骤：<a href="http://wiki.friendlyarm.com/wiki/index.php/NanoPi_2/zh" target="_blank" rel="external">http://wiki.friendlyarm.com/wiki/index.php/NanoPi_2/zh</a> 这儿做简要重复：</p>
<ol>
<li>查看WiFi的网络接口：<code>ifconfig -a</code>，以<code>wlan</code>开头的就是<code>wifi</code>，通常是<code>wlan0</code></li>
<li>创建一个以WiFi接口命名的文件<code>vi /etc/network/interfaces.d/wlan0</code>,这儿用的是<code>vi</code>编辑器</li>
<li><p>在<code>wlan0</code>文件中输入以下内容：</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">auto wlan0</span><br><span class="line">iface wlan0 <span class="keyword">inet</span> dhcp</span><br><span class="line">wpa-driver nl80211</span><br><span class="line">wpa-ssid <span class="variable">&lt;YourWiFiESSID&gt;</span></span><br><span class="line">wpa-ap-scan <span class="number">1</span></span><br><span class="line">wpa-psk <span class="variable">&lt;YourWiFiPassword&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>完成编辑后，reboot后即可自动连接无线。</p>
</li>
</ol>
<h1 id="修改root密码">修改root密码</h1><p>默认情况下，<code>root</code>密码是<code>fa</code>，配置好WiFi连接后，系统便接入了互联网，因此为了安全，建议修改<code>root</code>密码：<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sudo</span> passwd</span><br></pre></td></tr></table></figure></p>
<h1 id="SSH连接">SSH连接</h1><p>配置好无线连接后，可以通过SSH连接的方式连接到nanopi2。需要知道无线分配给nanopi2的IP地址，有两种方式：</p>
<ul>
<li>通过HDMI把nanopi2连接到显示器或电视，然后执行命令<code>ifconfig -a</code>来查看</li>
<li>或者在一台属于同一个无线网络的电脑执行命令<code>arp -a</code>来查看所有IP地址。</li>
</ul>
<p>获取IP地址后通过<code>ssh root@&lt;ip address&gt;</code>即可连接。</p>
<h1 id="修改时区及同步时间">修改时区及同步时间</h1><h2 id="修改时区">修改时区</h2><p>初次装的系统并没有设置时区，因此时间是UTC的方式显示。可以通过下面的命令来修改时区：<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sudo</span> dpkg-reconfigure tzdata</span><br></pre></td></tr></table></figure></p>
<p>命令执行后，系统会以图形化的方式引导修改时区。</p>
<h2 id="网络同步时间">网络同步时间</h2><p>由于nanopi2本身并不自带时钟电池，断电后时间设置就会丢失。因此通过NTP服务器动态获取时间的方式可以很好地确保时间的正确性。国内常用的NTP服务器有：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ntp<span class="class">.sjtu</span><span class="class">.edu</span><span class="class">.cn</span> <span class="number">202.120</span>.<span class="number">2.101</span> (上海交通大学网络中心NTP服务器地址）</span><br><span class="line">s1a<span class="class">.time</span><span class="class">.edu</span><span class="class">.cn</span>	北京邮电大学</span><br><span class="line">s1b<span class="class">.time</span><span class="class">.edu</span><span class="class">.cn</span>	清华大学</span><br><span class="line">s1c<span class="class">.time</span><span class="class">.edu</span><span class="class">.cn</span>	北京大学</span><br><span class="line">s1d<span class="class">.time</span><span class="class">.edu</span><span class="class">.cn</span>	东南大学</span><br><span class="line">s1e<span class="class">.time</span><span class="class">.edu</span><span class="class">.cn</span>	清华大学</span><br><span class="line">s2a<span class="class">.time</span><span class="class">.edu</span><span class="class">.cn</span>	清华大学</span><br><span class="line">s2b<span class="class">.time</span><span class="class">.edu</span><span class="class">.cn</span>	清华大学</span><br><span class="line">s2c<span class="class">.time</span><span class="class">.edu</span><span class="class">.cn</span>	北京邮电大学</span><br><span class="line">s2d<span class="class">.time</span><span class="class">.edu</span><span class="class">.cn</span>	西南地区网络中心</span><br><span class="line">s2e<span class="class">.time</span><span class="class">.edu</span><span class="class">.cn</span>	西北地区网络中心</span><br><span class="line">s2f<span class="class">.time</span><span class="class">.edu</span><span class="class">.cn</span>	东北地区网络中心</span><br><span class="line">s2g<span class="class">.time</span><span class="class">.edu</span><span class="class">.cn</span>	华东南地区网络中心</span><br><span class="line">s2h<span class="class">.time</span><span class="class">.edu</span><span class="class">.cn</span>	四川大学网络管理中心</span><br><span class="line">s2j<span class="class">.time</span><span class="class">.edu</span><span class="class">.cn</span>	大连理工大学网络中心</span><br><span class="line">s2k<span class="class">.time</span><span class="class">.edu</span><span class="class">.cn</span> CERNET桂林主节点</span><br><span class="line">s2m<span class="class">.time</span><span class="class">.edu</span><span class="class">.cn</span> 北京大学</span><br></pre></td></tr></table></figure></p>
<p>要通过NTP服务器同步时间，需要用到<code>ntpdate包</code>，通过下面命令安装:<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sudo</span> apt-get <span class="keyword">update</span> ntpdate</span><br></pre></td></tr></table></figure></p>
<p>安装后，通过<code>ntpdate</code>命令指定一个NTP服务器就可以同步时间了:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntpdate ntp<span class="class">.sjtu</span><span class="class">.edu</span><span class="class">.cn</span></span><br></pre></td></tr></table></figure></p>
<p>如果需要定期同步时间，可以通过<code>crontab -e</code>命令并在打开的文件中添加类似下面的一行：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">*</span>/30 <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span> /usr/sbin/ntpdate time.cuit.edu.cn</span><br></pre></td></tr></table></figure></p>
<p>表示系统每30分钟同步一次时间。</p>
<h1 id="修改hostname">修改hostname</h1><p>nanopi2设备默认的名字是<code>nanopi2</code>，例如用ssh以root身份登录系统后的显示如下：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root<span class="variable">@nanopi2</span><span class="symbol">:~</span><span class="comment">#</span></span><br></pre></td></tr></table></figure></p>
<p>可以通过修改<code>/etc/hostname</code>文件内容来修改设备名字。<br>此外，在<code>apt-get install</code>命令安装包时，系统会提示类似<code>cannot resolve hostname nanopi2</code>之类的消息，可以通过修改<code>/etc/host</code>文件，在其中加入一条<code>nanopi2</code>(或是修改后的hostname)记录来解决，例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">27.0</span><span class="number">.0</span><span class="number">.1</span>       localhost</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>      nanopi2</span><br><span class="line">::<span class="number">1</span>            localhost ip6-localhost ip6-loopback</span><br><span class="line">ff02::<span class="number">1</span>        ip6-allnodes</span><br><span class="line">ff02::<span class="number">2</span>        ip6-allrouters</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文介绍了在nanopi2上安装Debian系统的简要步骤以及安装后的必要配置。</p>
<h1 id="烧录Debian系统">烧录Debian系统</h1><p><a href="http://wiki.friendlyarm.com/wiki/index.php/NanoPi_2/zh">Nanopi2 wiki</a>上有对如何安装系统的详细介绍，这里以在Windows系统上安装Debian系统到SD/TF卡为例（安装Android请参考<a href="http://wiki.friendlyarm.com/wiki/index.php/NanoPi_2/zh">wiki</a>)</p>
<ul>
<li>首先到<a href="http://wiki.friendlyarm.com/wiki/nanopi2/download/">http://wiki.friendlyarm.com/wiki/nanopi2/download/</a> 下载需要的固件例如<code>nanopi2-debian-sd4g.img.zip</code>以及烧写工具<code>win32diskimager.rar</code></li>
<li>下载完成后运行<code>win32diskimager.exe</code>，选取下载的<code>Debian</code>固件，并指定正确的SD/TF卡盘符，然后烧写即可。</li>
</ul>
<p>写入完成后，在Windows上看到的卡容量会是64M。不必担心，这是因为64M是Windows能识别Boot分区，而其它分区是Linux分区，Windows并不能识别。</p>
<p>把TF卡插入Nanopi2的卡位1（靠近电源输入的一端），接入电源即可启动Nanopi2了。</p>]]>
    
    </summary>
    
      <category term="nanopi2" scheme="http://blog.liushuping.com/tags/nanopi2/"/>
    
      <category term="nanopi2" scheme="http://blog.liushuping.com/categories/nanopi2/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++算法笔记－常用头文件]]></title>
    <link href="http://blog.liushuping.com/2015/11/09/C-%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%EF%BC%8D%E5%B8%B8%E7%94%A8%E5%A4%B4%E6%96%87%E4%BB%B6/"/>
    <id>http://blog.liushuping.com/2015/11/09/C-算法笔记－常用头文件/</id>
    <published>2015-11-09T13:53:43.000Z</published>
    <updated>2015-11-14T15:16:58.000Z</updated>
    <content type="html"><![CDATA[<p>C＋+有非常非常多的库文件，很多常见的功能都可在其中找到了解常用的库文件可以让我们清楚地知道有哪些系统已有功能可以使用，有哪些功能是我们需要实现的。本文列出了算法程序常用库的头文件。</p>
<a id="more"></a>
<h1 id="输入输出">输入输出</h1><table>
<thead>
<tr>
<th>头文件</th>
<th>主要功能</th>
<th>主要的类及函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>iostream</td>
<td>标准流输入输出对象</td>
<td>cin, cout, cerr, clog</td>
</tr>
<tr>
<td>cstdio或stdio.h</td>
<td>C语言的输入输出函数库</td>
<td>printf, scanf, fprintf, fscanf, fopen以及fclose等</td>
</tr>
<tr>
<td>iomanip</td>
<td>包含了一系列输入输出格式化的功能</td>
<td>setiosflags, setbase, setfill, setw, get_money, put_money, get_time, put_time等</td>
</tr>
<tr>
<td>ios</td>
<td>包含了输入输出的基类及相关函数</td>
<td>ios, ios_base, dec, hex, oct, fixed, left, right, uppercase等</td>
</tr>
<tr>
<td>istream</td>
<td>包含了标准输入和结合了输入输出相关的功能</td>
<td>istream, iostream</td>
</tr>
<tr>
<td>ostream</td>
<td>包含了标准输出和结合了输入输出相关的功能</td>
<td>ostream, endl, ends, flush等。</td>
</tr>
<tr>
<td>sstream</td>
<td>包含了以流操作符方式操作字符串的相关功能</td>
<td>istringstream, ostringstream, stringstream, stringbuf等。</td>
</tr>
</tbody>
</table>
<h1 id="数值">数值</h1><table>
<thead>
<tr>
<th>头文件</th>
<th>主要功能</th>
<th>主要的类及函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>limits</td>
<td>包含了所有数值的边界值</td>
<td>numeric_limits</td>
</tr>
<tr>
<td>climits或limits.h</td>
<td>一系列极值相关的宏</td>
<td>INT_MIN, INT_MAX, LONG_MIN, LONG_MAX等。</td>
</tr>
<tr>
<td>numeric</td>
<td>包含了对数列元素的一些函数</td>
<td>accumulate, adjacent_difference, inner_product, partial_sum和iota</td>
</tr>
<tr>
<td>random</td>
<td>包含了随机数产生的相关功能</td>
<td>random_device等非常多的随机数相关功能</td>
</tr>
</tbody>
</table>
<h1 id="数学计算">数学计算</h1><table>
<thead>
<tr>
<th>头文件</th>
<th>主要功能</th>
<th>主要的类及函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>cmath或math.h</td>
<td>C语言的数学函数和宏的库，有三角函数，指数函数，比较的宏等。</td>
<td>sin, cos, exp, pow, sqrt, ceil, floor, nextafter等非常多的数学函数</td>
</tr>
<tr>
<td>complex</td>
<td>复数运算相关的功能</td>
<td>real, imag以及各数学函数的复数版重载</td>
</tr>
<tr>
<td>ratio</td>
<td>分数计算相关功能</td>
<td>ratio, ratio_add, ratio_substract, ratio_multiply, ratio_divide, ratio_equal, ratio_less等</td>
</tr>
</tbody>
</table>
<h1 id="字符串操作">字符串操作</h1><table>
<thead>
<tr>
<th>头文件</th>
<th>主要功能</th>
<th>主要的类及函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>string</td>
<td>字符串转换的相关功能</td>
<td>string, to_string等</td>
</tr>
<tr>
<td>regex</td>
<td>正则表达式</td>
<td>regex_match, regex_search, regex_replace, basic_regex, match_results, sub_match及reg等</td>
</tr>
</tbody>
</table>
<h1 id="内存操作">内存操作</h1><table>
<thead>
<tr>
<th>头文件</th>
<th>主要功能</th>
<th>主要的类及函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>memory</td>
<td>动态内存管理的相关功能</td>
<td>auto_ptr, shared_ptr, weak_ptr, make_shared等</td>
</tr>
<tr>
<td>new</td>
<td>重载了new、delete等动态内存操作符</td>
<td>operator new, operator new[], operator delete, operator delete[], set_new_handler, get_new_handler等</td>
</tr>
<tr>
<td>cstring或string.h</td>
<td>操作C类型的字符串或数组的功能</td>
<td>memcpy, memmove, strcpy, strncpy, memcmp, memset, strlen, size_t, strstr等</td>
</tr>
</tbody>
</table>
<h1 id="数据结构">数据结构</h1><table>
<thead>
<tr>
<th>头文件</th>
<th>主要功能</th>
<th>主要的类</th>
</tr>
</thead>
<tbody>
<tr>
<td>vector</td>
<td>C++中使用频率最高、可以动态改变大小的类似数组的数据结构</td>
<td>vector    </td>
</tr>
<tr>
<td>set</td>
<td>集合相关的数据结构</td>
<td>set和multiset</td>
</tr>
<tr>
<td>unordered_map</td>
<td>跟无序映射相关的功能</td>
<td>unordered_map和unordered_multimap</td>
</tr>
<tr>
<td>map</td>
<td>跟有序映射相关的功能</td>
<td>map和multimap</td>
</tr>
<tr>
<td>queue</td>
<td>FIFO队列和优先队列</td>
<td>queue和priority_queue</td>
</tr>
<tr>
<td>stack</td>
<td>栈</td>
<td>stack</td>
</tr>
<tr>
<td>array</td>
<td>固定长度数组类array，因此它的灵活性比vector差一些</td>
<td>array</td>
</tr>
<tr>
<td>list</td>
<td>具有常数时间复杂度的任意未知元素的插入删除操作，以及支持正反方向遍历操作的list</td>
<td>list</td>
</tr>
<tr>
<td>forward_list</td>
<td>前向链表</td>
<td>forward_list, begin, end</td>
</tr>
<tr>
<td>deque</td>
<td>可以从头尾分别访问的队列</td>
<td>deque</td>
</tr>
<tr>
<td>tuple</td>
<td>元组的相关功能</td>
<td>tuple, tuple_size, make_tuple, tuple_cat, get等</td>
</tr>
</tbody>
</table>
<h1 id="算法">算法</h1><table>
<thead>
<tr>
<th>头文件</th>
<th>主要功能</th>
<th>主要的类及函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>algorithm</td>
<td>来自于STL的算法库，有排序、二分搜索、归并、最值、分区、查找以及数列的操作等</td>
<td>all_of, any_of, none_of, for_each, count, count_if, search, search_n, find, find_if, copy, swap, reverse, sort, lower_bound, make_heap等非常多的算法相关功能</td>
</tr>
<tr>
<td>iterator</td>
<td>迭代器相关的功能</td>
<td>begin, end, prev, next, advance, distance, iterator, istream_iterator, ostream_iterator等</td>
</tr>
</tbody>
</table>
<h1 id="时间">时间</h1><table>
<thead>
<tr>
<th>头文件</th>
<th>主要功能</th>
<th>主要的类及函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>chrono</td>
<td>处理时刻、时间以及系统无力时间等</td>
<td>duration, time_point, system_clock, steady_clock, high_resolution_clock, duration_cast, time_point_cast, duration_values等</td>
</tr>
<tr>
<td>ctime或time.h</td>
<td>C语言的时间相关功能</td>
<td>clock, difftime, time, ctime, clock_t, size_t, time_t等</td>
</tr>
</tbody>
</table>
<h1 id="位操作">位操作</h1><table>
<thead>
<tr>
<th>头文件</th>
<th>主要功能</th>
<th>主要的类及函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>bitset</td>
<td>比特位的集合，适合进行位数超出最大整数的位操作</td>
<td>bitset</td>
</tr>
</tbody>
</table>
<h1 id="函数对象">函数对象</h1><table>
<thead>
<tr>
<th>头文件</th>
<th>主要功能</th>
<th>主要的类及函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>functional</td>
<td>函数对象，主要包含数字计算、比较、逻辑运算等函数对象，以及一些转换函数</td>
<td>plus, minus, multiplies, equal_to, greater, logical_and, not1, not2等非常多的函数对象</td>
</tr>
</tbody>
</table>
<h1 id="Utility">Utility</h1><table>
<thead>
<tr>
<th>头文件</th>
<th>主要功能</th>
<th>主要的类及函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>utility</td>
<td>多种工具集合</td>
<td>swap, make_pair, forward, move, pair等</td>
</tr>
</tbody>
</table>
]]></content>
    <summary type="html">
    <![CDATA[<p>C＋+有非常非常多的库文件，很多常见的功能都可在其中找到了解常用的库文件可以让我们清楚地知道有哪些系统已有功能可以使用，有哪些功能是我们需要实现的。本文列出了算法程序常用库的头文件。</p>]]>
    
    </summary>
    
      <category term="C++" scheme="http://blog.liushuping.com/tags/C/"/>
    
      <category term="算法" scheme="http://blog.liushuping.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="C++算法笔记" scheme="http://blog.liushuping.com/categories/C-%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[算法的思维之沿着右手边的墙往前走就一定能走出迷宫]]></title>
    <link href="http://blog.liushuping.com/2015/11/01/%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%9D%E7%BB%B4%E4%B9%8B%E6%B2%BF%E7%9D%80%E5%8F%B3%E6%89%8B%E8%BE%B9%E7%9A%84%E5%A2%99%E5%BE%80%E5%89%8D%E8%B5%B0%E5%B0%B1%E4%B8%80%E5%AE%9A%E8%83%BD%E8%B5%B0%E5%87%BA%E8%BF%B7%E5%AE%AB/"/>
    <id>http://blog.liushuping.com/2015/11/01/算法的思维之沿着右手边的墙往前走就一定能走出迷宫/</id>
    <published>2015-11-01T10:25:27.000Z</published>
    <updated>2015-11-09T13:47:06.000Z</updated>
    <content type="html"><![CDATA[<p>迷宫是一种老少咸宜的游戏，可以是画在纸上的迷宫游戏，也可以是以隔墙或树木修建在公园或游乐场的迷宫游戏。</p>
<h1 id="迷宫游戏的基本思路">迷宫游戏的基本思路</h1><p>解决迷宫游戏的思路很简单：任意挑一条面前没有走过的路，一旦发现当前所走的路是死胡同则记住当前路不可行并退回到上一个路口选择下一条未走过的路，以此类推直到走到出口位置。这里有个很大的难点：当迷宫足够大的时候，人很难记住哪些路是走过的，于是很有可能就在绕圈子。当用计算机来解决迷宫问题时，通常就简单很多了，因为计算机能“记忆”非常大的路径。计算机解决迷宫问题，可以归结为两种方案：深度优先搜索和广度优先搜索。</p>
<a id="more"></a>
<h1 id="深度优先">深度优先</h1><h2 id="算法">算法</h2><p>深度优先方案的思路是：每到一个分岔路口时，按照特定的顺序（例如顺时针）选取一个路口走下去，接下来的分岔路口继续按照这个思路走。一旦发现某一条路是死胡同则回到之前的岔路口，按照之前的顺序选取下一个路口走下去。如果发现当前的岔路口的所有选择都走不通，则退回到再之前的一个岔路口继续选择下去。</p>
<h2 id="数据结构">数据结构</h2><p>为了实现上面的算法，需要一定的数据结构来存储发现的路径，从而保证：</p>
<ol>
<li>路径的顺序是按照计划的方式存储的</li>
<li>要及时从数据结构中删除已经走过的路径，以确保不走重复的路</li>
<li>确保路径是沿着先深度后广度的的方案进行的</li>
</ol>
<p>基于这样的特征，很容易把栈对应到这个数据结构上来：</p>
<ol>
<li>把岔路口的所有选择逆序压到栈顶</li>
<li>然后选取栈顶的路径作为下一条路径</li>
<li>如果选择的路径走不通，则弹出栈顶的路径作为下一个选择</li>
<li>如果选择的路径继续有岔路口，则重复这几个步骤直到发现出口为止。</li>
</ol>
<p>因此这个方案所需要的栈存储空间跟入口到出口间的岔路口的多少成正比关系。</p>
<h1 id="广度优先">广度优先</h1><h2 id="算法-1">算法</h2><p>广度优先方案的思路是：每到一个分岔路口时，按照特定的顺序遍访所有的路口来确认其是否就是出口。如果没有找到出口，则以同样的思路遍访当前岔路口每一个路口所通向的下一个岔路口。如此进行下去，直到发现出口。</p>
<h2 id="数据结构-1">数据结构</h2><p>要实现上面的算法，需要一种数据结构来存储发现的岔路口，以保证：</p>
<ol>
<li>路径的顺序是按照计划的方式存取的</li>
<li>要及时从数据结构中删除已经访问过的岔路口，以确保不走重复的路</li>
<li>确保路径是沿着广度优先——层层向外扩展的方向进行的</li>
</ol>
<p>基于上面的特征，很容易把队列对应到这个数据结构上来：</p>
<ol>
<li>把当前碰到的所有岔路口追加到队列的尾部</li>
<li>取队列头部的岔路口，并检查其通向的所有路口是否为出口</li>
<li>如若不是，且该路口能通向下一个岔路口则把这个岔路口追加到队尾</li>
<li>如此循环进行，直到发现出口为止。</li>
</ol>
<p>因此这个方案所需的队列存储空间也跟入口到出口之间的岔路口的多少成正比关系。</p>
<h1 id="必须存储走过的路吗？">必须存储走过的路吗？</h1><p>为了避免让程序陷入死循环或是不必要的重复，需要记住走过的路，以便不再去走。是否需要这样做取决于所采取的方案在没有其它干预下是否存在可重复的可能。事实上，只要迷宫有岔路口，前面介绍的广度优先和深度优先的方案都确定存在这样的重复。</p>
<p>那么是否存在某种特殊的沿路径行走的方式，它能保证所走过的路一定是未走过的，不会重复走已经走过的呢？要回答这个问题，我们必须重新审视看待走迷宫的方式。</p>
<h1 id="如何看待迷宫某条路径的行走方式？">如何看待迷宫某条路径的行走方式？</h1><p>对同一个问题，不同的思考方式可能产生完全不同的解决方案，不同方案之间在复杂度以及效率上可能存在着巨大的差异。因此思维方式是人对算法理解的核心。</p>
<p>按照惯性思维，面对迷宫内的一条通道，最容易想到的是只有两种走法：进去和出来。然而基于这样的思维，解决方案也只能是前面介绍的广度或是深度优先的搜索，且都需要存储空间来标记已经走过的路。然而，简单的把迷宫通道的走法划分为进去和出来的方式使路径丢失了很多方向性信息，而丢失的信息正好可以用来“标记”走过的道路。事实上，迷宫的任意一条通道都是由左右两侧的两面墙组成而成的，沿着这两面墙分别有进去和出来的走法，这样一条通道就有4种走法了。</p>
<h1 id="无需额外记忆的迷宫走法">无需额外记忆的迷宫走法</h1><p>对迷宫通道走法的思维转变后，问题就容易分析了。先从直线分析，要保证不走重复的路很简单，只要沿着一个方向向前走即可。迷宫的路径是曲线，是否也可以用同样的方案？答案是肯定的：沿着曲线朝一个方向行走，若是发生回到原点的情况，只有下面两种可能：</p>
<ol>
<li>曲线是闭合的，在闭合区域内部，沿着曲线行走。</li>
<li>曲线是闭合的，在闭合区域的外沿，沿着曲线行走。</li>
</ol>
<p>然而，在入口到出口之间确定有通道的情况下（也即迷宫有解）的情况下，采取沿着迷宫墙壁朝一个方向行走的方式，是永远不会进入上面两种区域的。因为：</p>
<ol>
<li>不可能从一个闭合区域的外部进入其内部，因为没有”门”。而如果一开始就在内部，说明迷宫无解。</li>
<li>第二种是一个孤岛的情况，而从入口开始沿着墙朝一个方向行走，是不可能进入孤岛的。因为孤岛不可能接触人所在的墙，否则它就不是孤岛了。</li>
</ol>
<p>因此，我们把所有重复行走路线的可能都排除了，方案的正确性得到了证明。当然，沿着一个方向行走，既可是右侧，也可是左侧。</p>
<p>无需额外记忆的前提是迷宫确定有能通向出口的通道，否则会进入到上面介绍的两种重复行走路线的情况。</p>
<h1 id="总结">总结</h1><p>本文继续介绍了思维方式在算法中的重要性。通过分析解决迷宫问题的两种思路，阐述了思维方式的多样性以及不同的思维方式会对算法产生不同的效果。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>迷宫是一种老少咸宜的游戏，可以是画在纸上的迷宫游戏，也可以是以隔墙或树木修建在公园或游乐场的迷宫游戏。</p>
<h1 id="迷宫游戏的基本思路">迷宫游戏的基本思路</h1><p>解决迷宫游戏的思路很简单：任意挑一条面前没有走过的路，一旦发现当前所走的路是死胡同则记住当前路不可行并退回到上一个路口选择下一条未走过的路，以此类推直到走到出口位置。这里有个很大的难点：当迷宫足够大的时候，人很难记住哪些路是走过的，于是很有可能就在绕圈子。当用计算机来解决迷宫问题时，通常就简单很多了，因为计算机能“记忆”非常大的路径。计算机解决迷宫问题，可以归结为两种方案：深度优先搜索和广度优先搜索。</p>]]>
    
    </summary>
    
      <category term="几何" scheme="http://blog.liushuping.com/tags/%E5%87%A0%E4%BD%95/"/>
    
      <category term="算法" scheme="http://blog.liushuping.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="逻辑" scheme="http://blog.liushuping.com/tags/%E9%80%BB%E8%BE%91/"/>
    
      <category term="C++算法笔记" scheme="http://blog.liushuping.com/categories/C-%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[算法的思维之鸡兔同笼问题的分析]]></title>
    <link href="http://blog.liushuping.com/2015/11/01/%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%9D%E7%BB%B4%E4%B9%8B%E9%B8%A1%E5%85%94%E5%90%8C%E7%AC%BC%E9%97%AE%E9%A2%98%E7%9A%84%E5%88%86%E6%9E%90/"/>
    <id>http://blog.liushuping.com/2015/11/01/算法的思维之鸡兔同笼问题的分析/</id>
    <published>2015-11-01T10:24:25.000Z</published>
    <updated>2015-11-09T13:41:21.000Z</updated>
    <content type="html"><![CDATA[<p>约1500年前，《孙子算经》中有如下的问题描述：</p>
<blockquote>
<p>今有雉兔同笼，上有三十五头，下有九十四足，问雉兔各几何？</p>
</blockquote>
<p>首先科普一下，《孙子算经》的作者不详，且同《孙子兵法》不是一个作者。</p>
<p>进入正题：在数学发展到今天的水平来看，这是个很简单的问题，是一个初中问题或是小学奥数问题。然而用一些简单的问题去说明一些道理还是更容易让人接受的，毕竟如果直接拿哥德巴赫猜想（我也不会）这种世界性难题来说明道理是很难让人理解的，因为门槛太高。当然，这里要介绍的内容跟任何计算机程序语言都没有关系，只是统一分类到我的C++算法笔记作为一个子类别而已。</p>
<a id="more"></a>
<h1 id="思考的目的">思考的目的</h1><p>这里，我想通过这个简单的例子来尝试介绍一下算法的思维。个人认为，狭义上的算法思维就是按照能用计算机实现的方式来去思考问题的解决办法，当然这还需考虑解决办法的复杂度。这是一个很抽象的问题，我想还是通过这样一个简单的例子来给亲爱的读者一个直观的感觉吧。</p>
<h1 id="思考的方式">思考的方式</h1><p>这要从我还上小学的时候说起，那时就有长者考我这个问题，而当时的我觉得除了暴力穷举（知道这个方法的名字已经是好多年后的事了）外实在没有什么思路。等上了初中，学习了代数后才认识到它是人类发明的多么强大的数学工具，好多之前完全没有思路的问题顷刻间变的异常简单！</p>
<p>可是为什么会这样？这个问题我思考了很久，可以简单的总结为以下几点个人观点：</p>
<ol>
<li>有很多的问题我们很难分析出正面解决问题的思路办法</li>
<li>而在大量的问题分析过程中人们已经分析总结出了大量的恒等变化，例如交换律、结合律等等</li>
<li>代数的发明为人类提供了强有力的工具，让人们把正向难以分析的问题转化为反向的问题，从而使问题变得异常简单</li>
</ol>
<h1 id="思考的意义">思考的意义</h1><p>然而，很多情况下似乎正面分析得出的思路更容易通过计算机算法程序去实现。事实上，通过代数结合等式的恒等变化而解决问题的方式，如果不加深入的思考，很容易陷入知道如何解决问题，却不明白解决方式背后所隐含的真实思路的境况。</p>
<h1 id="以更加算法的方式去思考">以更加算法的方式去思考</h1><p>鸡兔同笼问题如果从正面思考，应该是简单的数论问题，是关于整数的加减乘除及取余的相关操作，而这些都跟计算机程序的算法息息相关。既然当鸡和兔子都已经站在笼子里时去正面分析比较困难，需要代数的帮忙，那么我们把顺序反过来，先让它们都站在笼子外面，然后从正面去分析让它们在逐步满足条件的前提下如何分步骤进入笼子。</p>
<p>在问题有解的前提下，腿的总数量应该介于全部是鸡时的腿的数量和全部是兔时腿的数量之间。那么在这个思路下，问题可以划分为多个子问题，而大问题划分为子问题的方法是计算机算法的一个重要工具：</p>
<ol>
<li>让全部的鸡进入笼子，然后计算一下全部腿的数量，如若等于问题给定的腿的数量，那么笼子内全是鸡；否则，进入第二个子问题</li>
<li>把多余的腿分配到笼子内的鸡身上。怎么分配？不能每只鸡分配一条腿，因为三条腿既不是鸡也不是兔子。所以要每只鸡分配两条腿，这样就神奇地让这只鸡变成兔子了。</li>
<li>问题得到了解决：变成兔子了的就是兔子，而没变的仍是鸡。</li>
</ol>
<h1 id="从反向思维推正向思维">从反向思维推正向思维</h1><p>代数、等式以及等价变换等都是数学对问题高度的抽象，可以脱离于物理量而存在。然而对于具体的问题，还是能通过对其问题的计算过程赋以具体物理意义而推导正向思维的。鸡兔问题，可以通过一元一次或二元一次方程来解决。而二元一次方程可以转化为一元一次方程，所以我们就以一元一次方程来分析（因为给二元赋以物理量比给一元赋以物理量难得多）：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span>x + (<span class="number">35</span> - x) * <span class="number">2</span> = <span class="number">94</span></span><br></pre></td></tr></table></figure></p>
<p>这代表了<code>x</code>只兔子和<code>35 - x</code>只鸡总共有94条腿。然后，可以用数学工具把它变化为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>x = <span class="number">94</span> - <span class="number">70</span></span><br></pre></td></tr></table></figure></p>
<p>这代表了什么意思呢？一种可行的理解方式是：假如把<code>35</code>全部分配为鸡的话<code>(35 * 2)</code>，剩余的腿<code>(94 - 70)</code>如何去分配呢？分配的限制条件是只能分配成兔子，也就是说要以两个两个的方式去分配，而被分配到的就变成了兔子，这就是<code>2x</code>所表示的意义。那么这个正向思路也就倒着推出来了。</p>
<h1 id="总结">总结</h1><p>思维的方式是决定或影响算法的一个重要因素。有时候从正反两个方面去分析问题，能更容易地找到思路。本文的目的不是告诉大家鸡兔同笼这个问题如何去解，而是通过分析解这道题的思路去认识和了解算法的思维。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>约1500年前，《孙子算经》中有如下的问题描述：</p>
<blockquote>
<p>今有雉兔同笼，上有三十五头，下有九十四足，问雉兔各几何？</p>
</blockquote>
<p>首先科普一下，《孙子算经》的作者不详，且同《孙子兵法》不是一个作者。</p>
<p>进入正题：在数学发展到今天的水平来看，这是个很简单的问题，是一个初中问题或是小学奥数问题。然而用一些简单的问题去说明一些道理还是更容易让人接受的，毕竟如果直接拿哥德巴赫猜想（我也不会）这种世界性难题来说明道理是很难让人理解的，因为门槛太高。当然，这里要介绍的内容跟任何计算机程序语言都没有关系，只是统一分类到我的C++算法笔记作为一个子类别而已。</p>]]>
    
    </summary>
    
      <category term="数学" scheme="http://blog.liushuping.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="数论" scheme="http://blog.liushuping.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="算法" scheme="http://blog.liushuping.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="逻辑" scheme="http://blog.liushuping.com/tags/%E9%80%BB%E8%BE%91/"/>
    
      <category term="C++算法笔记" scheme="http://blog.liushuping.com/categories/C-%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++算法笔记－基本输入输出]]></title>
    <link href="http://blog.liushuping.com/2015/10/28/C++%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%EF%BC%8D%E5%9F%BA%E6%9C%AC%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
    <id>http://blog.liushuping.com/2015/10/28/C++算法笔记－基本输入输出/</id>
    <published>2015-10-28T15:24:51.000Z</published>
    <updated>2015-11-09T13:40:23.000Z</updated>
    <content type="html"><![CDATA[<p>算法题目都是要求对于给定的输入，在规定时间内把结果输出到指定的设备上。因此输入输出是做算法的最基本条件。</p>
<h1 id="输入">输入</h1><p>C++中输入有两种常见的形式：来自标准输入设备<code>stdin</code>和来自文件。</p>
<h2 id="标准输入设备stdin">标准输入设备stdin</h2><h3 id="输入重定向">输入重定向</h3><p>默认情况下<code>stdin</code>来自于键盘的输入，然而我们可以把它重定向到任何其它可用的设备，比如常见的文件。在常见的系统中，对于一个控制台程序，我们可以用输入重定向来把标准输入重定向到文件设备。例如下列代码把程序<code>test</code>的标准输入重定向到了文件<code>file1.txt</code>:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test &lt; file1.txt</span><br></pre></td></tr></table></figure></p>
<p>这是一个非常实用的功能：在程序算法题中常见的输入是一个文件，如果通过把文件内容粘贴到控制台程序来实现输入会很不方便，尤其是当文件内容非常大的时候。</p>
<p>除输入重定向之外，还可以通过<code>freopen</code>来使一个已经存在的流<code>stream</code>指向目标文件。当然，<code>stdin</code>，<code>stdout</code>，以及<code>stderr</code>都是流的一种，因此我们可以用该函数来实现输入的重定向。下面的代码实现了把标准输入重定向到文件<code>file1.txt</code>:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">freopen(“file1.txt”, “r”, <span class="built_in">stdin</span>);</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>函数<code>freopen</code>的第二个参数表示了文件的访问模式，有下面的几种可能的取值：</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>”r”</td>
<td>以读取的方式打开文件，文件必须存在</td>
</tr>
<tr>
<td>”w”</td>
<td>创建一个空文件用来写入。如果文件内容存在，则忽略文件内容并按照空文件的方式写入内容</td>
</tr>
<tr>
<td>”a”</td>
<td>按照追加模式打开文件写入内容。如果文件不存在，则创建文件</td>
</tr>
<tr>
<td>”r+”</td>
<td>以读取并更新的模式打开一个文件，文件必须存在</td>
</tr>
<tr>
<td>”w+”</td>
<td>以写入并更新的模式创建一个文件。如果文件存在，则忽略内容并按照空文件的方式对待</td>
</tr>
<tr>
<td>”a+”</td>
<td>以追加并更新的模式打开一个文件。文件定位操作会影响下次输入的操作，而输出内容总是会被追加到文件末尾。如果文件不存在，则创建文件</td>
</tr>
</tbody>
</table>
<p>上面所列模式都是以文本方式打开文件，这也是大多数算法程序常见的输入模式。若需要以二进制的方式读取文件，在模式中添加一个<code>b</code>字符即可，该字符可处于任何位置，如：<code>rb</code>，<code>bw</code>。<br>作为良好的习惯，在文件使用完毕后应该将其关闭：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">freopen(“file1.txt”, “r”, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">fclose(<span class="built_in">stdin</span>);</span><br></pre></td></tr></table></figure></p>
<p>关于<code>freopen</code>的信息，请参考<a href="http://www.cplusplus.com/reference/cstdio/freopen/" target="_blank" rel="external">链接</a>。</p>
<h3 id="读取标准输入设备stdin">读取标准输入设备stdin</h3><h4 id="std::cin">std::cin</h4><p><code>std::cin</code>是指向标准输入设备<code>stdin</code>的流对象，通过流输入运算符<code>&gt;&gt;</code>可以从标准输入设备中读取内容到指定的内存变量中。例如下面的代码是从标准输入设备中读取一个整数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br></pre></td></tr></table></figure></p>
<p>默认的读取方式是以空格或换行符号为分隔的。假如输入设备中有内容 <code>10 20 abc</code>，可以方便的用以下代码读取：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> c;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br></pre></td></tr></table></figure></p>
<h4 id="std::cin读取空格或换行符">std::cin读取空格或换行符</h4><p>如果确需要读取空格或换行字符，则需要用到<code>std::cin.get();</code>函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s;</span><br><span class="line">s = <span class="built_in">std</span>::<span class="built_in">cin</span>.get();</span><br></pre></td></tr></table></figure></p>
<h4 id="std::cin读取非十进制数字">std::cin读取非十进制数字</h4><p>如果要读取的字符是非十进制数字，则需要告诉<code>std::cin</code>按照指定的进制读取，可以通过<code>std::setbase()</code>来指定：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; <span class="built_in">std</span>::setbase(<span class="number">16</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br></pre></td></tr></table></figure></p>
<h4 id="cin读取整行">cin读取整行</h4><p>可以通过<code>std::cin.getline()</code>或<code>std::getline()</code>来实现读取一行内容。实际使用中，<code>std::getline()</code>更常用一些，因为它直接支持STL字符串类型，更加方便：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">std</span>::getline(<span class="built_in">cin</span>, s);</span><br></pre></td></tr></table></figure></p>
<p>更多的关于<code>std::getline()</code>的内容，参考<a href="http://www.cplusplus.com/reference/string/string/getline/?kw=getline" target="_blank" rel="external">链接</a>。<br>关于<code>std::cin.getline()</code>的内容，参考<a href="http://www.cplusplus.com/reference/istream/istream/getline/" target="_blank" rel="external">链接</a>。</p>
<h4 id="std::cin其它相关">std::cin其它相关</h4><p>事实上，<code>std::cin</code>是<code>std::istream</code>的一个实例，因此<code>std::istream</code>的所有公开方法都可以通过<code>std::cin</code>调用。比如流读取位置定位，<code>peek</code>以及忽略当前字符等等功能。这些高级功能在算法程序中应用的比较少，就不赘述了，具体内容可参考<a href="http://www.cnblogs.com/pegasus923/archive/2011/04/22/2024418.html" target="_blank" rel="external">链接</a>。</p>
<h3 id="scanf">scanf</h3><p><code>scanf</code>是C风格的从标准输入设备读取格式化数据的强有力的方法，它从<code>stdin</code>中读取内容，其参数类型丰富强大，但也不容易记忆。<code>scanf</code>接受至少一个参数的变长参数，第一个参数是以C类型字符串表示的输入参数格式。后面的其它参数应该是一系列预先分配好的变量，依次对应参数格式字符串内的标识符。例如下面代码表示从<code>stdin</code>中读取一个整型数字到变量<code>x</code>中：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(“%i”, &amp;x);</span><br></pre></td></tr></table></figure></p>
<p>其中参数格式字符串的格式是：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%[<span class="link_label">*</span>][<span class="link_reference">width</span>][<span class="link_label">length</span>]specifier</span><br></pre></td></tr></table></figure></p>
<p>这其中的的<code>specifier</code>有如下的定义：</p>
<table>
<thead>
<tr>
<th>specifier</th>
<th>解释</th>
<th>读取的字符</th>
</tr>
</thead>
<tbody>
<tr>
<td>i</td>
<td>Integer</td>
<td>整数，有符号的(singed)，可以以<code>+</code>或<code>-</code>开头。默认是十进制，若以0开头则认为是8进制，以0x开头则认为是16进制</td>
</tr>
<tr>
<td>d, u</td>
<td>Decimal Integer</td>
<td>十进制整数，可以以<code>+</code>或<code>-</code>开头。<code>d</code>代表有符号的，<code>u</code>代表无符号的</td>
</tr>
<tr>
<td>o</td>
<td>Octal integer</td>
<td>八进制整数，可以以<code>+</code>或<code>-</code>开头。无符号参数</td>
</tr>
<tr>
<td>x</td>
<td>Hexadecimal integer</td>
<td>十六进制整数，可以以<code>0x</code>或<code>0X</code>开头，同时也可以以<code>+</code>或<code>-</code>开头。无符号参数</td>
</tr>
<tr>
<td>f, e, g</td>
<td>Floating Point Number</td>
<td>浮点数，可带小数点，开头可以包含<code>+</code>或<code>-</code>，可以用科学记数法。C99标准支持以<code>0x</code>或<code>0X</code>开头的十六进制数</td>
</tr>
<tr>
<td>c</td>
<td>Character</td>
<td>读取下一个字符。如果<code>width</code>是大于<code>1</code>的数，则读取相应数量的字符，并把它们放在指定的内存连续空间内，但不会在结尾处添加<code>null</code>字符。</td>
</tr>
<tr>
<td>s</td>
<td>String of characters</td>
<td>从当前位置开始读取字符，直到下一个字符是空白字符。读取完毕后会在存储变量后添加一个代表结束的<code>null</code>字符</td>
</tr>
<tr>
<td>p</td>
<td>Pointer address</td>
<td>读取一系列代表指针的字符，它的格式会因不同系统及不同库而不同，但是它跟在<code>fprintf</code>中的<code>%p</code>的参数使用方式是一样的</td>
</tr>
<tr>
<td>[characters]</td>
<td>Scanset</td>
<td>从当前位置开始读取字符，直到下一个字符是方括号内未定义的字符停止</td>
</tr>
<tr>
<td>[^characters]</td>
<td>Negated scanset</td>
<td>从当前位置开始读取字符，直到下一个字符是方括号内定义的字符停止</td>
</tr>
<tr>
<td>n</td>
<td>Count</td>
<td>不会读取字符，会返回当前已读取字符的个数到对应参数所指向的存储空间</td>
</tr>
<tr>
<td>%</td>
<td>%</td>
<td>表示读取一个%字符</td>
</tr>
</tbody>
</table>
<p>除<code>n</code>之外，其它任何的标识符都至少会触发读取一个字符，否则匹配失败，读取扫描结束。</p>
<p>参数格式中的<code>*</code>，<code>width</code>及<code>length</code>的解释如下：</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>可选参数，表示数据会被读取并被忽略，不会存储到某个地址中</td>
</tr>
<tr>
<td>width</td>
<td>可选参数，指定了读取字符的最大个数</td>
</tr>
<tr>
<td>length</td>
<td>可选参数，可以是<code>hh</code>, <code>h</code>, <code>l</code>, <code>ll</code>, <code>j</code>, <code>z</code>, <code>t</code>, <code>L</code>中的任一值，表明了对存储地址的期望类型</td>
</tr>
</tbody>
</table>
<p>下表列出了不同<code>length</code>对不同标识符的类型期望：</p>
<table>
<thead>
<tr>
<th>length</th>
<th>d i</th>
<th>u o x</th>
<th>f e g a</th>
<th>c s [] [^]</th>
<th>p</th>
<th>n</th>
</tr>
</thead>
<tbody>
<tr>
<td>(none)</td>
<td>int*</td>
<td>unsigned int*</td>
<td>float*</td>
<td>char*</td>
<td>void**</td>
<td>int*</td>
</tr>
<tr>
<td>hh</td>
<td>signed char*</td>
<td>unsigned char*</td>
<td></td>
<td></td>
<td></td>
<td>singed char*</td>
</tr>
<tr>
<td>h</td>
<td>short int*</td>
<td>unsigned short int*</td>
<td></td>
<td></td>
<td></td>
<td>short int*</td>
</tr>
<tr>
<td>l</td>
<td>long int*</td>
<td>unsigned long int*</td>
<td>double*</td>
<td>wchar_t*</td>
<td></td>
<td>long int*</td>
</tr>
<tr>
<td>ll</td>
<td>long long int*</td>
<td>unsigned long long int*</td>
<td></td>
<td></td>
<td></td>
<td>long int*</td>
</tr>
<tr>
<td>j</td>
<td>intmax_t*</td>
<td>uintmax_t*</td>
<td></td>
<td></td>
<td></td>
<td>intmax_t*</td>
</tr>
<tr>
<td>z</td>
<td>size_t*</td>
<td>size_t*</td>
<td></td>
<td></td>
<td></td>
<td>size_t*</td>
</tr>
<tr>
<td>t</td>
<td>ptrdiff_t*</td>
<td>ptrdiff_t*</td>
<td></td>
<td></td>
<td></td>
<td>ptfdiff_t*</td>
</tr>
<tr>
<td>L</td>
<td></td>
<td></td>
<td>long double*</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>函数返回有多少个参数被设置值了，可能是返回所有参数的个数，如果发生了任何错误，则可能是比它小的一个数字。</p>
<p>关于<code>scanf</code>更多内容请参考<a href="http://www.cplusplus.com/reference/cstdio/scanf/?kw=scanf" target="_blank" rel="external">链接</a>。</p>
<h3 id="读取文件内容">读取文件内容</h3><p>当输入内容来自于文件时，对于编写算法程序，推荐的做法是通过输入重定向或<code>freopen</code>让<code>stdin</code>指向输入文件。然而如果确需要直接读取文件，可以使用<code>fopen</code>打开文件然后配合多种文件的读取函数来实现期望的对输入文件的读取，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FILE *file;</span><br><span class="line">file = fopen(<span class="string">"stdinout.cpp"</span>, <span class="string">"r"</span>);</span><br><span class="line"><span class="keyword">char</span> c = getc(file);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c;</span><br><span class="line">fclose(file);</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，<code>getc</code>的作用是从指定的文件中读取下一个字符。除此之外，还有很多从文件读取内容的函数，如<code>fgetc</code>，<code>fgets</code>，<code>fscanf</code>等。由于算法程序中输入大多是顺序的文本文件读取操作，因此输入重定向结合读取标准输入设备的方式更实用。文件的读取方式便不再赘述，有关详细内容可参考<a href="http://www.cplusplus.com/reference/cstdio/" target="_blank" rel="external">链接</a>。</p>
<h1 id="输出">输出</h1><p>C++中输出有两种常见的形式：标准输出设备<code>stdout</code>和文件。</p>
<h2 id="标准输出设备stdout">标准输出设备stdout</h2><h3 id="输出重定向">输出重定向</h3><p>默认情况下，<code>stdout</code>指向的是显示器，然而我们可以把它重定向到任何其它可用的设备，例如文件。在常见的系统中，对于一个控制台程序，我们可以通过输出重定向来让<code>stdout</code>指向文件，例如下面的代码把<code>test</code>程序的输出重定向到了文件<code>file1.txt</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span> &gt; file1.txt</span><br></pre></td></tr></table></figure></p>
<p>输出重定向是一个非常实用的功能：当程序输出内容很多的时候，显示器会翻屏甚至清除掉前面输出的内容，不方便人工查看。因此，可以把内容输出重定向到文件内，方便人工查看和备份。</p>
<p>除了输出重定向外，还可以通过<code>freopen</code>来让一个已经存在的<code>stream</code>指向指定的目标文件。它的使用方式已经在<a href="#输入重定向">输入重定向</a>中详细介绍了，这里不在赘述，区别是输出的时候文件打开模式要是<code>&quot;w&quot;</code>。</p>
<h3 id="写入到标准输出设备stdout">写入到标准输出设备stdout</h3><h4 id="std::cout">std::cout</h4><p><code>std::cout</code>是指向标准输出设备<code>stdout</code>的流对象，通过流运算符<code>&lt;&lt;</code>可以输出内容到标准输出设备中。例如下面的代码是向标准设备输出整数<code>x</code>:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">x = <span class="number">123</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x;</span><br></pre></td></tr></table></figure></p>
<h4 id="std::cout输出空行">std::cout输出空行</h4><p>当需要输出空行是，可以用<code>\n</code>或者<code>std::endl</code>的方式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::endl;</span><br></pre></td></tr></table></figure></p>
<h4 id="std::cout输出指定宽度">std::cout输出指定宽度</h4><p>当需要对输出内容指定宽度时，可以使用<code>std::setw()</code>函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setw(<span class="number">5</span>) &lt;&lt; <span class="number">11</span> &lt;&lt; <span class="built_in">std</span>::endl;</span><br></pre></td></tr></table></figure></p>
<p>输出时，数字<code>11</code>的左侧会填充三个空格。值得注意的是，<code>std::setw()</code>只会影响下一次输出，并不会影响后续的输出。<code>std::set()</code>来自于头文件<code>&lt;iomanip&gt;</code>。</p>
<h4 id="std::cout指定输出的填充字符">std::cout指定输出的填充字符</h4><p>当对输出内容指定输出宽度，但内容不够宽度时，输出内容的左侧会以空格字符填充。如果需要指定不同的填充字符，则使用<code>std::setfill()</code>，如下代码则用字符<code>x</code>做为填充：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setfill(<span class="string">'x'</span>) &lt;&lt; <span class="built_in">std</span>::setw(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">11</span> &lt;&lt; <span class="built_in">std</span>::endl;</span><br></pre></td></tr></table></figure></p>
<h4 id="std::cout输出非十进制数字">std::cout输出非十进制数字</h4><p>当需要输出的内容是非十进制时，可以通过<code>std::setbase()</code>来指定：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setbase(<span class="number">16</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">0xff</span> &lt;&lt; <span class="built_in">std</span>::endl;</span><br></pre></td></tr></table></figure></p>
<p>STL预定义了一些进制标识符可以用做<code>std::setbase()</code>的参数，他们是：<code>std::dec</code>，<code>std::hex</code>和<code>std::oct</code>。</p>
<h4 id="std::cout设置流的格式">std::cout设置流的格式</h4><p>通过<code>std::setbase()</code>可以设置下一次数的输出进制，然而如果需要多次输出则需要多次设置。<code>std::cout</code>支持全局设置格式，直到取消前该格式会一直影响输出设置。STL定义了一系列的基于位运算的格式，详细信息如下表所列：</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>常量</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>独立标志位</td>
<td>boolalpha</td>
<td>以字符串的形式(true，false)读取布尔变量</td>
</tr>
<tr>
<td>独立标志位</td>
<td>showbase</td>
<td>在输出整数之前输出其进制标识符</td>
</tr>
<tr>
<td>独立标志位</td>
<td>showpoint</td>
<td>输出浮点数时，总是输出小数点</td>
</tr>
<tr>
<td>独立标志位</td>
<td>showpos</td>
<td>输出非负数时，以+号开始</td>
</tr>
<tr>
<td>独立标志位</td>
<td>skipws</td>
<td>这个参数用在输入时，其作用是忽略某些输入操作开头部分的空格</td>
</tr>
<tr>
<td>独立标志位</td>
<td>unitbuf</td>
<td>每次插入操作后，都进行一次写出(flush)操作</td>
</tr>
<tr>
<td>独立标志位</td>
<td>uppercase</td>
<td>在某些插入操作，以大写字母代替小写字幕</td>
</tr>
<tr>
<td>进制(basefield)</td>
<td>dec</td>
<td>以十进制读取或写入整数</td>
</tr>
<tr>
<td>进制(basefield)</td>
<td>hex</td>
<td>以十六进制读取或写入整数</td>
</tr>
<tr>
<td>进制(basefield)</td>
<td>oct</td>
<td>以八进制读取或写入整数</td>
</tr>
<tr>
<td>浮点数格式(floatfield)</td>
<td>fixed</td>
<td>以固定小数点的形式输出浮点数</td>
</tr>
<tr>
<td>浮点数格式(floatfield)</td>
<td>scientific</td>
<td>以科学计数法的形式输出浮点数</td>
</tr>
<tr>
<td>对齐方式(adjustfield)</td>
<td>internal</td>
<td>通过在指定位置插入填充字符的方式来使输出达到指定宽度</td>
</tr>
<tr>
<td>对齐方式(adjustfield)</td>
<td>left</td>
<td>通过在末尾追加填充字符的方式来使输出达到指定宽度</td>
</tr>
<tr>
<td>对齐方式(adjustfield)</td>
<td>right</td>
<td>通过在开头添加填充字符的方式来使输出达到指定宽度</td>
</tr>
</tbody>
</table>
<p>格式可以是上述任意一种或是它们任意多个的组合。<code>basefield</code>，<code>floatfield</code>和<code>adjustfield</code>是三个预定义的组合，它们分别对应的值如下表所列：</p>
<table>
<thead>
<tr>
<th>组合</th>
<th>组合形式</th>
</tr>
</thead>
<tbody>
<tr>
<td>basefield</td>
<td>dec&#124;hex&#124;oct</td>
</tr>
<tr>
<td>floatfield</td>
<td>fixed&#124;scientific</td>
</tr>
<tr>
<td>adjustfield</td>
<td>internal&#124;left&#124;right</td>
</tr>
</tbody>
</table>
<p>这些常量值都定义在<code>ios_base</code>类中，因此可以通过<code>ios_base</code>及其子类，或任何其实例来访问这些常量。例如：<code>std::ios_base::hex</code>，<code>std::ios::hex</code>或<code>std::cout.hex</code>。可以通过<code>std::cout.setf()</code>函数来设置这些值：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::<span class="built_in">cout</span>.hex);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::ios_base::hex);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::ios::hex);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::out.hex, <span class="built_in">std</span>::<span class="built_in">cout</span>.basefield)</span><br></pre></td></tr></table></figure></p>
<p>从代码中可以看出，<code>std::cout.setf()</code>有重载，可以是给定一个参数，相当于只设置这个标志位而不影响其它标志位；也可以是两个参数，其作用是设置第二个参数所影响范围内的标志位，把其值设置为第一个参数和第二个参数的逻辑与之后的值，而第二个参数标志位以外的标志位不受影响。关于<code>std::cout.setf()</code>的更多信息请参考<a href="http://www.cplusplus.com/reference/ios/ios_base/setf/" target="_blank" rel="external">链接</a></p>
<p>另外，<code>std::cout.setiosflags()</code>等同于<code>std::cout.setf()</code>的两参数版本；<code>std:cout.resetiosflags()</code>等同于<code>std::cout.unsetf()</code>的两参数版本。</p>
<p>任何时刻可以通过<code>std::cout.unsetf()</code>来取消之前所设置的任何标志位。</p>
<p>任何时刻都可以通过<code>std::cout.flags()</code>来获取当前已经设置的所有标志位。<code>std::cout.flags()</code>还有一个重载，接受一个标志位参数，不同于<code>std::cout.setf()</code>的是，它会清除所有其它的标志位，只保留所设置的标志位。</p>
<h3 id="printf">printf</h3><p><code>printf</code>是C风格的向标准输出设备输出格式化字符串的强有力方法，它有同<code>scanf</code>类似的参数定义，但对参数格式字符串的定义有略微的不同，其定义是：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%[<span class="link_label">flags</span>][<span class="link_reference">width</span>][<span class="link_label">.precision</span>][<span class="link_reference">length</span>]specifier</span><br></pre></td></tr></table></figure></p>
<p>对其中的<code>specifier</code>的解释如下表：</p>
<table>
<thead>
<tr>
<th>specifier</th>
<th>输出</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>d或i</td>
<td>有符号的十进制整数</td>
<td>123</td>
</tr>
<tr>
<td>u</td>
<td>无符号的十进制整数</td>
<td>1234</td>
</tr>
<tr>
<td>o</td>
<td>无符号的八进制整数</td>
<td>723</td>
</tr>
<tr>
<td>x</td>
<td>无符号的十六进制整数</td>
<td>ab12</td>
</tr>
<tr>
<td>X</td>
<td>大写的无符号十六进制整数</td>
<td>AB12</td>
</tr>
<tr>
<td>f</td>
<td>小写的十进制浮点数</td>
<td>123.45</td>
</tr>
<tr>
<td>F</td>
<td>大写的十进制浮点数</td>
<td>123.45</td>
</tr>
<tr>
<td>e</td>
<td>小写的科学计数法数</td>
<td>1.2345e+2</td>
</tr>
<tr>
<td>E</td>
<td>大写的科学计数法数</td>
<td>1.2345E+2</td>
</tr>
<tr>
<td>g</td>
<td>在%f和%e之间取比较短的表示方式</td>
<td>123.45</td>
</tr>
<tr>
<td>G</td>
<td>在%F和%E之间取比较短的表示方式</td>
<td>123.45</td>
</tr>
<tr>
<td>a</td>
<td>小写16进制浮点数</td>
<td>-0xabc123.45ep-3</td>
</tr>
<tr>
<td>A</td>
<td>大写16进制浮点数</td>
<td>-0XABC123.45EP-3</td>
</tr>
<tr>
<td>c</td>
<td>字符</td>
<td>a</td>
</tr>
<tr>
<td>s</td>
<td>字符串</td>
<td>test</td>
</tr>
<tr>
<td>p</td>
<td>指针地址</td>
<td>f1234567</td>
</tr>
<tr>
<td>n</td>
<td>不会输出任何内容，对应的参数应该是一个有符号整数，会把当前已经输出的字符个数存储到该参数对应的变量中</td>
<td></td>
</tr>
<tr>
<td>%</td>
<td>输出一个%符号</td>
<td>%</td>
</tr>
</tbody>
</table>
<p>对格式串中的<code>flags</code>域有如下表所列解释：</p>
<table>
<thead>
<tr>
<th>flags</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>-</td>
<td>以左对齐的方式输出指定内容，默认是右对齐</td>
</tr>
<tr>
<td>+</td>
<td>强制数字的输出以<code>+</code>或<code>-</code>符号开始，即使是正数。默认只有负数才以符号位开始</td>
</tr>
<tr>
<td>(空格)</td>
<td>如果无符号输出，则在值之前输出一个空格</td>
</tr>
<tr>
<td>#</td>
<td>当跟o，x或X一起使用时，用来指示值是以0，0x或0X开头。当跟a，A，e，E，f，F，g，G一起使用时，强制输出小数点后的位数。默认情况下，如果没有小数点后的位数则不输出小数点</td>
</tr>
<tr>
<td>0</td>
<td>当对输出指定宽度时(见下表)，不足位数在左侧以0补齐</td>
</tr>
</tbody>
</table>
<p>对格式串中的<code>width</code>域的解释如下：</p>
<table>
<thead>
<tr>
<th>width</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>数字</td>
<td>输出字符串的最小宽度，当不足宽度时以空格或其它指定的字符补齐；当要输出的内容比指定的宽度长时，内容不会被截断</td>
</tr>
<tr>
<td>*</td>
<td>未在格式串中指定宽度，而是由对应的一个额外的参数（来自于参数列表）来指定。</td>
</tr>
</tbody>
</table>
<p>对格式串中的 <code>.precision</code>域的解释如下：</p>
<table>
<thead>
<tr>
<th>.precision</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>.number</td>
<td>当和整数标识符(d，i，o，u，x，X）一起使用时，表示要输出的总位数，不够时在左侧以0补齐。当要输出的数字超出这个长度时不会被截断。当<code>precision</code>是0的时候，表示对0不会输出任何字符。当同a，A，e，E，f或F一起使用时，表示要输出的小数点后的位数。当结合g或G使用时，表示要输出的最大有效位数。当与s结合使用时，表示要输出的最大字符数，默认情况下会一直输出到空字符结束。</td>
</tr>
<tr>
<td>.*</td>
<td>未在格式串中指定精度，而是由对应的一个额外参数（来自于参数列表）来指定。</td>
</tr>
</tbody>
</table>
<p>而格式串中的<code>length</code>与<a href="#scanf">scanf</a>格式串中的<code>length</code>域有相同的解释，不再重复。</p>
<h3 id="写入文件内容">写入文件内容</h3><p>当需要输出内容到文件时，对于编写算法程序，推荐的做法是通过输出重定向或<code>freopen</code>让<code>stdout</code>指向目标输出文件。然而如果确需要直接写入文件，可以使用<code>fopen</code>以写入的方式打开文件并进行写入，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FILE *file;</span><br><span class="line">file = fopen(<span class="string">"test.txt"</span>, <span class="string">"wt"</span>);</span><br><span class="line">putc(<span class="string">'a'</span>, file);</span><br><span class="line">fclose(file);</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，<code>putc</code>的作用是向文件<code>test.txt</code>中输出一个指定的字符。除此之外，还有其它写入文件内容的函数，如<code>fputc</code>，<code>fputs</code>，<code>fprintf</code>等。由于算法程序大多是顺序的输出，因此输出重定向结合写入标准输出设备的方式更实用。文件的写入方式便不再赘述，有关详细内容可参考<a href="http://www.cplusplus.com/reference/cstdio/" target="_blank" rel="external">链接</a>。</p>
<h1 id="输出的效率">输出的效率</h1><p>算法程序的一个重要考量因素是程序的运行效率。除去程序逻辑本身是算法效率高低的主要因素之外，输出的效率也是一个应该考虑的因素，尤其是当输出的数据量非常大时。例如在一个非常大的循环内输出数据，而输出又被定向到文件内，这样多次的文件写入必然会造成效率的损失。因此，把要输出的数据缓存在一个内存空间内，待所有数据准备完毕后，一次性输出到文件内，则可提高一定的效率。</p>
<h1 id="头文件">头文件</h1><p><code>std::cin</code>和<code>std::cout</code>来自于头文件<code>&lt;iostream&gt;</code><br><code>std::cin</code>和<code>std::cout</code>输入输出格式的控制函数存在于<code>&lt;iomanip&gt;</code>头文件中。<br><code>scanf</code>和<code>printf</code>函数来自于头文件<code>&lt;stdio.h&gt;</code></p>
<h1 id="TL;DR">TL;DR</h1><p>基本的输入输出是算法程序的重要基础。在C++算法程序中，输入输出的重定向可以方便快捷地让标准输入输出设备指向所指定的文件。而C++ STL中的<code>cin</code>和<code>cout</code>流可以很方便地从标准输入设备读取数据和向标准输出设备输出数据。<code>scanf</code>和<code>printf</code>是C风格的输入输出函数。熟练掌握输入输出数据格式的控制，是正确处理输入输出文件的重要前提，也是保证算法程序正确性的一个基本前提。</p>
<p>把要输出的内容缓存到一个内存空间内，待所有数据准备完毕后一次性把结果写出到输出设备中，可以一定程度地提高程序的运行效率。当然，这需要在内存的占用空间和算法效率之间做一些权衡。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>算法题目都是要求对于给定的输入，在规定时间内把结果输出到指定的设备上。因此输入输出是做算法的最基本条件。</p>
<h1 id="输入">输入</h1><p>C++中输入有两种常见的形式：来自标准输入设备<code>stdin</code>和来自文件。</p>
<h2 id="标准输入设备stdin">标准输入设备stdin</h2><h3 id="输入重定向">输入重定向</h3><p>默认情况下<code>stdin</code>来自于键盘的输入，然而我们可以把它重定向到任何其它可用的设备，比如常见的文件。在常见的系统中，对于一个控制台程序，我们可以用输入重定向来把标准输入重定向到文件设备。例如下列代码把程序<code>test</code>的标准输入重定向到了文件<code>file1.txt</code>:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test &lt; file1.txt</span><br></pre></td></tr></table></figure></p>
<p>这是一个非常实用的功能：在程序算法题中常见的输入是一个文件，如果通过把文件内容粘贴到控制台程序来实现输入会很不方便，尤其是当文件内容非常大的时候。</p>
<p>除输入重定向之外，还可以通过<code>freopen</code>来使一个已经存在的流<code>stream</code>指向目标文件。当然，<code>stdin</code>，<code>stdout</code>，以及<code>stderr</code>都是流的一种，因此我们可以用该函数来实现输入的重定向。下面的代码实现了把标准输入重定向到文件<code>file1.txt</code>:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">freopen(“file1.txt”, “r”, <span class="built_in">stdin</span>);</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="C++" scheme="http://blog.liushuping.com/tags/C/"/>
    
      <category term="算法" scheme="http://blog.liushuping.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="C++算法笔记" scheme="http://blog.liushuping.com/categories/C-%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Backbone router demo]]></title>
    <link href="http://blog.liushuping.com/2015/08/09/Backbone-router-demo/"/>
    <id>http://blog.liushuping.com/2015/08/09/Backbone-router-demo/</id>
    <published>2015-08-09T14:48:36.000Z</published>
    <updated>2015-10-25T10:40:14.000Z</updated>
    <content type="html"><![CDATA[<p>这是一个简单的关于Backbone router的演示，下面的例子演示了，通过Backbone的router和pushState来达到省略URL中的Hash符号的目的。</p>
<p>首先定义一个App需要的router，例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> AppRouter = Backbone.Router.extend(&#123;  </span><br><span class="line">    routes : &#123;  </span><br><span class="line">        <span class="string">'help'</span>: <span class="string">'help'</span>,  </span><br><span class="line">        <span class="string">'search/:query'</span>: <span class="string">'search'</span>, </span><br><span class="line">        <span class="string">'search/:query/:page'</span>: <span class="string">'search'</span></span><br><span class="line">    &#125;,   </span><br><span class="line"></span><br><span class="line">    search: <span class="function"><span class="keyword">function</span>(<span class="params">query, page</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (page == <span class="literal">null</span>) &#123;</span><br><span class="line">          alert(<span class="string">'query: '</span> + query);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          alert(<span class="string">'query: '</span> + query + <span class="string">', page: '</span> + page);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>接下来启动<code>history</code>的状态记录：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Backbone.history.start(&#123;pushState: <span class="literal">true</span>&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这里如果页面所在的目录不是根目录，则需要添加root参数。</p>
<p>然后我们就可以用router来控制URL状态了：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> router = <span class="keyword">new</span> AppRouter();</span><br><span class="line">router.navigate(<span class="string">'search/myquery/123'</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure></p>
<p>这很有用，然而并不是所有的状态变化都是我们通过代码来修改<code>router</code>的状态，更多的是可能交给用户去“导航”，比如<code>&lt;a&gt;</code>标签。然而不幸的是，<code>Backbone</code>并没有对<code>&lt;a&gt;</code>标签做任何的定制，也就是说如果不做任何处理的话，<code>&lt;a&gt;</code>标签的点击事件还是会触发浏览器向服务器发起HTTP请求的，这并不是我们想要的。</p>
<p>因此，我们应该做的是阻断a标签的<code>click</code>事件，在事件里面阻止<code>&lt;a&gt;</code>标签的默认行为，修改为我们的<code>router.navigate</code>行为。例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).on(<span class="string">'click'</span>, <span class="string">'a'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> href = $(<span class="keyword">this</span>).prop(<span class="string">'href'</span>);</span><br><span class="line">    href = href.slice(...) <span class="comment">// 去掉root部分</span></span><br><span class="line">    router.navigate(href, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果我们并不想这样处理所有的<code>&lt;a&gt;</code>标签，比如仍保留某些向服务器发送HTTP请求的功能。这可以通过有条件的选择，一个好的方式是把所有不期望向服务器发送请求的<code>&lt;a&gt;</code>标签的href都以<code>&#39;#&#39;</code>开头，否则则认为向服务器发送请求。此时阻断代码可以写成如下的样子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).on(<span class="string">'click'</span>, <span class="string">'a[href*="#"]'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> href = $(<span class="keyword">this</span>).prop(<span class="string">'href'</span>);</span><br><span class="line">    href = href.slice(...) <span class="comment">// 去掉root部分</span></span><br><span class="line">    router.navigate(href, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>点击下面的链接及浏览器的前进后退按钮查看运行效果：</p>
<p><base href="/2015/08/09/Backbone-router-demo/"></p>
<div id="demo"><br>  <a href="#help">help</a><br>  <a href="#search/myquery">search “myquery”</a><br>  <a href="#search/myquery/page1">search “myquery/page1”</a><br><br>  <script src="http://cdn.staticfile.org/jquery/2.1.1/jquery.min.js"></script><br>  <script src="http://cdn.staticfile.org/underscore.js/1.7.0/underscore-min.js"></script><br>  <script src="http://cdn.staticfile.org/backbone.js/1.1.2/backbone-min.js"></script><br>  <script src="/assets/backbone-router-demo.js"></script><br></div>]]></content>
    <summary type="html">
    <![CDATA[<p>这是一个简单的关于Backbone router的演示，下面的例子演示了，通过Backbone的router和pushState来达到省略URL中的Hash符号的目的。</p>
<p>首先定义一个App需要的router，例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> AppRouter = Backbone.Router.extend(&#123;  </span><br><span class="line">    routes : &#123;  </span><br><span class="line">        <span class="string">'help'</span>: <span class="string">'help'</span>,  </span><br><span class="line">        <span class="string">'search/:query'</span>: <span class="string">'search'</span>, </span><br><span class="line">        <span class="string">'search/:query/:page'</span>: <span class="string">'search'</span></span><br><span class="line">    &#125;,   </span><br><span class="line"></span><br><span class="line">    search: <span class="function"><span class="keyword">function</span>(<span class="params">query, page</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (page == <span class="literal">null</span>) &#123;</span><br><span class="line">          alert(<span class="string">'query: '</span> + query);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          alert(<span class="string">'query: '</span> + query + <span class="string">', page: '</span> + page);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="Backbone" scheme="http://blog.liushuping.com/tags/Backbone/"/>
    
      <category term="Route" scheme="http://blog.liushuping.com/tags/Route/"/>
    
      <category term="Backbone" scheme="http://blog.liushuping.com/categories/Backbone/"/>
    
  </entry>
  
</feed>
